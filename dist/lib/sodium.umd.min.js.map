{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sodium.umd.min.js","webpack:///webpack/bootstrap 77c2100eaa3515868b63","webpack:///./node_modules/typescript-collections/dist/lib/util.js","webpack:///./src/lib/Transaction.ts","webpack:///./src/lib/Vertex.ts","webpack:///./src/lib/Stream.ts","webpack:///./node_modules/typescript-collections/dist/lib/arrays.js","webpack:///./node_modules/typescript-collections/dist/lib/Dictionary.js","webpack:///./src/lib/Lambda.ts","webpack:///./src/lib/Cell.ts","webpack:///./node_modules/typescript-collections/dist/lib/LinkedList.js","webpack:///./src/lib/TimerSystem.ts","webpack:///./node_modules/typescript-collections/dist/lib/index.js","webpack:///./node_modules/typescript-collections/dist/lib/Set.js","webpack:///./node_modules/typescript-collections/dist/lib/Queue.js","webpack:///./node_modules/typescript-collections/dist/lib/Heap.js","webpack:///./src/lib/CoalesceHandler.ts","webpack:///./src/lib/Lazy.ts","webpack:///./src/lib/Operational.ts","webpack:///./src/lib/Unit.ts","webpack:///./src/lib/LazyCell.ts","webpack:///./src/lib/StreamSink.ts","webpack:///./src/lib/CellSink.ts","webpack:///./src/lib/Sodium.ts","webpack:///./node_modules/typescript-collections/dist/lib/Bag.js","webpack:///./node_modules/typescript-collections/dist/lib/BSTree.js","webpack:///./node_modules/typescript-collections/dist/lib/LinkedDictionary.js","webpack:///./node_modules/typescript-collections/dist/lib/MultiDictionary.js","webpack:///./node_modules/typescript-collections/dist/lib/PriorityQueue.js","webpack:///./node_modules/typescript-collections/dist/lib/Stack.js","webpack:///./src/lib/Listener.ts","webpack:///./src/lib/CellLoop.ts","webpack:///./src/lib/Tuple2.ts","webpack:///./src/lib/SecondsTimerSystem.ts","webpack:///./src/lib/MillisecondsTimerSystem.ts","webpack:///./src/lib/IOAction.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","defaultCompare","a","b","defaultEquals","defaultToString","item","isUndefined","isString","toString","makeString","join","toret","first","prop","has","isFunction","func","obj","reverseCompareFunction","compareFunction","v","compareToEquals","_hasOwnProperty","value","typescript_collections_1","Entry","rank","action","seq","nextSeq","Transaction","inCallback","toRegen","prioritizedQ","PriorityQueue","entries","Set","lastQ","postQ","requestRegen","prioritized","target","f","e","enqueue","add","last","h","push","post","childIx","length","existing","neu","checkRegen","clear","es","toArray","isActive","currentTransaction","close","isEmpty","dequeue","remove","parent_1","err","onStart","r","onStartHooks","run","transWas","runningOnStartHooks","getTotalRegistrations","totalRegistrations","setVerbose","verbose","describeAll","visited","contains","id","console","log","descr","chs","children","Source","origin","register_","registered","deregister_","Error","register","_this","increment","decrement","deregister","Color","roots","nextID","Vertex","sources","targets","childrn","color","black","buffered","refCountAdj","refCount","collectCycles","incRefCount","anyChanged","ensureBiggerThan","decRefCount","matched","splice","addSource","src","limit","colStr","gray","white","purple","str","referrer","release","possibleRoots","free","markRoots","scanRoots","collectRoots","newRoots","markGray","scan","collectWhite","scanBlack","NULL","__extends","extendStatics","setPrototypeOf","__proto__","Array","__","constructor","create","Lambda_1","Vertex_1","Transaction_1","CoalesceHandler_1","Cell_1","Listener_1","Lazy_1","LazyCell_1","Stream","vertex","listeners","firings","getVertex__","map","out","StreamWithSend","ff","Lambda1_toFunction","listen_","send_","concat","toSources","Lambda1_deps","mapTo","orElse","merge","left","right","merge_","coalesce__","coalescer","CoalesceHandler","Lambda2_deps","filter","filterNotNull","gate","snapshot","pred","snapshot1","sampleNoTrans__","f_","Lambda2_toFunction","snapshot3","Lambda3_toFunction","Lambda3_deps","snapshot4","Lambda4_toFunction","Lambda4_deps","snapshot5","Lambda5_toFunction","Lambda5_deps","snapshot6","Lambda6_toFunction","Lambda6_deps","hold","initValue","Cell","holdLazy","LazyCell","collect","initState","collectLazy","Lazy","ea","StreamLoop","ebs","eb","bs","es_out","loop","accum","accumLazy","once","me","listen","suppressEarlierFirings","listener","Listener","firings_1","slice","removed","_super","setVertex__","assigned__","sa_out","indexOf","array","equalsFunction","equals","util","lastIndexOf","index","frequency","freq","array1","array2","copy","swap","j","temp","forEach","callback","_i","array_1","Dictionary","toStrFunction","table","nElements","toStr","getValue","key","pair","setValue","ret","k","previousElement","undefined","keys","name_1","values","name_2","name_3","containsKey","size","default","lambda1","deps","Lambda1","lambda2","Lambda2","lambda3","Lambda3","lambda4","Lambda4","lambda5","Lambda5","lambda6","Lambda6","ss","dep","Stream_1","Operational_1","LazySample","cell","hasValue","ApplyState","f_present","a_present","setStream","valueUpdate","lazyInitValue","getStream__","sample","sampleLazy","sampleLazyNoTrans__","Operational","updates","lift","fn0","fn","cf","aa","bb","apply","lift3","mf","cc","lift4","dd","lift5","ee","lift6","ca","state","cf_value","ca_value","src1","src2","switchC","cca","za","ba","last_ca","cca_value","kill2","kill1","switchS","csa","h2","sa","arrays","LinkedList","firstNode","lastNode","newNode","createNode","next","prev","nodeAtIndex","element","elementAtIndex","node","equalsF","currentNode","previous","other","eqF","equalsAux","n1","n2","removeElementAtIndex","reverse","current","CellSink_1","TimerSystemImpl","Event","t","sAlarm","TimerSystem","impl","eventQueue","BSTree","tMinimum","timeSnk","CellSink","now","time","Math","max","ev","mev","minimum","send","at","tAlarm","cancelCurrent","active","tAl","sampled","updateTimer","setTimer","kill","oAlarm","_arrays","Bag_1","Bag","BSTree_1","Dictionary_1","Heap_1","Heap","LinkedDictionary_1","LinkedDictionary","LinkedList_1","MultiDictionary_1","MultiDictionary","Queue_1","Queue","PriorityQueue_1","Set_1","Stack_1","Stack","_util","toStringFunction","dictionary","intersection","otherSet","set","union","difference","isSubsetOf","isSub","list","elem","el","peek","collections","data","compare","leftChildIndex","nodeIndex","rightChildIndex","parentIndex","floor","minIndex","leftChild","rightChild","siftUp","parent","siftDown","min","removeRoot","equF","accumValid","Unit_1","sSpark","Unit","UNIT","sInitial","defer","split","as","StreamSink","StreamSink_1","CellLoop_1","CellLoop","Tuple2_1","Tuple2","TimerSystem_1","SecondsTimerSystem_1","SecondsTimerSystem","MillisecondsTimerSystem_1","MillisecondsTimerSystem","IOAction_1","IOAction","toStrF","nCopies","copies","count","values_1","toSet","elements","elements_1","ele","insertNode","searchNode","removeNode","inorderTraversal","inorderTraversalAux","stop","preorderTraversal","preorderTraversalAux","postorderTraversal","postorderTraversalAux","levelTraversal","levelTraversalAux","minimumAux","maximum","maximumAux","height","heightAux","cmp","leftCh","rightCh","transplant","y","signal","queue","position","LinkedDictionaryPair","unlink","head","tail","appendToTail","entry","getLinkedDictionaryPair","replace","oldPair","newPair","existingPair","crawlNode","valuesEqualsFunction","allowDuplicateValues","dict","allowDuplicate","_a","v_1","w","heap","pop","a_out","SecondsTimerSystemImpl","arguments","timeout","setTimeout","clearTimeout","Date","MillisecondsTimerSystemImpl","fromAsync","performIO"],"mappings":"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","file":"sodium.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Sodium\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sodium\"] = factory();\n\telse\n\t\troot[\"Sodium\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Sodium\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sodium\"] = factory();\n\telse\n\t\troot[\"Sodium\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexports.has = function (obj, prop) {\n    return _hasOwnProperty.call(obj, prop);\n};\n/**\n * Default function to compare element order.\n * @function\n */\nfunction defaultCompare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a === b) {\n        return 0;\n    }\n    else {\n        return 1;\n    }\n}\nexports.defaultCompare = defaultCompare;\n/**\n * Default function to test equality.\n * @function\n */\nfunction defaultEquals(a, b) {\n    return a === b;\n}\nexports.defaultEquals = defaultEquals;\n/**\n * Default function to convert an object to a string.\n * @function\n */\nfunction defaultToString(item) {\n    if (item === null) {\n        return 'COLLECTION_NULL';\n    }\n    else if (isUndefined(item)) {\n        return 'COLLECTION_UNDEFINED';\n    }\n    else if (isString(item)) {\n        return '$s' + item;\n    }\n    else {\n        return '$o' + item.toString();\n    }\n}\nexports.defaultToString = defaultToString;\n/**\n* Joins all the properies of the object using the provided join string\n*/\nfunction makeString(item, join) {\n    if (join === void 0) { join = ','; }\n    if (item === null) {\n        return 'COLLECTION_NULL';\n    }\n    else if (isUndefined(item)) {\n        return 'COLLECTION_UNDEFINED';\n    }\n    else if (isString(item)) {\n        return item.toString();\n    }\n    else {\n        var toret = '{';\n        var first = true;\n        for (var prop in item) {\n            if (exports.has(item, prop)) {\n                if (first) {\n                    first = false;\n                }\n                else {\n                    toret = toret + join;\n                }\n                toret = toret + prop + ':' + item[prop];\n            }\n        }\n        return toret + '}';\n    }\n}\nexports.makeString = makeString;\n/**\n * Checks if the given argument is a function.\n * @function\n */\nfunction isFunction(func) {\n    return (typeof func) === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Checks if the given argument is undefined.\n * @function\n */\nfunction isUndefined(obj) {\n    return (typeof obj) === 'undefined';\n}\nexports.isUndefined = isUndefined;\n/**\n * Checks if the given argument is a string.\n * @function\n */\nfunction isString(obj) {\n    return Object.prototype.toString.call(obj) === '[object String]';\n}\nexports.isString = isString;\n/**\n * Reverses a compare function.\n * @function\n */\nfunction reverseCompareFunction(compareFunction) {\n    if (!isFunction(compareFunction)) {\n        return function (a, b) {\n            if (a < b) {\n                return 1;\n            }\n            else if (a === b) {\n                return 0;\n            }\n            else {\n                return -1;\n            }\n        };\n    }\n    else {\n        return function (d, v) {\n            return compareFunction(d, v) * -1;\n        };\n    }\n}\nexports.reverseCompareFunction = reverseCompareFunction;\n/**\n * Returns an equal function given a compare function.\n * @function\n */\nfunction compareToEquals(compareFunction) {\n    return function (a, b) {\n        return compareFunction(a, b) === 0;\n    };\n}\nexports.compareToEquals = compareToEquals;\n//# sourceMappingURL=util.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_collections_1 = __webpack_require__(10);\r\nvar Entry = (function () {\r\n    function Entry(rank, action) {\r\n        this.rank = rank;\r\n        this.action = action;\r\n        this.seq = Entry.nextSeq++;\r\n    }\r\n    Entry.prototype.toString = function () {\r\n        return this.seq.toString();\r\n    };\r\n    Entry.nextSeq = 0;\r\n    return Entry;\r\n}());\r\nexports.Entry = Entry;\r\nvar Transaction = (function () {\r\n    function Transaction() {\r\n        this.inCallback = 0;\r\n        this.toRegen = false;\r\n        this.prioritizedQ = new typescript_collections_1.PriorityQueue(function (a, b) {\r\n            // Note: Low priority numbers are treated as \"greater\" according to this\r\n            // comparison, so that the lowest numbers are highest priority and go first.\r\n            if (a.rank.rank < b.rank.rank)\r\n                return 1;\r\n            if (a.rank.rank > b.rank.rank)\r\n                return -1;\r\n            if (a.seq < b.seq)\r\n                return 1;\r\n            if (a.seq > b.seq)\r\n                return -1;\r\n            return 0;\r\n        });\r\n        this.entries = new typescript_collections_1.Set(function (a) { return a.toString(); });\r\n        this.lastQ = [];\r\n        this.postQ = null;\r\n    }\r\n    Transaction.prototype.requestRegen = function () {\r\n        this.toRegen = true;\r\n    };\r\n    Transaction.prototype.prioritized = function (target, f) {\r\n        var e = new Entry(target, f);\r\n        this.prioritizedQ.enqueue(e);\r\n        this.entries.add(e);\r\n    };\r\n    Transaction.prototype.last = function (h) {\r\n        this.lastQ.push(h);\r\n    };\r\n    /**\r\n     * Add an action to run after all last() actions.\r\n     */\r\n    Transaction.prototype.post = function (childIx, action) {\r\n        if (this.postQ == null)\r\n            this.postQ = [];\r\n        // If an entry exists already, combine the old one with the new one.\r\n        while (this.postQ.length <= childIx)\r\n            this.postQ.push(null);\r\n        var existing = this.postQ[childIx], neu = existing === null ? action\r\n            : function () {\r\n                existing();\r\n                action();\r\n            };\r\n        this.postQ[childIx] = neu;\r\n    };\r\n    // If the priority queue has entries in it when we modify any of the nodes'\r\n    // ranks, then we need to re-generate it to make sure it's up-to-date.\r\n    Transaction.prototype.checkRegen = function () {\r\n        if (this.toRegen) {\r\n            this.toRegen = false;\r\n            this.prioritizedQ.clear();\r\n            var es = this.entries.toArray();\r\n            for (var i = 0; i < es.length; i++)\r\n                this.prioritizedQ.enqueue(es[i]);\r\n        }\r\n    };\r\n    Transaction.prototype.isActive = function () {\r\n        return Transaction.currentTransaction ? true : false;\r\n    };\r\n    Transaction.prototype.close = function () {\r\n        while (true) {\r\n            this.checkRegen();\r\n            if (this.prioritizedQ.isEmpty())\r\n                break;\r\n            var e = this.prioritizedQ.dequeue();\r\n            this.entries.remove(e);\r\n            e.action();\r\n        }\r\n        for (var i = 0; i < this.lastQ.length; i++)\r\n            this.lastQ[i]();\r\n        this.lastQ = [];\r\n        if (this.postQ != null) {\r\n            for (var i = 0; i < this.postQ.length; i++) {\r\n                if (this.postQ[i] != null) {\r\n                    var parent_1 = Transaction.currentTransaction;\r\n                    try {\r\n                        if (i > 0) {\r\n                            Transaction.currentTransaction = new Transaction();\r\n                            try {\r\n                                this.postQ[i]();\r\n                                Transaction.currentTransaction.close();\r\n                            }\r\n                            catch (err) {\r\n                                Transaction.currentTransaction.close();\r\n                                throw err;\r\n                            }\r\n                        }\r\n                        else {\r\n                            Transaction.currentTransaction = null;\r\n                            this.postQ[i]();\r\n                        }\r\n                        Transaction.currentTransaction = parent_1;\r\n                    }\r\n                    catch (err) {\r\n                        Transaction.currentTransaction = parent_1;\r\n                        throw err;\r\n                    }\r\n                }\r\n            }\r\n            this.postQ = null;\r\n        }\r\n    };\r\n    /**\r\n     * Add a runnable that will be executed whenever a transaction is started.\r\n     * That runnable may start transactions itself, which will not cause the\r\n     * hooks to be run recursively.\r\n     *\r\n     * The main use case of this is the implementation of a time/alarm system.\r\n     */\r\n    Transaction.onStart = function (r) {\r\n        Transaction.onStartHooks.push(r);\r\n    };\r\n    Transaction.run = function (f) {\r\n        var transWas = Transaction.currentTransaction;\r\n        if (transWas === null) {\r\n            if (!Transaction.runningOnStartHooks) {\r\n                Transaction.runningOnStartHooks = true;\r\n                try {\r\n                    for (var i = 0; i < Transaction.onStartHooks.length; i++)\r\n                        Transaction.onStartHooks[i]();\r\n                }\r\n                finally {\r\n                    Transaction.runningOnStartHooks = false;\r\n                }\r\n            }\r\n            Transaction.currentTransaction = new Transaction();\r\n        }\r\n        try {\r\n            var a = f();\r\n            if (transWas === null) {\r\n                Transaction.currentTransaction.close();\r\n                Transaction.currentTransaction = null;\r\n            }\r\n            return a;\r\n        }\r\n        catch (err) {\r\n            if (transWas === null) {\r\n                Transaction.currentTransaction.close();\r\n                Transaction.currentTransaction = null;\r\n            }\r\n            throw err;\r\n        }\r\n    };\r\n    Transaction.currentTransaction = null;\r\n    Transaction.onStartHooks = [];\r\n    Transaction.runningOnStartHooks = false;\r\n    return Transaction;\r\n}());\r\nexports.Transaction = Transaction;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar totalRegistrations = 0;\r\nfunction getTotalRegistrations() {\r\n    return totalRegistrations;\r\n}\r\nexports.getTotalRegistrations = getTotalRegistrations;\r\nvar Source = (function () {\r\n    function Source(origin, register_) {\r\n        this.registered = false;\r\n        this.deregister_ = null;\r\n        if (origin === null)\r\n            throw new Error(\"null origin!\");\r\n        this.origin = origin;\r\n        this.register_ = register_;\r\n    }\r\n    Source.prototype.register = function (target) {\r\n        var _this = this;\r\n        if (!this.registered) {\r\n            this.registered = true;\r\n            if (this.register_ !== null)\r\n                this.deregister_ = this.register_();\r\n            else {\r\n                this.origin.increment(target);\r\n                this.deregister_ = function () { return _this.origin.decrement(target); };\r\n            }\r\n        }\r\n    };\r\n    Source.prototype.deregister = function (target) {\r\n        if (this.registered) {\r\n            this.registered = false;\r\n            if (this.deregister_ !== null)\r\n                this.deregister_();\r\n        }\r\n    };\r\n    return Source;\r\n}());\r\nexports.Source = Source;\r\nvar Color;\r\n(function (Color) {\r\n    Color[Color[\"black\"] = 0] = \"black\";\r\n    Color[Color[\"gray\"] = 1] = \"gray\";\r\n    Color[Color[\"white\"] = 2] = \"white\";\r\n    Color[Color[\"purple\"] = 3] = \"purple\";\r\n})(Color = exports.Color || (exports.Color = {}));\r\n;\r\nvar roots = [];\r\nvar nextID = 0;\r\nvar verbose = false;\r\nfunction setVerbose(v) { verbose = v; }\r\nexports.setVerbose = setVerbose;\r\nfunction describeAll(v, visited) {\r\n    if (visited.contains(v.id))\r\n        return;\r\n    console.log(v.descr());\r\n    visited.add(v.id);\r\n    var chs = v.children();\r\n    for (var i = 0; i < chs.length; i++)\r\n        describeAll(chs[i], visited);\r\n}\r\nexports.describeAll = describeAll;\r\nvar Vertex = (function () {\r\n    function Vertex(name, rank, sources) {\r\n        this.targets = [];\r\n        this.childrn = [];\r\n        this.visited = false;\r\n        // --------------------------------------------------------\r\n        // Synchronous Cycle Collection algorithm presented in \"Concurrent\r\n        // Cycle Collection in Reference Counted Systems\" by David F. Bacon\r\n        // and V.T. Rajan.\r\n        this.color = Color.black;\r\n        this.buffered = false;\r\n        this.refCountAdj = 0;\r\n        this.name = name;\r\n        this.rank = rank;\r\n        this.sources = sources;\r\n        this.id = nextID++;\r\n    }\r\n    Vertex.prototype.refCount = function () { return this.targets.length; };\r\n    ;\r\n    Vertex.prototype.register = function (target) {\r\n        return this.increment(target);\r\n    };\r\n    Vertex.prototype.deregister = function (target) {\r\n        if (verbose)\r\n            console.log(\"deregister \" + this.descr() + \" => \" + target.descr());\r\n        this.decrement(target);\r\n        Vertex.collectCycles();\r\n    };\r\n    Vertex.prototype.incRefCount = function (target) {\r\n        var anyChanged = false;\r\n        if (this.refCount() == 0) {\r\n            for (var i = 0; i < this.sources.length; i++)\r\n                this.sources[i].register(this);\r\n        }\r\n        this.targets.push(target);\r\n        target.childrn.push(this);\r\n        if (target.ensureBiggerThan(this.rank))\r\n            anyChanged = true;\r\n        totalRegistrations++;\r\n        return anyChanged;\r\n    };\r\n    Vertex.prototype.decRefCount = function (target) {\r\n        if (verbose)\r\n            console.log(\"DEC \" + this.descr());\r\n        var matched = false;\r\n        for (var i = 0; i < target.childrn.length; i++)\r\n            if (target.childrn[i] === this) {\r\n                target.childrn.splice(i, 1);\r\n            }\r\n        for (var i = 0; i < this.targets.length; i++)\r\n            if (this.targets[i] === target) {\r\n                this.targets.splice(i, 1);\r\n                matched = true;\r\n                break;\r\n            }\r\n        if (matched) {\r\n            if (this.refCount() == 0) {\r\n                for (var i = 0; i < this.sources.length; i++)\r\n                    this.sources[i].deregister(this);\r\n            }\r\n            totalRegistrations--;\r\n        }\r\n    };\r\n    Vertex.prototype.addSource = function (src) {\r\n        this.sources.push(src);\r\n        if (this.refCount() > 0)\r\n            src.register(this);\r\n    };\r\n    Vertex.prototype.ensureBiggerThan = function (limit) {\r\n        if (this.rank > limit || this.visited)\r\n            return false;\r\n        this.visited = true;\r\n        this.rank = limit + 1;\r\n        for (var i = 0; i < this.targets.length; i++)\r\n            this.targets[i].ensureBiggerThan(this.rank);\r\n        this.visited = false;\r\n        return true;\r\n    };\r\n    Vertex.prototype.descr = function () {\r\n        var colStr = null;\r\n        switch (this.color) {\r\n            case Color.black:\r\n                colStr = \"black\";\r\n                break;\r\n            case Color.gray:\r\n                colStr = \"gray\";\r\n                break;\r\n            case Color.white:\r\n                colStr = \"white\";\r\n                break;\r\n            case Color.purple:\r\n                colStr = \"purple\";\r\n                break;\r\n        }\r\n        var str = this.id + \" \" + this.name + \" [\" + this.refCount() + \"/\" + this.refCountAdj + \"] \" + colStr + \" ->\";\r\n        var chs = this.children();\r\n        for (var i = 0; i < chs.length; i++) {\r\n            str = str + \" \" + chs[i].id;\r\n        }\r\n        return str;\r\n    };\r\n    Vertex.prototype.children = function () { return this.childrn; };\r\n    Vertex.prototype.increment = function (referrer) {\r\n        return this.incRefCount(referrer);\r\n    };\r\n    Vertex.prototype.decrement = function (referrer) {\r\n        this.decRefCount(referrer);\r\n        if (this.refCount() == 0)\r\n            this.release();\r\n        else\r\n            this.possibleRoots();\r\n    };\r\n    Vertex.prototype.release = function () {\r\n        this.color = Color.black;\r\n        if (!this.buffered)\r\n            this.free();\r\n    };\r\n    Vertex.prototype.free = function () {\r\n        while (this.targets.length > 0)\r\n            this.decRefCount(this.targets[0]);\r\n    };\r\n    Vertex.prototype.possibleRoots = function () {\r\n        if (this.color != Color.purple) {\r\n            this.color = Color.purple;\r\n            if (!this.buffered) {\r\n                this.buffered = true;\r\n                roots.push(this);\r\n            }\r\n        }\r\n    };\r\n    Vertex.collectCycles = function () {\r\n        Vertex.markRoots();\r\n        Vertex.scanRoots();\r\n        Vertex.collectRoots();\r\n    };\r\n    Vertex.markRoots = function () {\r\n        var newRoots = [];\r\n        for (var i = 0; i < roots.length; i++) {\r\n            if (verbose)\r\n                console.log(\"markRoots \" + roots[i].descr()); // ###\r\n            if (roots[i].color == Color.purple) {\r\n                roots[i].markGray();\r\n                newRoots.push(roots[i]);\r\n            }\r\n            else {\r\n                roots[i].buffered = false;\r\n                if (roots[i].color == Color.black && roots[i].refCount() == 0)\r\n                    roots[i].free();\r\n            }\r\n        }\r\n        roots = newRoots;\r\n    };\r\n    Vertex.scanRoots = function () {\r\n        for (var i = 0; i < roots.length; i++)\r\n            roots[i].scan();\r\n    };\r\n    Vertex.collectRoots = function () {\r\n        for (var i = 0; i < roots.length; i++) {\r\n            roots[i].buffered = false;\r\n            roots[i].collectWhite();\r\n        }\r\n        roots = [];\r\n    };\r\n    Vertex.prototype.markGray = function () {\r\n        if (this.color != Color.gray) {\r\n            this.color = Color.gray;\r\n            var chs = this.children();\r\n            for (var i = 0; i < chs.length; i++) {\r\n                chs[i].refCountAdj--;\r\n                if (verbose)\r\n                    console.log(\"markGray \" + this.descr());\r\n                chs[i].markGray();\r\n            }\r\n        }\r\n    };\r\n    Vertex.prototype.scan = function () {\r\n        if (verbose)\r\n            console.log(\"scan \" + this.descr());\r\n        if (this.color == Color.gray) {\r\n            if (this.refCount() + this.refCountAdj > 0)\r\n                this.scanBlack();\r\n            else {\r\n                this.color = Color.white;\r\n                if (verbose)\r\n                    console.log(\"scan WHITE \" + this.descr());\r\n                var chs = this.children();\r\n                for (var i = 0; i < chs.length; i++)\r\n                    chs[i].scan();\r\n            }\r\n        }\r\n    };\r\n    Vertex.prototype.scanBlack = function () {\r\n        this.color = Color.black;\r\n        var chs = this.children();\r\n        for (var i = 0; i < chs.length; i++) {\r\n            chs[i].refCountAdj++;\r\n            if (verbose)\r\n                console.log(\"scanBlack \" + this.descr());\r\n            if (chs[i].color != Color.black)\r\n                chs[i].scanBlack();\r\n        }\r\n    };\r\n    Vertex.prototype.collectWhite = function () {\r\n        if (this.color == Color.white && !this.buffered) {\r\n            if (verbose)\r\n                console.log(\"collectWhite \" + this.descr());\r\n            this.color = Color.black;\r\n            this.refCountAdj = 0;\r\n            var chs = this.children();\r\n            for (var i = 0; i < chs.length; i++)\r\n                chs[i].collectWhite();\r\n            this.free();\r\n        }\r\n    };\r\n    Vertex.NULL = new Vertex(\"user\", 1e12, []);\r\n    return Vertex;\r\n}());\r\nexports.Vertex = Vertex;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Lambda_1 = __webpack_require__(6);\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar CoalesceHandler_1 = __webpack_require__(14);\r\nvar Cell_1 = __webpack_require__(7);\r\n//import { StreamLoop } from \"./StreamLoop\";\r\nvar Listener_1 = __webpack_require__(28);\r\nvar Lazy_1 = __webpack_require__(15);\r\nvar LazyCell_1 = __webpack_require__(18);\r\nvar Stream = (function () {\r\n    function Stream(vertex) {\r\n        this.listeners = [];\r\n        this.firings = [];\r\n        this.vertex = vertex ? vertex : new Vertex_1.Vertex(\"Stream\", 0, []);\r\n    }\r\n    Stream.prototype.getVertex__ = function () {\r\n        return this.vertex;\r\n    };\r\n    /**\r\n     * Transform the stream's event values according to the supplied function, so the returned\r\n     * Stream's event values reflect the value of the function applied to the input\r\n     * Stream's event values.\r\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    Stream.prototype.map = function (f) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda1_toFunction(f);\r\n        out.vertex = new Vertex_1.Vertex(\"map\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a));\r\n                }, false);\r\n            })\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda1_deps(f))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Transform the stream's event values into the specified constant value.\r\n     * @param b Constant value.\r\n     */\r\n    Stream.prototype.mapTo = function (b) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        out.vertex = new Vertex_1.Vertex(\"mapTo\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(b);\r\n                }, false);\r\n            })\r\n        ]);\r\n        return out;\r\n    };\r\n    /**\r\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\r\n     * in the simultaneous case.\r\n     * <p>\r\n     * In the case where two events are simultaneous (i.e. both\r\n     * within the same transaction), the event from <em>this</em> will take precedence, and\r\n     * the event from <em>s</em> will be dropped.\r\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\r\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\r\n     * <p>\r\n     * The name orElse() is used instead of merge() to make it really clear that care should\r\n     * be taken, because events can be dropped.\r\n     */\r\n    Stream.prototype.orElse = function (s) {\r\n        return this.merge(s, function (left, right) {\r\n            return left;\r\n        });\r\n    };\r\n    Stream.prototype.merge_ = function (s) {\r\n        var _this = this;\r\n        var out = new StreamWithSend();\r\n        var left = new Vertex_1.Vertex(\"merge\", 0, []);\r\n        left.sources.push(new Vertex_1.Source(this.vertex, function () {\r\n            return _this.listen_(left, function (a) {\r\n                out.send_(a);\r\n            }, false);\r\n        }));\r\n        out.vertex.sources = out.vertex.sources.concat([\r\n            new Vertex_1.Source(left, function () {\r\n                left.register(out.vertex);\r\n                return function () { left.deregister(out.vertex); };\r\n            }),\r\n            new Vertex_1.Source(s.vertex, function () {\r\n                return s.listen_(out.vertex, function (a) {\r\n                    out.send_(a);\r\n                }, false);\r\n            })\r\n        ]);\r\n        return out;\r\n    };\r\n    Stream.prototype.coalesce__ = function (f) {\r\n        var _this = this;\r\n        var out = new StreamWithSend();\r\n        var coalescer = new CoalesceHandler_1.CoalesceHandler(f, out);\r\n        out.vertex.sources = out.vertex.sources.concat([\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    coalescer.send_(a);\r\n                }, false);\r\n            })\r\n        ]).concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f)));\r\n        return out;\r\n    };\r\n    /**\r\n     * Merge two streams of the same type into one, so that events on either input appear\r\n     * on the returned stream.\r\n     * <p>\r\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\r\n     * occurring in the same transaction), combine them into one using the specified combining function\r\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\r\n     * The event from <em>this</em> will appear at the left input of the combining function, and\r\n     * the event from <em>s</em> will appear at the right.\r\n     * @param f Function to combine the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    Stream.prototype.merge = function (s, f) {\r\n        var _this = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            return _this.merge_(s).coalesce__(f);\r\n        });\r\n    };\r\n    /**\r\n     * Return a stream that only outputs events for which the predicate returns true.\r\n     */\r\n    Stream.prototype.filter = function (f) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda1_toFunction(f);\r\n        out.vertex = new Vertex_1.Vertex(\"filter\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    if (ff(a))\r\n                        out.send_(a);\r\n                }, false);\r\n            })\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda1_deps(f))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream that only outputs events that have present\r\n     * values, discarding null values.\r\n     */\r\n    Stream.prototype.filterNotNull = function () {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        out.vertex = new Vertex_1.Vertex(\"filterNotNull\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    if (a !== null)\r\n                        out.send_(a);\r\n                }, false);\r\n            })\r\n        ]);\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream that only outputs events from the input stream\r\n     * when the specified cell's value is true.\r\n     */\r\n    Stream.prototype.gate = function (c) {\r\n        return this.snapshot(c, function (a, pred) {\r\n            return pred ? a : null;\r\n        }).filterNotNull();\r\n    };\r\n    /**\r\n     * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\r\n     * at the time of the event firing, ignoring the stream's value.\r\n     */\r\n    Stream.prototype.snapshot1 = function (c) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot1\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(c.sampleNoTrans__());\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(c.getVertex__(), null)\r\n        ]);\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream whose events are the result of the combination using the specified\r\n     * function of the input stream's event value and the value of the cell at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n    Stream.prototype.snapshot = function (b, f_) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda2_toFunction(f_);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a, b.sampleNoTrans__()));\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(b.getVertex__(), null)\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f_))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream whose events are the result of the combination using the specified\r\n     * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n    Stream.prototype.snapshot3 = function (b, c, f_) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda3_toFunction(f_);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__()));\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(b.getVertex__(), null),\r\n            new Vertex_1.Source(c.getVertex__(), null)\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda3_deps(f_))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream whose events are the result of the combination using the specified\r\n     * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n    Stream.prototype.snapshot4 = function (b, c, d, f_) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda4_toFunction(f_);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(), d.sampleNoTrans__()));\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(b.getVertex__(), null),\r\n            new Vertex_1.Source(c.getVertex__(), null),\r\n            new Vertex_1.Source(d.getVertex__(), null)\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda4_deps(f_))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream whose events are the result of the combination using the specified\r\n     * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n    Stream.prototype.snapshot5 = function (b, c, d, e, f_) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda5_toFunction(f_);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(), d.sampleNoTrans__(), e.sampleNoTrans__()));\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(b.getVertex__(), null),\r\n            new Vertex_1.Source(c.getVertex__(), null),\r\n            new Vertex_1.Source(d.getVertex__(), null),\r\n            new Vertex_1.Source(e.getVertex__(), null)\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda5_deps(f_))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Return a stream whose events are the result of the combination using the specified\r\n     * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n    Stream.prototype.snapshot6 = function (b, c, d, e, f, f_) {\r\n        var _this = this;\r\n        var out = new StreamWithSend(null);\r\n        var ff = Lambda_1.Lambda6_toFunction(f_);\r\n        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n            new Vertex_1.Source(this.vertex, function () {\r\n                return _this.listen_(out.vertex, function (a) {\r\n                    out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(), d.sampleNoTrans__(), e.sampleNoTrans__(), f.sampleNoTrans__()));\r\n                }, false);\r\n            }),\r\n            new Vertex_1.Source(b.getVertex__(), null),\r\n            new Vertex_1.Source(c.getVertex__(), null),\r\n            new Vertex_1.Source(d.getVertex__(), null),\r\n            new Vertex_1.Source(e.getVertex__(), null),\r\n            new Vertex_1.Source(f.getVertex__(), null)\r\n        ].concat(Lambda_1.toSources(Lambda_1.Lambda6_deps(f_))));\r\n        return out;\r\n    };\r\n    /**\r\n     * Create a {@link Cell} with the specified initial value, that is updated\r\n     * by this stream's event values.\r\n     * <p>\r\n     * There is an implicit delay: State updates caused by event firings don't become\r\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\r\n     * until the following transaction. To put this another way,\r\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\r\n     * any state changes from the current transaction.\r\n     */\r\n    Stream.prototype.hold = function (initValue) {\r\n        return new Cell_1.Cell(initValue, this);\r\n    };\r\n    /**\r\n     * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\r\n     */\r\n    Stream.prototype.holdLazy = function (initValue) {\r\n        return new LazyCell_1.LazyCell(initValue, this);\r\n    };\r\n    /**\r\n     * Transform an event with a generalized state loop (a Mealy machine). The function\r\n     * is passed the input and the old state and returns the new state and output value.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    Stream.prototype.collect = function (initState, f) {\r\n        return this.collectLazy(new Lazy_1.Lazy(function () { return initState; }), f);\r\n    };\r\n    /**\r\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    Stream.prototype.collectLazy = function (initState, f) {\r\n        var ea = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            var es = new StreamLoop(), s = es.holdLazy(initState), ebs = ea.snapshot(s, f), eb = ebs.map(function (bs) { return bs.a; }), es_out = ebs.map(function (bs) { return bs.b; });\r\n            es.loop(es_out);\r\n            return eb;\r\n        });\r\n    };\r\n    /**\r\n     * Accumulate on input event, outputting the new state each time.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    Stream.prototype.accum = function (initState, f) {\r\n        return this.accumLazy(new Lazy_1.Lazy(function () { return initState; }), f);\r\n    };\r\n    /**\r\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    Stream.prototype.accumLazy = function (initState, f) {\r\n        var ea = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            var es = new StreamLoop(), s = es.holdLazy(initState), es_out = ea.snapshot(s, f);\r\n            es.loop(es_out);\r\n            return es_out.holdLazy(initState);\r\n        });\r\n    };\r\n    /**\r\n     * Return a stream that outputs only one value: the next event of the\r\n     * input stream, starting from the transaction in which once() was invoked.\r\n     */\r\n    Stream.prototype.once = function () {\r\n        /*\r\n            return Transaction.run(() => {\r\n                const ev = this,\r\n                    out = new StreamWithSend<A>();\r\n                let la : () => void = null;\r\n                la = ev.listen_(out.vertex, (a : A) => {\r\n                    if (la !== null) {\r\n                        out.send_(a);\r\n                        la();\r\n                        la = null;\r\n                    }\r\n                }, false);\r\n                return out;\r\n            });\r\n            */\r\n        // We can't use the implementation above, beacuse deregistering\r\n        // listeners triggers the exception\r\n        // \"send() was invoked before listeners were registered\"\r\n        // We can revisit this another time. For now we will use the less\r\n        // efficient implementation below.\r\n        var me = this;\r\n        return Transaction_1.Transaction.run(function () { return me.gate(me.mapTo(false).hold(true)); });\r\n    };\r\n    Stream.prototype.listen = function (h) {\r\n        var _this = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            return _this.listen_(Vertex_1.Vertex.NULL, h, false);\r\n        });\r\n    };\r\n    Stream.prototype.listen_ = function (target, h, suppressEarlierFirings) {\r\n        var _this = this;\r\n        if (this.vertex.register(target))\r\n            Transaction_1.Transaction.currentTransaction.requestRegen();\r\n        var listener = new Listener_1.Listener(h, target);\r\n        this.listeners.push(listener);\r\n        if (!suppressEarlierFirings && this.firings.length != 0) {\r\n            var firings_1 = this.firings.slice();\r\n            Transaction_1.Transaction.currentTransaction.prioritized(target, function () {\r\n                // Anything sent already in this transaction must be sent now so that\r\n                // there's no order dependency between send and listen.\r\n                for (var i = 0; i < firings_1.length; i++)\r\n                    h(firings_1[i]);\r\n            });\r\n        }\r\n        return function () {\r\n            var removed = false;\r\n            for (var i = 0; i < _this.listeners.length; i++) {\r\n                if (_this.listeners[i] == listener) {\r\n                    _this.listeners.splice(i, 1);\r\n                    removed = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (removed)\r\n                _this.vertex.deregister(target);\r\n        };\r\n    };\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Stream satisfies the Functor and Monoid Categories (and hence Semigroup)\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    Stream.prototype['fantasy-land/map'] = function (f) {\r\n        return this.map(f);\r\n    };\r\n    //concat :: Semigroup a => a ~> a -> a\r\n    Stream.prototype['fantasy-land/concat'] = function (a) {\r\n        return this.orElse(a);\r\n    };\r\n    //empty :: Monoid m => () -> m\r\n    Stream.prototype['fantasy-land/empty'] = function () {\r\n        return new Stream();\r\n    };\r\n    return Stream;\r\n}());\r\nexports.Stream = Stream;\r\nvar StreamWithSend = (function (_super) {\r\n    __extends(StreamWithSend, _super);\r\n    function StreamWithSend(vertex) {\r\n        return _super.call(this, vertex) || this;\r\n    }\r\n    StreamWithSend.prototype.setVertex__ = function (vertex) {\r\n        this.vertex = vertex;\r\n    };\r\n    StreamWithSend.prototype.send_ = function (a) {\r\n        var _this = this;\r\n        // We throw this error if we send into FRP logic that has been constructed\r\n        // but nothing is listening to it yet. We need to do it this way because\r\n        // it's the only way to manage memory in a language with no finalizers.\r\n        if (this.vertex.refCount() == 0)\r\n            throw new Error(\"send() was invoked before listeners were registered\");\r\n        if (this.firings.length == 0)\r\n            Transaction_1.Transaction.currentTransaction.last(function () {\r\n                _this.firings = [];\r\n            });\r\n        this.firings.push(a);\r\n        var listeners = this.listeners.slice();\r\n        var _loop_1 = function (i) {\r\n            var h = listeners[i].h;\r\n            Transaction_1.Transaction.currentTransaction.prioritized(listeners[i].target, function () {\r\n                Transaction_1.Transaction.currentTransaction.inCallback++;\r\n                try {\r\n                    h(a);\r\n                    Transaction_1.Transaction.currentTransaction.inCallback--;\r\n                }\r\n                catch (err) {\r\n                    Transaction_1.Transaction.currentTransaction.inCallback--;\r\n                    throw err;\r\n                }\r\n            });\r\n        };\r\n        for (var i = 0; i < listeners.length; i++) {\r\n            _loop_1(i);\r\n        }\r\n    };\r\n    return StreamWithSend;\r\n}(Stream));\r\nexports.StreamWithSend = StreamWithSend;\r\n/**\r\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\r\n */\r\nvar StreamLoop = (function (_super) {\r\n    __extends(StreamLoop, _super);\r\n    function StreamLoop() {\r\n        var _this = _super.call(this) || this;\r\n        _this.assigned__ = false; // to do: Figure out how to hide this\r\n        _this.vertex.name = \"StreamLoop\";\r\n        if (Transaction_1.Transaction.currentTransaction === null)\r\n            throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\r\n        return _this;\r\n    }\r\n    /**\r\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    StreamLoop.prototype.loop = function (sa_out) {\r\n        var _this = this;\r\n        if (this.assigned__)\r\n            throw new Error(\"StreamLoop looped more than once\");\r\n        this.assigned__ = true;\r\n        this.vertex.addSource(new Vertex_1.Source(sa_out.getVertex__(), function () {\r\n            return sa_out.listen_(_this.vertex, function (a) {\r\n                _this.send_(a);\r\n            }, false);\r\n        }));\r\n    };\r\n    return StreamLoop;\r\n}(StreamWithSend));\r\nexports.StreamLoop = StreamLoop;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\n/**\n * Returns the position of the first occurrence of the specified item\n * within the specified array.4\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the first occurrence of the specified element\n * within the specified array, or -1 if not found.\n */\nfunction indexOf(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    for (var i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.indexOf = indexOf;\n/**\n * Returns the position of the last occurrence of the specified element\n * within the specified array.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the last occurrence of the specified element\n * within the specified array or -1 if not found.\n */\nfunction lastIndexOf(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    for (var i = length - 1; i >= 0; i--) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.lastIndexOf = lastIndexOf;\n/**\n * Returns true if the specified array contains the specified element.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the specified array contains the specified element.\n */\nfunction contains(array, item, equalsFunction) {\n    return indexOf(array, item, equalsFunction) >= 0;\n}\nexports.contains = contains;\n/**\n * Removes the first ocurrence of the specified element from the specified array.\n * @param {*} array the array in which to search element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the array changed after this call.\n */\nfunction remove(array, item, equalsFunction) {\n    var index = indexOf(array, item, equalsFunction);\n    if (index < 0) {\n        return false;\n    }\n    array.splice(index, 1);\n    return true;\n}\nexports.remove = remove;\n/**\n * Returns the number of elements in the specified array equal\n * to the specified object.\n * @param {Array} array the array in which to determine the frequency of the element.\n * @param {Object} item the element whose frequency is to be determined.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the number of elements in the specified array\n * equal to the specified object.\n */\nfunction frequency(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    var freq = 0;\n    for (var i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            freq++;\n        }\n    }\n    return freq;\n}\nexports.frequency = frequency;\n/**\n * Returns true if the two specified arrays are equal to one another.\n * Two arrays are considered equal if both arrays contain the same number\n * of elements, and all corresponding pairs of elements in the two\n * arrays are equal and are in the same order.\n * @param {Array} array1 one array to be tested for equality.\n * @param {Array} array2 the other array to be tested for equality.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between elemements in the arrays.\n * @return {boolean} true if the two arrays are equal\n */\nfunction equals(array1, array2, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    var length = array1.length;\n    for (var i = 0; i < length; i++) {\n        if (!equals(array1[i], array2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equals = equals;\n/**\n * Returns shallow a copy of the specified array.\n * @param {*} array the array to copy.\n * @return {Array} a copy of the specified array\n */\nfunction copy(array) {\n    return array.concat();\n}\nexports.copy = copy;\n/**\n * Swaps the elements at the specified positions in the specified array.\n * @param {Array} array The array in which to swap elements.\n * @param {number} i the index of one element to be swapped.\n * @param {number} j the index of the other element to be swapped.\n * @return {boolean} true if the array is defined and the indexes are valid.\n */\nfunction swap(array, i, j) {\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\n        return false;\n    }\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n    return true;\n}\nexports.swap = swap;\nfunction toString(array) {\n    return '[' + array.toString() + ']';\n}\nexports.toString = toString;\n/**\n * Executes the provided function once for each element present in this array\n * starting from index 0 to length - 1.\n * @param {Array} array The array in which to iterate.\n * @param {function(Object):*} callback function to execute, it is\n * invoked with one argument: the element value, to break the iteration you can\n * optionally return false.\n */\nfunction forEach(array, callback) {\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n        var ele = array_1[_i];\n        if (callback(ele) === false) {\n            return;\n        }\n    }\n}\nexports.forEach = forEach;\n//# sourceMappingURL=arrays.js.map\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar Dictionary = (function () {\n    /**\n     * Creates an empty dictionary.\n     * @class <p>Dictionaries map keys to values; each key can map to at most one value.\n     * This implementation accepts any kind of objects as keys.</p>\n     *\n     * <p>If the keys are custom objects a function which converts keys to unique\n     * strings must be provided. Example:</p>\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function used\n     * to convert keys to strings. If the keys aren't strings or if toString()\n     * is not appropriate, a custom function which receives a key and returns a\n     * unique string must be provided.\n     */\n    function Dictionary(toStrFunction) {\n        this.table = {};\n        this.nElements = 0;\n        this.toStr = toStrFunction || util.defaultToString;\n    }\n    /**\n     * Returns the value to which this dictionary maps the specified key.\n     * Returns undefined if this dictionary contains no mapping for this key.\n     * @param {Object} key key whose associated value is to be returned.\n     * @return {*} the value to which this dictionary maps the specified key or\n     * undefined if the map contains no mapping for this key.\n     */\n    Dictionary.prototype.getValue = function (key) {\n        var pair = this.table['$' + this.toStr(key)];\n        if (util.isUndefined(pair)) {\n            return undefined;\n        }\n        return pair.value;\n    };\n    /**\n     * Associates the specified value with the specified key in this dictionary.\n     * If the dictionary previously contained a mapping for this key, the old\n     * value is replaced by the specified value.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value value to be associated with the specified key.\n     * @return {*} previous value associated with the specified key, or undefined if\n     * there was no mapping for the key or if the key/value are undefined.\n     */\n    Dictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return undefined;\n        }\n        var ret;\n        var k = '$' + this.toStr(key);\n        var previousElement = this.table[k];\n        if (util.isUndefined(previousElement)) {\n            this.nElements++;\n            ret = undefined;\n        }\n        else {\n            ret = previousElement.value;\n        }\n        this.table[k] = {\n            key: key,\n            value: value\n        };\n        return ret;\n    };\n    /**\n     * Removes the mapping for this key from this dictionary if it is present.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @return {*} previous value associated with specified key, or undefined if\n     * there was no mapping for key.\n     */\n    Dictionary.prototype.remove = function (key) {\n        var k = '$' + this.toStr(key);\n        var previousElement = this.table[k];\n        if (!util.isUndefined(previousElement)) {\n            delete this.table[k];\n            this.nElements--;\n            return previousElement.value;\n        }\n        return undefined;\n    };\n    /**\n     * Returns an array containing all of the keys in this dictionary.\n     * @return {Array} an array containing all of the keys in this dictionary.\n     */\n    Dictionary.prototype.keys = function () {\n        var array = [];\n        for (var name_1 in this.table) {\n            if (util.has(this.table, name_1)) {\n                var pair = this.table[name_1];\n                array.push(pair.key);\n            }\n        }\n        return array;\n    };\n    /**\n     * Returns an array containing all of the values in this dictionary.\n     * @return {Array} an array containing all of the values in this dictionary.\n     */\n    Dictionary.prototype.values = function () {\n        var array = [];\n        for (var name_2 in this.table) {\n            if (util.has(this.table, name_2)) {\n                var pair = this.table[name_2];\n                array.push(pair.value);\n            }\n        }\n        return array;\n    };\n    /**\n    * Executes the provided function once for each key-value pair\n    * present in this dictionary.\n    * @param {function(Object,Object):*} callback function to execute, it is\n    * invoked with two arguments: key and value. To break the iteration you can\n    * optionally return false.\n    */\n    Dictionary.prototype.forEach = function (callback) {\n        for (var name_3 in this.table) {\n            if (util.has(this.table, name_3)) {\n                var pair = this.table[name_3];\n                var ret = callback(pair.key, pair.value);\n                if (ret === false) {\n                    return;\n                }\n            }\n        }\n    };\n    /**\n     * Returns true if this dictionary contains a mapping for the specified key.\n     * @param {Object} key key whose presence in this dictionary is to be\n     * tested.\n     * @return {boolean} true if this dictionary contains a mapping for the\n     * specified key.\n     */\n    Dictionary.prototype.containsKey = function (key) {\n        return !util.isUndefined(this.getValue(key));\n    };\n    /**\n    * Removes all mappings from this dictionary.\n    * @this {collections.Dictionary}\n    */\n    Dictionary.prototype.clear = function () {\n        this.table = {};\n        this.nElements = 0;\n    };\n    /**\n     * Returns the number of keys in this dictionary.\n     * @return {number} the number of key-value mappings in this dictionary.\n     */\n    Dictionary.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this dictionary contains no mappings.\n     * @return {boolean} true if this dictionary contains no mappings.\n     */\n    Dictionary.prototype.isEmpty = function () {\n        return this.nElements <= 0;\n    };\n    Dictionary.prototype.toString = function () {\n        var toret = '{';\n        this.forEach(function (k, v) {\n            toret += \"\\n\\t\" + k + \" : \" + v;\n        });\n        return toret + '\\n}';\n    };\n    return Dictionary;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Dictionary; // End of dictionary\n//# sourceMappingURL=Dictionary.js.map\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar Lambda1 = (function () {\r\n    function Lambda1(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda1;\r\n}());\r\nexports.Lambda1 = Lambda1;\r\nfunction lambda1(f, deps) {\r\n    return new Lambda1(f, deps);\r\n}\r\nexports.lambda1 = lambda1;\r\nfunction Lambda1_deps(f) {\r\n    if (f instanceof Lambda1)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda1_deps = Lambda1_deps;\r\nfunction Lambda1_toFunction(f) {\r\n    if (f instanceof Lambda1)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda1_toFunction = Lambda1_toFunction;\r\nvar Lambda2 = (function () {\r\n    function Lambda2(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda2;\r\n}());\r\nexports.Lambda2 = Lambda2;\r\nfunction lambda2(f, deps) {\r\n    return new Lambda2(f, deps);\r\n}\r\nexports.lambda2 = lambda2;\r\nfunction Lambda2_deps(f) {\r\n    if (f instanceof Lambda2)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda2_deps = Lambda2_deps;\r\nfunction Lambda2_toFunction(f) {\r\n    if (f instanceof Lambda2)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda2_toFunction = Lambda2_toFunction;\r\nvar Lambda3 = (function () {\r\n    function Lambda3(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda3;\r\n}());\r\nexports.Lambda3 = Lambda3;\r\nfunction lambda3(f, deps) {\r\n    return new Lambda3(f, deps);\r\n}\r\nexports.lambda3 = lambda3;\r\nfunction Lambda3_deps(f) {\r\n    if (f instanceof Lambda3)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda3_deps = Lambda3_deps;\r\nfunction Lambda3_toFunction(f) {\r\n    if (f instanceof Lambda3)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda3_toFunction = Lambda3_toFunction;\r\nvar Lambda4 = (function () {\r\n    function Lambda4(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda4;\r\n}());\r\nexports.Lambda4 = Lambda4;\r\nfunction lambda4(f, deps) {\r\n    return new Lambda4(f, deps);\r\n}\r\nexports.lambda4 = lambda4;\r\nfunction Lambda4_deps(f) {\r\n    if (f instanceof Lambda4)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda4_deps = Lambda4_deps;\r\nfunction Lambda4_toFunction(f) {\r\n    if (f instanceof Lambda4)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda4_toFunction = Lambda4_toFunction;\r\nvar Lambda5 = (function () {\r\n    function Lambda5(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda5;\r\n}());\r\nexports.Lambda5 = Lambda5;\r\nfunction lambda5(f, deps) {\r\n    return new Lambda5(f, deps);\r\n}\r\nexports.lambda5 = lambda5;\r\nfunction Lambda5_deps(f) {\r\n    if (f instanceof Lambda5)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda5_deps = Lambda5_deps;\r\nfunction Lambda5_toFunction(f) {\r\n    if (f instanceof Lambda5)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda5_toFunction = Lambda5_toFunction;\r\nvar Lambda6 = (function () {\r\n    function Lambda6(f, deps) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    return Lambda6;\r\n}());\r\nexports.Lambda6 = Lambda6;\r\nfunction lambda6(f, deps) {\r\n    return new Lambda6(f, deps);\r\n}\r\nexports.lambda6 = lambda6;\r\nfunction Lambda6_deps(f) {\r\n    if (f instanceof Lambda6)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\nexports.Lambda6_deps = Lambda6_deps;\r\nfunction Lambda6_toFunction(f) {\r\n    if (f instanceof Lambda6)\r\n        return f.f;\r\n    else\r\n        return f;\r\n}\r\nexports.Lambda6_toFunction = Lambda6_toFunction;\r\nfunction toSources(deps) {\r\n    var ss = [];\r\n    for (var i = 0; i < deps.length; i++) {\r\n        var dep = deps[i];\r\n        ss.push(new Vertex_1.Source(dep.getVertex__(), null));\r\n    }\r\n    return ss;\r\n}\r\nexports.toSources = toSources;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Lambda_1 = __webpack_require__(6);\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar Lazy_1 = __webpack_require__(15);\r\nvar Stream_1 = __webpack_require__(3);\r\nvar Operational_1 = __webpack_require__(16);\r\nvar LazySample = (function () {\r\n    function LazySample(cell) {\r\n        this.hasValue = false;\r\n        this.value = null;\r\n        this.cell = cell;\r\n    }\r\n    return LazySample;\r\n}());\r\nvar ApplyState = (function () {\r\n    function ApplyState() {\r\n        this.f = null;\r\n        this.f_present = false;\r\n        this.a = null;\r\n        this.a_present = false;\r\n    }\r\n    return ApplyState;\r\n}());\r\nvar Cell = (function () {\r\n    function Cell(initValue, str) {\r\n        var _this = this;\r\n        this.value = initValue;\r\n        if (!str) {\r\n            this.str = new Stream_1.Stream();\r\n            this.vertex = new Vertex_1.Vertex(\"ConstCell\", 0, []);\r\n        }\r\n        else\r\n            Transaction_1.Transaction.run(function () { return _this.setStream(str); });\r\n    }\r\n    Cell.prototype.setStream = function (str) {\r\n        var _this = this;\r\n        this.str = str;\r\n        var me = this, src = new Vertex_1.Source(str.getVertex__(), function () {\r\n            return str.listen_(me.vertex, function (a) {\r\n                if (me.valueUpdate == null) {\r\n                    Transaction_1.Transaction.currentTransaction.last(function () {\r\n                        me.value = me.valueUpdate;\r\n                        me.lazyInitValue = null;\r\n                        me.valueUpdate = null;\r\n                    });\r\n                }\r\n                me.valueUpdate = a;\r\n            }, false);\r\n        });\r\n        this.vertex = new Vertex_1.Vertex(\"Cell\", 0, [src]);\r\n        // We do a trick here of registering the source for the duration of the current\r\n        // transaction so that we are guaranteed to catch any stream events that\r\n        // occur in the same transaction.\r\n        this.vertex.register(Vertex_1.Vertex.NULL);\r\n        Transaction_1.Transaction.currentTransaction.last(function () {\r\n            _this.vertex.deregister(Vertex_1.Vertex.NULL);\r\n        });\r\n    };\r\n    Cell.prototype.getVertex__ = function () {\r\n        return this.vertex;\r\n    };\r\n    Cell.prototype.getStream__ = function () {\r\n        return this.str;\r\n    };\r\n    /**\r\n     * Sample the cell's current value.\r\n     * <p>\r\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\r\n     * miss any updates, but in many circumstances it makes sense.\r\n     * <p>\r\n     * NOTE: In the Java and other versions of Sodium, using sample() inside map(), filter() and\r\n     * merge() is encouraged. In the Javascript/Typescript version, not so much, for the\r\n     * following reason: The memory management is different in the Javascript version, and this\r\n     * requires us to track all dependencies. In order for the use of sample() inside\r\n     * a closure to be correct, the cell that was sample()d inside the closure would have to be\r\n     * declared explicitly using the helpers lambda1(), lambda2(), etc. Because this is\r\n     * something that can be got wrong, we don't encourage this kind of use of sample() in\r\n     * Javascript. Better and simpler to use snapshot().\r\n     * <p>\r\n     * NOTE: If you need to sample() a cell, you have to make sure it's \"alive\" in terms of\r\n     * memory management or it will ignore updates. To make a cell work correctly\r\n     * with sample(), you have to ensure that it's being used. One way to guarantee this is\r\n     * to register a dummy listener on the cell. It will also work to have it referenced\r\n     * by something that is ultimately being listened to.\r\n     */\r\n    Cell.prototype.sample = function () {\r\n        var _this = this;\r\n        return Transaction_1.Transaction.run(function () { return _this.sampleNoTrans__(); });\r\n    };\r\n    Cell.prototype.sampleNoTrans__ = function () {\r\n        return this.value;\r\n    };\r\n    /**\r\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\r\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\r\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\r\n     */\r\n    Cell.prototype.sampleLazy = function () {\r\n        var me = this;\r\n        return Transaction_1.Transaction.run(function () { return me.sampleLazyNoTrans__(); });\r\n    };\r\n    Cell.prototype.sampleLazyNoTrans__ = function () {\r\n        var me = this, s = new LazySample(me);\r\n        Transaction_1.Transaction.currentTransaction.last(function () {\r\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\r\n            s.hasValue = true;\r\n            s.cell = null;\r\n        });\r\n        return new Lazy_1.Lazy(function () {\r\n            if (s.hasValue)\r\n                return s.value;\r\n            else\r\n                return s.cell.sample();\r\n        });\r\n    };\r\n    /**\r\n     * Transform the cell's value according to the supplied function, so the returned Cell\r\n     * always reflects the value of the function applied to the input Cell's value.\r\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.map = function (f) {\r\n        var c = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            return Operational_1.Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda_1.Lambda1_toFunction(f)));\r\n        });\r\n    };\r\n    /**\r\n     * Lift a binary function into cells, so the returned Cell always reflects the specified\r\n     * function applied to the input cells' values.\r\n     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.lift = function (b, fn0) {\r\n        var fn = Lambda_1.Lambda2_toFunction(fn0), cf = this.map(function (aa) { return function (bb) { return fn(aa, bb); }; });\r\n        return Cell.apply(cf, b, Lambda_1.toSources(Lambda_1.Lambda2_deps(fn0)));\r\n    };\r\n    /**\r\n     * Lift a ternary function into cells, so the returned Cell always reflects the specified\r\n     * function applied to the input cells' values.\r\n     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.lift3 = function (b, c, fn0) {\r\n        var fn = Lambda_1.Lambda3_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return fn(aa, bb, cc); }; }; }, cf = this.map(mf);\r\n        return Cell.apply(Cell.apply(cf, b), c, Lambda_1.toSources(Lambda_1.Lambda3_deps(fn0)));\r\n    };\r\n    /**\r\n     * Lift a quaternary function into cells, so the returned Cell always reflects the specified\r\n     * function applied to the input cells' values.\r\n     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.lift4 = function (b, c, d, fn0) {\r\n        var fn = Lambda_1.Lambda4_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return fn(aa, bb, cc, dd); }; }; }; }, cf = this.map(mf);\r\n        return Cell.apply(Cell.apply(Cell.apply(cf, b), c), d, Lambda_1.toSources(Lambda_1.Lambda4_deps(fn0)));\r\n    };\r\n    /**\r\n     * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\r\n     * function applied to the input cells' values.\r\n     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.lift5 = function (b, c, d, e, fn0) {\r\n        var fn = Lambda_1.Lambda5_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return function (ee) { return fn(aa, bb, cc, dd, ee); }; }; }; }; }, cf = this.map(mf);\r\n        return Cell.apply(Cell.apply(Cell.apply(Cell.apply(cf, b), c), d), e, Lambda_1.toSources(Lambda_1.Lambda5_deps(fn0)));\r\n    };\r\n    /**\r\n     * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\r\n     * function applied to the input cells' values.\r\n     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n     */\r\n    Cell.prototype.lift6 = function (b, c, d, e, f, fn0) {\r\n        var fn = Lambda_1.Lambda6_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return function (ee) { return function (ff) { return fn(aa, bb, cc, dd, ee, ff); }; }; }; }; }; }, cf = this.map(mf);\r\n        return Cell.apply(Cell.apply(Cell.apply(Cell.apply(Cell.apply(cf, b), c), d), e), f, Lambda_1.toSources(Lambda_1.Lambda6_deps(fn0)));\r\n    };\r\n    /**\r\n     * Apply a value inside a cell to a function inside a cell. This is the\r\n     * primitive for all function lifting.\r\n     */\r\n    Cell.apply = function (cf, ca, sources) {\r\n        return Transaction_1.Transaction.run(function () {\r\n            var state = new ApplyState(), out = new Stream_1.StreamWithSend(), cf_value = Operational_1.Operational.value(cf), ca_value = Operational_1.Operational.value(ca), src1 = new Vertex_1.Source(cf_value.getVertex__(), function () {\r\n                return cf_value.listen_(out.getVertex__(), function (f) {\r\n                    state.f = f;\r\n                    state.f_present = true;\r\n                    if (state.a_present)\r\n                        out.send_(state.f(state.a));\r\n                }, false);\r\n            }), src2 = new Vertex_1.Source(ca_value.getVertex__(), function () {\r\n                return ca_value.listen_(out.getVertex__(), function (a) {\r\n                    state.a = a;\r\n                    state.a_present = true;\r\n                    if (state.f_present)\r\n                        out.send_(state.f(state.a));\r\n                }, false);\r\n            });\r\n            out.setVertex__(new Vertex_1.Vertex(\"apply\", 0, [src1, src2].concat(sources ? sources : [])));\r\n            return out.coalesce__(function (l, r) { return r; }).holdLazy(new Lazy_1.Lazy(function () {\r\n                return cf.sampleNoTrans__()(ca.sampleNoTrans__());\r\n            }));\r\n        });\r\n    };\r\n    /**\r\n     * Unwrap a cell inside another cell to give a time-varying cell implementation.\r\n     */\r\n    Cell.switchC = function (cca) {\r\n        return Transaction_1.Transaction.run(function () {\r\n            var za = cca.sampleLazy().map(function (ba) { return ba.sample(); }), out = new Stream_1.StreamWithSend();\r\n            var last_ca = null;\r\n            var cca_value = Operational_1.Operational.value(cca), src = new Vertex_1.Source(cca_value.getVertex__(), function () {\r\n                var kill2 = last_ca === null ? null :\r\n                    Operational_1.Operational.value(last_ca).listen_(out.getVertex__(), function (a) { return out.send_(a); }, false);\r\n                var kill1 = cca_value.listen_(out.getVertex__(), function (ca) {\r\n                    // Note: If any switch takes place during a transaction, then the\r\n                    // coalesce__() below will always cause a sample to be fetched\r\n                    // from the one we just switched to. So anything from the old input cell\r\n                    // that might have happened during this transaction will be suppressed.\r\n                    last_ca = ca;\r\n                    if (kill2 !== null)\r\n                        kill2();\r\n                    kill2 = Operational_1.Operational.value(ca).listen_(out.getVertex__(), function (a) { return out.send_(a); }, false);\r\n                }, false);\r\n                return function () { kill1(); kill2(); };\r\n            });\r\n            out.setVertex__(new Vertex_1.Vertex(\"switchC\", 0, [src]));\r\n            return out.coalesce__(function (l, r) { return r; }).holdLazy(za);\r\n        });\r\n    };\r\n    /**\r\n     * Unwrap a stream inside a cell to give a time-varying stream implementation.\r\n     */\r\n    Cell.switchS = function (csa) {\r\n        return Transaction_1.Transaction.run(function () {\r\n            var out = new Stream_1.StreamWithSend(), h2 = function (a) {\r\n                out.send_(a);\r\n            }, src = new Vertex_1.Source(csa.getVertex__(), function () {\r\n                var kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\r\n                var kill1 = csa.getStream__().listen_(out.getVertex__(), function (sa) {\r\n                    kill2();\r\n                    kill2 = sa.listen_(out.getVertex__(), h2, true);\r\n                }, false);\r\n                return function () { kill1(); kill2(); };\r\n            });\r\n            out.setVertex__(new Vertex_1.Vertex(\"switchS\", 0, [src]));\r\n            return out;\r\n        });\r\n    };\r\n    /**\r\n     * Listen for updates to the value of this cell. This is the observer pattern. The\r\n     * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\r\n     * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\r\n     * the world of I/O and for FRP.\r\n     * @param h The handler to execute when there's a new value.\r\n     *   You should make no assumptions about what thread you are called on, and the\r\n     *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\r\n     *   or {@link StreamSink#send(Object)} in the handler.\r\n     *   An exception will be thrown, because you are not meant to use this to create\r\n     *   your own primitives.\r\n     */\r\n    Cell.prototype.listen = function (h) {\r\n        var _this = this;\r\n        return Transaction_1.Transaction.run(function () {\r\n            return Operational_1.Operational.value(_this).listen(h);\r\n        });\r\n    };\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Cell satisfies the Monad and Comonad Categories (and hence Functor, Apply, Applicative, and Extend as well)\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n    //of :: Applicative f => a -> f a\r\n    Cell['fantasy-land/of'] = function (a) {\r\n        return new Cell(a);\r\n    };\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    Cell.prototype['fantasy-land/map'] = function (f) {\r\n        return this.map(f);\r\n    };\r\n    //ap :: Apply f => f a ~> f (a -> b) -> f b\r\n    Cell.prototype['fantasy-land/ap'] = function (cf) {\r\n        return Cell.apply(cf, this);\r\n    };\r\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\r\n    Cell.prototype['fantasy-land/chain'] = function (f) {\r\n        return Cell.switchC(this.map(f));\r\n    };\r\n    //extend :: Extend w => w a ~> (w a -> b) -> w b\r\n    Cell.prototype['fantasy-land/extend'] = function (f) {\r\n        return new Cell(f(this));\r\n    };\r\n    //extract :: Comonad w => w a ~> () -> a\r\n    Cell.prototype['fantasy-land/extract'] = function () {\r\n        return this.sample();\r\n    };\r\n    return Cell;\r\n}());\r\nexports.Cell = Cell;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar arrays = __webpack_require__(4);\nvar LinkedList = (function () {\n    /**\n    * Creates an empty Linked List.\n    * @class A linked list is a data structure consisting of a group of nodes\n    * which together represent a sequence.\n    * @constructor\n    */\n    function LinkedList() {\n        /**\n        * First node in the list\n        * @type {Object}\n        * @private\n        */\n        this.firstNode = null;\n        /**\n        * Last node in the list\n        * @type {Object}\n        * @private\n        */\n        this.lastNode = null;\n        /**\n        * Number of elements in the list\n        * @type {number}\n        * @private\n        */\n        this.nElements = 0;\n    }\n    /**\n    * Adds an element to this list.\n    * @param {Object} item element to be added.\n    * @param {number=} index optional index to add the element. If no index is specified\n    * the element is added to the end of this list.\n    * @return {boolean} true if the element was added or false if the index is invalid\n    * or if the element is undefined.\n    */\n    LinkedList.prototype.add = function (item, index) {\n        if (util.isUndefined(index)) {\n            index = this.nElements;\n        }\n        if (index < 0 || index > this.nElements || util.isUndefined(item)) {\n            return false;\n        }\n        var newNode = this.createNode(item);\n        if (this.nElements === 0) {\n            // First node in the list.\n            this.firstNode = newNode;\n            this.lastNode = newNode;\n        }\n        else if (index === this.nElements) {\n            // Insert at the end.\n            this.lastNode.next = newNode;\n            this.lastNode = newNode;\n        }\n        else if (index === 0) {\n            // Change first node.\n            newNode.next = this.firstNode;\n            this.firstNode = newNode;\n        }\n        else {\n            var prev = this.nodeAtIndex(index - 1);\n            newNode.next = prev.next;\n            prev.next = newNode;\n        }\n        this.nElements++;\n        return true;\n    };\n    /**\n    * Returns the first element in this list.\n    * @return {*} the first element of the list or undefined if the list is\n    * empty.\n    */\n    LinkedList.prototype.first = function () {\n        if (this.firstNode !== null) {\n            return this.firstNode.element;\n        }\n        return undefined;\n    };\n    /**\n    * Returns the last element in this list.\n    * @return {*} the last element in the list or undefined if the list is\n    * empty.\n    */\n    LinkedList.prototype.last = function () {\n        if (this.lastNode !== null) {\n            return this.lastNode.element;\n        }\n        return undefined;\n    };\n    /**\n     * Returns the element at the specified position in this list.\n     * @param {number} index desired index.\n     * @return {*} the element at the given index or undefined if the index is\n     * out of bounds.\n     */\n    LinkedList.prototype.elementAtIndex = function (index) {\n        var node = this.nodeAtIndex(index);\n        if (node === null) {\n            return undefined;\n        }\n        return node.element;\n    };\n    /**\n     * Returns the index in this list of the first occurrence of the\n     * specified element, or -1 if the List does not contain this element.\n     * <p>If the elements inside this list are\n     * not comparable with the === operator a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName = function(pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} item element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction Optional\n     * function used to check if two elements are equal.\n     * @return {number} the index in this list of the first occurrence\n     * of the specified element, or -1 if this list does not contain the\n     * element.\n     */\n    LinkedList.prototype.indexOf = function (item, equalsFunction) {\n        var equalsF = equalsFunction || util.defaultEquals;\n        if (util.isUndefined(item)) {\n            return -1;\n        }\n        var currentNode = this.firstNode;\n        var index = 0;\n        while (currentNode !== null) {\n            if (equalsF(currentNode.element, item)) {\n                return index;\n            }\n            index++;\n            currentNode = currentNode.next;\n        }\n        return -1;\n    };\n    /**\n       * Returns true if this list contains the specified element.\n       * <p>If the elements inside the list are\n       * not comparable with the === operator a custom equals function should be\n       * provided to perform searches, the function must receive two arguments and\n       * return true if they are equal, false otherwise. Example:</p>\n       *\n       * <pre>\n       * const petsAreEqualByName = function(pet1, pet2) {\n       *  return pet1.name === pet2.name;\n       * }\n       * </pre>\n       * @param {Object} item element to search for.\n       * @param {function(Object,Object):boolean=} equalsFunction Optional\n       * function used to check if two elements are equal.\n       * @return {boolean} true if this list contains the specified element, false\n       * otherwise.\n       */\n    LinkedList.prototype.contains = function (item, equalsFunction) {\n        return (this.indexOf(item, equalsFunction) >= 0);\n    };\n    /**\n     * Removes the first occurrence of the specified element in this list.\n     * <p>If the elements inside the list are\n     * not comparable with the === operator a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName = function(pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} item element to be removed from this list, if present.\n     * @return {boolean} true if the list contained the specified element.\n     */\n    LinkedList.prototype.remove = function (item, equalsFunction) {\n        var equalsF = equalsFunction || util.defaultEquals;\n        if (this.nElements < 1 || util.isUndefined(item)) {\n            return false;\n        }\n        var previous = null;\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            if (equalsF(currentNode.element, item)) {\n                if (currentNode === this.firstNode) {\n                    this.firstNode = this.firstNode.next;\n                    if (currentNode === this.lastNode) {\n                        this.lastNode = null;\n                    }\n                }\n                else if (currentNode === this.lastNode) {\n                    this.lastNode = previous;\n                    previous.next = currentNode.next;\n                    currentNode.next = null;\n                }\n                else {\n                    previous.next = currentNode.next;\n                    currentNode.next = null;\n                }\n                this.nElements--;\n                return true;\n            }\n            previous = currentNode;\n            currentNode = currentNode.next;\n        }\n        return false;\n    };\n    /**\n     * Removes all of the elements from this list.\n     */\n    LinkedList.prototype.clear = function () {\n        this.firstNode = null;\n        this.lastNode = null;\n        this.nElements = 0;\n    };\n    /**\n     * Returns true if this list is equal to the given list.\n     * Two lists are equal if they have the same elements in the same order.\n     * @param {LinkedList} other the other list.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function used to check if two elements are equal. If the elements in the lists\n     * are custom objects you should provide a function, otherwise\n     * the === operator is used to check equality between elements.\n     * @return {boolean} true if this list is equal to the given list.\n     */\n    LinkedList.prototype.equals = function (other, equalsFunction) {\n        var eqF = equalsFunction || util.defaultEquals;\n        if (!(other instanceof LinkedList)) {\n            return false;\n        }\n        if (this.size() !== other.size()) {\n            return false;\n        }\n        return this.equalsAux(this.firstNode, other.firstNode, eqF);\n    };\n    /**\n    * @private\n    */\n    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {\n        while (n1 !== null) {\n            if (!eqF(n1.element, n2.element)) {\n                return false;\n            }\n            n1 = n1.next;\n            n2 = n2.next;\n        }\n        return true;\n    };\n    /**\n     * Removes the element at the specified position in this list.\n     * @param {number} index given index.\n     * @return {*} removed element or undefined if the index is out of bounds.\n     */\n    LinkedList.prototype.removeElementAtIndex = function (index) {\n        if (index < 0 || index >= this.nElements) {\n            return undefined;\n        }\n        var element;\n        if (this.nElements === 1) {\n            //First node in the list.\n            element = this.firstNode.element;\n            this.firstNode = null;\n            this.lastNode = null;\n        }\n        else {\n            var previous = this.nodeAtIndex(index - 1);\n            if (previous === null) {\n                element = this.firstNode.element;\n                this.firstNode = this.firstNode.next;\n            }\n            else if (previous.next === this.lastNode) {\n                element = this.lastNode.element;\n                this.lastNode = previous;\n            }\n            if (previous !== null) {\n                element = previous.next.element;\n                previous.next = previous.next.next;\n            }\n        }\n        this.nElements--;\n        return element;\n    };\n    /**\n     * Executes the provided function once for each element present in this list in order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    LinkedList.prototype.forEach = function (callback) {\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            if (callback(currentNode.element) === false) {\n                break;\n            }\n            currentNode = currentNode.next;\n        }\n    };\n    /**\n     * Reverses the order of the elements in this linked list (makes the last\n     * element first, and the first element last).\n     */\n    LinkedList.prototype.reverse = function () {\n        var previous = null;\n        var current = this.firstNode;\n        var temp = null;\n        while (current !== null) {\n            temp = current.next;\n            current.next = previous;\n            previous = current;\n            current = temp;\n        }\n        temp = this.firstNode;\n        this.firstNode = this.lastNode;\n        this.lastNode = temp;\n    };\n    /**\n     * Returns an array containing all of the elements in this list in proper\n     * sequence.\n     * @return {Array.<*>} an array containing all of the elements in this list,\n     * in proper sequence.\n     */\n    LinkedList.prototype.toArray = function () {\n        var array = [];\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            array.push(currentNode.element);\n            currentNode = currentNode.next;\n        }\n        return array;\n    };\n    /**\n     * Returns the number of elements in this list.\n     * @return {number} the number of elements in this list.\n     */\n    LinkedList.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this list contains no elements.\n     * @return {boolean} true if this list contains no elements.\n     */\n    LinkedList.prototype.isEmpty = function () {\n        return this.nElements <= 0;\n    };\n    LinkedList.prototype.toString = function () {\n        return arrays.toString(this.toArray());\n    };\n    /**\n     * @private\n     */\n    LinkedList.prototype.nodeAtIndex = function (index) {\n        if (index < 0 || index >= this.nElements) {\n            return null;\n        }\n        if (index === (this.nElements - 1)) {\n            return this.lastNode;\n        }\n        var node = this.firstNode;\n        for (var i = 0; i < index; i++) {\n            node = node.next;\n        }\n        return node;\n    };\n    /**\n     * @private\n     */\n    LinkedList.prototype.createNode = function (item) {\n        return {\n            element: item,\n            next: null\n        };\n    };\n    return LinkedList;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedList; // End of linked list\n//# sourceMappingURL=LinkedList.js.map\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar typescript_collections_1 = __webpack_require__(10);\r\nvar Stream_1 = __webpack_require__(3);\r\nvar CellSink_1 = __webpack_require__(20);\r\nvar Transaction_1 = __webpack_require__(1);\r\n/**\r\n * An interface for implementations of FRP timer systems.\r\n */\r\nvar TimerSystemImpl = (function () {\r\n    function TimerSystemImpl() {\r\n    }\r\n    return TimerSystemImpl;\r\n}());\r\nexports.TimerSystemImpl = TimerSystemImpl;\r\nvar nextSeq = 0;\r\nvar Event = (function () {\r\n    function Event(t, sAlarm) {\r\n        this.t = t;\r\n        this.sAlarm = sAlarm;\r\n        this.seq = ++nextSeq;\r\n    }\r\n    return Event;\r\n}());\r\nvar TimerSystem = (function () {\r\n    function TimerSystem(impl) {\r\n        var _this = this;\r\n        this.eventQueue = new typescript_collections_1.BSTree(function (a, b) {\r\n            if (a.t < b.t)\r\n                return -1;\r\n            if (a.t > b.t)\r\n                return 1;\r\n            if (a.seq < b.seq)\r\n                return -1;\r\n            if (a.seq > b.seq)\r\n                return 1;\r\n            return 0;\r\n        });\r\n        Transaction_1.Transaction.run(function () {\r\n            _this.impl = impl;\r\n            _this.tMinimum = 0;\r\n            var timeSnk = new CellSink_1.CellSink(impl.now());\r\n            _this.time = timeSnk;\r\n            // A dummy listener to time to keep it alive even when there are no other listeners.\r\n            _this.time.listen(function (t) { });\r\n            Transaction_1.Transaction.onStart(function () {\r\n                // Ensure the time is always increasing from the FRP's point of view.\r\n                var t = _this.tMinimum = Math.max(_this.tMinimum, impl.now());\r\n                var _loop_1 = function () {\r\n                    var ev = null;\r\n                    if (!_this.eventQueue.isEmpty()) {\r\n                        var mev = _this.eventQueue.minimum();\r\n                        if (mev.t <= t) {\r\n                            ev = mev;\r\n                            // TO DO: Detect infinite loops!\r\n                        }\r\n                    }\r\n                    if (ev != null) {\r\n                        timeSnk.send(ev.t);\r\n                        Transaction_1.Transaction.run(function () { return ev.sAlarm.send_(ev.t); });\r\n                    }\r\n                    else\r\n                        return \"break\";\r\n                };\r\n                // Pop and execute all events earlier than or equal to t (the current time).\r\n                while (true) {\r\n                    var state_1 = _loop_1();\r\n                    if (state_1 === \"break\")\r\n                        break;\r\n                }\r\n                timeSnk.send(t);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * A timer that fires at the specified time, which can be null, meaning\r\n     * that the alarm is not set.\r\n     */\r\n    TimerSystem.prototype.at = function (tAlarm) {\r\n        var _this = this;\r\n        var current = null, cancelCurrent = null, active = false, tAl = null, sampled = false;\r\n        var sAlarm = new Stream_1.StreamWithSend(null), updateTimer = function () {\r\n            if (cancelCurrent !== null) {\r\n                cancelCurrent();\r\n                _this.eventQueue.remove(current);\r\n            }\r\n            cancelCurrent = null;\r\n            current = null;\r\n            if (active) {\r\n                if (!sampled) {\r\n                    sampled = true;\r\n                    tAl = tAlarm.sampleNoTrans__();\r\n                }\r\n                if (tAl !== null) {\r\n                    current = new Event(tAl, sAlarm);\r\n                    _this.eventQueue.add(current);\r\n                    cancelCurrent = _this.impl.setTimer(tAl, function () {\r\n                        // Correction to ensure the clock time appears to be >= the\r\n                        // alarm time. It can be a few milliseconds early, and\r\n                        // this breaks things otherwise, because it doesn't think\r\n                        // it's time to fire the alarm yet.\r\n                        _this.tMinimum = Math.max(_this.tMinimum, tAl);\r\n                        // Open and close a transaction to trigger queued\r\n                        // events to run.\r\n                        Transaction_1.Transaction.run(function () { });\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        sAlarm.setVertex__(new Vertex_1.Vertex(\"at\", 0, [\r\n            new Vertex_1.Source(tAlarm.getVertex__(), function () {\r\n                active = true;\r\n                sampled = false;\r\n                Transaction_1.Transaction.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\r\n                var kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), function (oAlarm) {\r\n                    tAl = oAlarm;\r\n                    sampled = true;\r\n                    updateTimer();\r\n                }, false);\r\n                return function () {\r\n                    active = false;\r\n                    updateTimer();\r\n                    kill();\r\n                };\r\n            })\r\n        ]));\r\n        return sAlarm;\r\n    };\r\n    return TimerSystem;\r\n}());\r\nexports.TimerSystem = TimerSystem;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright 2013 Basarat Ali Syed. All Rights Reserved.\n//\n// Licensed under MIT open source license http://opensource.org/licenses/MIT\n//\n// Orginal javascript code was by Mauricio Santos\n//\nvar _arrays = __webpack_require__(4);\nexports.arrays = _arrays;\nvar Bag_1 = __webpack_require__(22);\nexports.Bag = Bag_1.default;\nvar BSTree_1 = __webpack_require__(23);\nexports.BSTree = BSTree_1.default;\nvar Dictionary_1 = __webpack_require__(5);\nexports.Dictionary = Dictionary_1.default;\nvar Heap_1 = __webpack_require__(13);\nexports.Heap = Heap_1.default;\nvar LinkedDictionary_1 = __webpack_require__(24);\nexports.LinkedDictionary = LinkedDictionary_1.default;\nvar LinkedList_1 = __webpack_require__(8);\nexports.LinkedList = LinkedList_1.default;\nvar MultiDictionary_1 = __webpack_require__(25);\nexports.MultiDictionary = MultiDictionary_1.default;\nvar Queue_1 = __webpack_require__(12);\nexports.Queue = Queue_1.default;\nvar PriorityQueue_1 = __webpack_require__(26);\nexports.PriorityQueue = PriorityQueue_1.default;\nvar Set_1 = __webpack_require__(11);\nexports.Set = Set_1.default;\nvar Stack_1 = __webpack_require__(27);\nexports.Stack = Stack_1.default;\nvar _util = __webpack_require__(0);\nexports.util = _util;\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar arrays = __webpack_require__(4);\nvar Dictionary_1 = __webpack_require__(5);\nvar Set = (function () {\n    /**\n     * Creates an empty set.\n     * @class <p>A set is a data structure that contains no duplicate items.</p>\n     * <p>If the inserted elements are custom objects a function\n     * which converts elements to strings must be provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object):string=} toStringFunction optional function used\n     * to convert elements to strings. If the elements aren't strings or if toString()\n     * is not appropriate, a custom function which receives a onject and returns a\n     * unique string must be provided.\n     */\n    function Set(toStringFunction) {\n        this.dictionary = new Dictionary_1.default(toStringFunction);\n    }\n    /**\n     * Returns true if this set contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this set contains the specified element,\n     * false otherwise.\n     */\n    Set.prototype.contains = function (element) {\n        return this.dictionary.containsKey(element);\n    };\n    /**\n     * Adds the specified element to this set if it is not already present.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if this set did not already contain the specified element.\n     */\n    Set.prototype.add = function (element) {\n        if (this.contains(element) || util.isUndefined(element)) {\n            return false;\n        }\n        else {\n            this.dictionary.setValue(element, element);\n            return true;\n        }\n    };\n    /**\n     * Performs an intersecion between this an another set.\n     * Removes all values that are not present this set and the given set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.intersection = function (otherSet) {\n        var set = this;\n        this.forEach(function (element) {\n            if (!otherSet.contains(element)) {\n                set.remove(element);\n            }\n            return true;\n        });\n    };\n    /**\n     * Performs a union between this an another set.\n     * Adds all values from the given set to this set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.union = function (otherSet) {\n        var set = this;\n        otherSet.forEach(function (element) {\n            set.add(element);\n            return true;\n        });\n    };\n    /**\n     * Performs a difference between this an another set.\n     * Removes from this set all the values that are present in the given set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.difference = function (otherSet) {\n        var set = this;\n        otherSet.forEach(function (element) {\n            set.remove(element);\n            return true;\n        });\n    };\n    /**\n     * Checks whether the given set contains all the elements in this set.\n     * @param {collections.Set} otherSet other set.\n     * @return {boolean} true if this set is a subset of the given set.\n     */\n    Set.prototype.isSubsetOf = function (otherSet) {\n        if (this.size() > otherSet.size()) {\n            return false;\n        }\n        var isSub = true;\n        this.forEach(function (element) {\n            if (!otherSet.contains(element)) {\n                isSub = false;\n                return false;\n            }\n            return true;\n        });\n        return isSub;\n    };\n    /**\n     * Removes the specified element from this set if it is present.\n     * @return {boolean} true if this set contained the specified element.\n     */\n    Set.prototype.remove = function (element) {\n        if (!this.contains(element)) {\n            return false;\n        }\n        else {\n            this.dictionary.remove(element);\n            return true;\n        }\n    };\n    /**\n     * Executes the provided function once for each element\n     * present in this set.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one arguments: the element. To break the iteration you can\n     * optionally return false.\n     */\n    Set.prototype.forEach = function (callback) {\n        this.dictionary.forEach(function (k, v) {\n            return callback(v);\n        });\n    };\n    /**\n     * Returns an array containing all of the elements in this set in arbitrary order.\n     * @return {Array} an array containing all of the elements in this set.\n     */\n    Set.prototype.toArray = function () {\n        return this.dictionary.values();\n    };\n    /**\n     * Returns true if this set contains no elements.\n     * @return {boolean} true if this set contains no elements.\n     */\n    Set.prototype.isEmpty = function () {\n        return this.dictionary.isEmpty();\n    };\n    /**\n     * Returns the number of elements in this set.\n     * @return {number} the number of elements in this set.\n     */\n    Set.prototype.size = function () {\n        return this.dictionary.size();\n    };\n    /**\n     * Removes all of the elements from this set.\n     */\n    Set.prototype.clear = function () {\n        this.dictionary.clear();\n    };\n    /*\n    * Provides a string representation for display\n    */\n    Set.prototype.toString = function () {\n        return arrays.toString(this.toArray());\n    };\n    return Set;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Set; // end of Set\n//# sourceMappingURL=Set.js.map\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LinkedList_1 = __webpack_require__(8);\nvar Queue = (function () {\n    /**\n     * Creates an empty queue.\n     * @class A queue is a First-In-First-Out (FIFO) data structure, the first\n     * element added to the queue will be the first one to be removed. This\n     * implementation uses a linked list as a container.\n     * @constructor\n     */\n    function Queue() {\n        this.list = new LinkedList_1.default();\n    }\n    /**\n     * Inserts the specified element into the end of this queue.\n     * @param {Object} elem the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    Queue.prototype.enqueue = function (elem) {\n        return this.list.add(elem);\n    };\n    /**\n     * Inserts the specified element into the end of this queue.\n     * @param {Object} elem the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    Queue.prototype.add = function (elem) {\n        return this.list.add(elem);\n    };\n    /**\n     * Retrieves and removes the head of this queue.\n     * @return {*} the head of this queue, or undefined if this queue is empty.\n     */\n    Queue.prototype.dequeue = function () {\n        if (this.list.size() !== 0) {\n            var el = this.list.first();\n            this.list.removeElementAtIndex(0);\n            return el;\n        }\n        return undefined;\n    };\n    /**\n     * Retrieves, but does not remove, the head of this queue.\n     * @return {*} the head of this queue, or undefined if this queue is empty.\n     */\n    Queue.prototype.peek = function () {\n        if (this.list.size() !== 0) {\n            return this.list.first();\n        }\n        return undefined;\n    };\n    /**\n     * Returns the number of elements in this queue.\n     * @return {number} the number of elements in this queue.\n     */\n    Queue.prototype.size = function () {\n        return this.list.size();\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * <p>If the elements inside this stack are\n     * not comparable with the === operator, a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName (pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} elem element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function to check if two elements are equal.\n     * @return {boolean} true if this queue contains the specified element,\n     * false otherwise.\n     */\n    Queue.prototype.contains = function (elem, equalsFunction) {\n        return this.list.contains(elem, equalsFunction);\n    };\n    /**\n     * Checks if this queue is empty.\n     * @return {boolean} true if and only if this queue contains no items; false\n     * otherwise.\n     */\n    Queue.prototype.isEmpty = function () {\n        return this.list.size() <= 0;\n    };\n    /**\n     * Removes all of the elements from this queue.\n     */\n    Queue.prototype.clear = function () {\n        this.list.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this queue in\n     * FIFO order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Queue.prototype.forEach = function (callback) {\n        this.list.forEach(callback);\n    };\n    return Queue;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Queue; // End of queue\n//# sourceMappingURL=Queue.js.map\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar collections = __webpack_require__(0);\nvar arrays = __webpack_require__(4);\nvar Heap = (function () {\n    /**\n     * Creates an empty Heap.\n     * @class\n     * <p>A heap is a binary tree, where the nodes maintain the heap property:\n     * each node is smaller than each of its children and therefore a MinHeap\n     * This implementation uses an array to store elements.</p>\n     * <p>If the inserted elements are custom objects a compare function must be provided,\n     *  at construction time, otherwise the <=, === and >= operators are\n     * used to compare elements. Example:</p>\n     *\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     *\n     * <p>If a Max-Heap is wanted (greater elements on top) you can a provide a\n     * reverse compare function to accomplish that behavior. Example:</p>\n     *\n     * <pre>\n     * function reverseCompare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return 1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return -1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two elements. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function Heap(compareFunction) {\n        /**\n         * Array used to store the elements od the heap.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.data = [];\n        this.compare = compareFunction || collections.defaultCompare;\n    }\n    /**\n     * Returns the index of the left child of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the left child\n     * for.\n     * @return {number} The index of the left child.\n     * @private\n     */\n    Heap.prototype.leftChildIndex = function (nodeIndex) {\n        return (2 * nodeIndex) + 1;\n    };\n    /**\n     * Returns the index of the right child of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the right child\n     * for.\n     * @return {number} The index of the right child.\n     * @private\n     */\n    Heap.prototype.rightChildIndex = function (nodeIndex) {\n        return (2 * nodeIndex) + 2;\n    };\n    /**\n     * Returns the index of the parent of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the parent for.\n     * @return {number} The index of the parent.\n     * @private\n     */\n    Heap.prototype.parentIndex = function (nodeIndex) {\n        return Math.floor((nodeIndex - 1) / 2);\n    };\n    /**\n     * Returns the index of the smaller child node (if it exists).\n     * @param {number} leftChild left child index.\n     * @param {number} rightChild right child index.\n     * @return {number} the index with the minimum value or -1 if it doesn't\n     * exists.\n     * @private\n     */\n    Heap.prototype.minIndex = function (leftChild, rightChild) {\n        if (rightChild >= this.data.length) {\n            if (leftChild >= this.data.length) {\n                return -1;\n            }\n            else {\n                return leftChild;\n            }\n        }\n        else {\n            if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {\n                return leftChild;\n            }\n            else {\n                return rightChild;\n            }\n        }\n    };\n    /**\n     * Moves the node at the given index up to its proper place in the heap.\n     * @param {number} index The index of the node to move up.\n     * @private\n     */\n    Heap.prototype.siftUp = function (index) {\n        var parent = this.parentIndex(index);\n        while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {\n            arrays.swap(this.data, parent, index);\n            index = parent;\n            parent = this.parentIndex(index);\n        }\n    };\n    /**\n     * Moves the node at the given index down to its proper place in the heap.\n     * @param {number} nodeIndex The index of the node to move down.\n     * @private\n     */\n    Heap.prototype.siftDown = function (nodeIndex) {\n        //smaller child index\n        var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\n        while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {\n            arrays.swap(this.data, min, nodeIndex);\n            nodeIndex = min;\n            min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\n        }\n    };\n    /**\n     * Retrieves but does not remove the root element of this heap.\n     * @return {*} The value at the root of the heap. Returns undefined if the\n     * heap is empty.\n     */\n    Heap.prototype.peek = function () {\n        if (this.data.length > 0) {\n            return this.data[0];\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Adds the given element into the heap.\n     * @param {*} element the element.\n     * @return true if the element was added or fals if it is undefined.\n     */\n    Heap.prototype.add = function (element) {\n        if (collections.isUndefined(element)) {\n            return undefined;\n        }\n        this.data.push(element);\n        this.siftUp(this.data.length - 1);\n        return true;\n    };\n    /**\n     * Retrieves and removes the root element of this heap.\n     * @return {*} The value removed from the root of the heap. Returns\n     * undefined if the heap is empty.\n     */\n    Heap.prototype.removeRoot = function () {\n        if (this.data.length > 0) {\n            var obj = this.data[0];\n            this.data[0] = this.data[this.data.length - 1];\n            this.data.splice(this.data.length - 1, 1);\n            if (this.data.length > 0) {\n                this.siftDown(0);\n            }\n            return obj;\n        }\n        return undefined;\n    };\n    /**\n     * Returns true if this heap contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this Heap contains the specified element, false\n     * otherwise.\n     */\n    Heap.prototype.contains = function (element) {\n        var equF = collections.compareToEquals(this.compare);\n        return arrays.contains(this.data, element, equF);\n    };\n    /**\n     * Returns the number of elements in this heap.\n     * @return {number} the number of elements in this heap.\n     */\n    Heap.prototype.size = function () {\n        return this.data.length;\n    };\n    /**\n     * Checks if this heap is empty.\n     * @return {boolean} true if and only if this heap contains no items; false\n     * otherwise.\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.data.length <= 0;\n    };\n    /**\n     * Removes all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.data.length = 0;\n    };\n    /**\n     * Executes the provided function once for each element present in this heap in\n     * no particular order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Heap.prototype.forEach = function (callback) {\n        arrays.forEach(this.data, callback);\n    };\n    return Heap;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Heap;\n//# sourceMappingURL=Heap.js.map\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Lambda_1 = __webpack_require__(6);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar CoalesceHandler = (function () {\r\n    function CoalesceHandler(f, out) {\r\n        this.f = Lambda_1.Lambda2_toFunction(f);\r\n        this.out = out;\r\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f)));\r\n        this.accumValid = false;\r\n    }\r\n    CoalesceHandler.prototype.send_ = function (a) {\r\n        var _this = this;\r\n        if (this.accumValid)\r\n            this.accum = this.f(this.accum, a);\r\n        else {\r\n            Transaction_1.Transaction.currentTransaction.prioritized(this.out.getVertex__(), function () {\r\n                _this.out.send_(_this.accum);\r\n                _this.accumValid = false;\r\n                _this.accum = null;\r\n            });\r\n            this.accum = a;\r\n            this.accumValid = true;\r\n        }\r\n    };\r\n    return CoalesceHandler;\r\n}());\r\nexports.CoalesceHandler = CoalesceHandler;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * A representation for a value that may not be available until the current\r\n * transaction is closed.\r\n */\r\nvar Lazy = (function () {\r\n    function Lazy(f) {\r\n        this.f = f;\r\n    }\r\n    /**\r\n     * Get the value if available, throwing an exception if not.\r\n     * In the general case this should only be used in subsequent transactions to\r\n     * when the Lazy was obtained.\r\n     */\r\n    Lazy.prototype.get = function () {\r\n        return this.f();\r\n    };\r\n    /**\r\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazy's value.\r\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\r\n     */\r\n    Lazy.prototype.map = function (f) {\r\n        var _this = this;\r\n        return new Lazy(function () { return f(_this.f()); });\r\n    };\r\n    /**\r\n     * Lift a binary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n     */\r\n    Lazy.prototype.lift = function (b, f) {\r\n        var _this = this;\r\n        return new Lazy(function () { return f(_this.f(), b.f()); });\r\n    };\r\n    /**\r\n     * Lift a ternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n     */\r\n    Lazy.prototype.lift3 = function (b, c, f) {\r\n        var _this = this;\r\n        return new Lazy(function () { return f(_this.f(), b.f(), c.f()); });\r\n    };\r\n    /**\r\n     * Lift a quaternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n     */\r\n    Lazy.prototype.lift4 = function (b, c, d, f) {\r\n        var _this = this;\r\n        return new Lazy(function () { return f(_this.f(), b.f(), c.f(), d.f()); });\r\n    };\r\n    return Lazy;\r\n}());\r\nexports.Lazy = Lazy;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Stream_1 = __webpack_require__(3);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar Unit_1 = __webpack_require__(17);\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar Operational = (function () {\r\n    function Operational() {\r\n    }\r\n    /**\r\n     * A stream that gives the updates/steps for a {@link Cell}.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    Operational.updates = function (c) {\r\n        /*  Don't think this is needed\r\n        const out = new StreamWithSend<A>(null);\r\n        out.setVertex__(new Vertex(\"updates\", 0, [\r\n                new Source(\r\n                    c.getStream__().getVertex__(),\r\n                    () => {\r\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\r\n                            out.send_(a);\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(\r\n                    c.getVertex__(),\r\n                    () => {\r\n                        return () => { };\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return out;\r\n        */\r\n        return c.getStream__();\r\n    };\r\n    /**\r\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\r\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\r\n     * firing for each update/step of the cell's value.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    Operational.value = function (c) {\r\n        return Transaction_1.Transaction.run(function () {\r\n            var sSpark = new Stream_1.StreamWithSend();\r\n            Transaction_1.Transaction.currentTransaction.prioritized(sSpark.getVertex__(), function () {\r\n                sSpark.send_(Unit_1.Unit.UNIT);\r\n            });\r\n            var sInitial = sSpark.snapshot1(c);\r\n            return Operational.updates(c).orElse(sInitial);\r\n        });\r\n    };\r\n    /**\r\n     * Push each event onto a new transaction guaranteed to come before the next externally\r\n     * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\r\n     */\r\n    Operational.defer = function (s) {\r\n        return Operational.split(s.map(function (a) {\r\n            return [a];\r\n        }));\r\n    };\r\n    /**\r\n     * Push each event in the list onto a newly created transaction guaranteed\r\n     * to come before the next externally initiated transaction. Note that the semantics\r\n     * are such that two different invocations of split() can put events into the same\r\n     * new transaction, so the resulting stream's events could be simultaneous with\r\n     * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\r\n     */\r\n    Operational.split = function (s) {\r\n        var out = new Stream_1.StreamWithSend(null);\r\n        out.setVertex__(new Vertex_1.Vertex(\"split\", 0, [\r\n            new Vertex_1.Source(s.getVertex__(), function () {\r\n                return s.listen_(out.getVertex__(), function (as) {\r\n                    var _loop_1 = function (i) {\r\n                        Transaction_1.Transaction.currentTransaction.post(i, function () {\r\n                            Transaction_1.Transaction.run(function () {\r\n                                out.send_(as[i]);\r\n                            });\r\n                        });\r\n                    };\r\n                    for (var i = 0; i < as.length; i++) {\r\n                        _loop_1(i);\r\n                    }\r\n                }, false);\r\n            })\r\n        ]));\r\n        return out;\r\n    };\r\n    return Operational;\r\n}());\r\nexports.Operational = Operational;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Unit = (function () {\r\n    function Unit() {\r\n    }\r\n    Unit.UNIT = new Unit();\r\n    return Unit;\r\n}());\r\nexports.Unit = Unit;\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Cell_1 = __webpack_require__(7);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar LazyCell = (function (_super) {\r\n    __extends(LazyCell, _super);\r\n    function LazyCell(lazyInitValue, str) {\r\n        var _this = _super.call(this, null, null) || this;\r\n        Transaction_1.Transaction.run(function () {\r\n            if (str)\r\n                _this.setStream(str);\r\n            _this.lazyInitValue = lazyInitValue;\r\n        });\r\n        return _this;\r\n    }\r\n    LazyCell.prototype.sampleNoTrans__ = function () {\r\n        if (this.value == null && this.lazyInitValue != null) {\r\n            this.value = this.lazyInitValue.get();\r\n            this.lazyInitValue = null;\r\n        }\r\n        return this.value;\r\n    };\r\n    return LazyCell;\r\n}(Cell_1.Cell));\r\nexports.LazyCell = LazyCell;\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Stream_1 = __webpack_require__(3);\r\nvar CoalesceHandler_1 = __webpack_require__(14);\r\nvar Transaction_1 = __webpack_require__(1);\r\n/**\r\n * A stream that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\r\n * should downcast to {@link Stream}.\r\n */\r\nvar StreamSink = (function (_super) {\r\n    __extends(StreamSink, _super);\r\n    function StreamSink(f) {\r\n        var _this = _super.call(this) || this;\r\n        if (!f)\r\n            f = (function (l, r) {\r\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\r\n            });\r\n        _this.coalescer = new CoalesceHandler_1.CoalesceHandler(f, _this);\r\n        return _this;\r\n    }\r\n    StreamSink.prototype.send = function (a) {\r\n        var _this = this;\r\n        Transaction_1.Transaction.run(function () {\r\n            if (Transaction_1.Transaction.currentTransaction.inCallback > 0)\r\n                throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\r\n            _this.coalescer.send_(a);\r\n        });\r\n    };\r\n    return StreamSink;\r\n}(Stream_1.StreamWithSend));\r\nexports.StreamSink = StreamSink;\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Cell_1 = __webpack_require__(7);\r\nvar StreamSink_1 = __webpack_require__(19);\r\n/**\r\n * A cell that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\r\n * should downcast to {@link Cell}.\r\n */\r\nvar CellSink = (function (_super) {\r\n    __extends(CellSink, _super);\r\n    /**\r\n     * Construct a writable cell with the specified initial value. If multiple values are\r\n     * sent in the same transaction, the specified function is used to combine them.\r\n     *\r\n     * If the function is not supplied, then an exception will be thrown in this case.\r\n     */\r\n    function CellSink(initValue, f) {\r\n        return _super.call(this, initValue, new StreamSink_1.StreamSink(f)) || this;\r\n    }\r\n    /**\r\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\r\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\r\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\r\n     * You are not meant to use this to define your own primitives.\r\n     * @param a Value to push into the cell.\r\n     */\r\n    CellSink.prototype.send = function (a) {\r\n        this.getStream__().send(a);\r\n    };\r\n    return CellSink;\r\n}(Cell_1.Cell));\r\nexports.CellSink = CellSink;\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Lambda_1 = __webpack_require__(6);\r\nexports.lambda1 = Lambda_1.lambda1;\r\nexports.lambda2 = Lambda_1.lambda2;\r\nexports.lambda3 = Lambda_1.lambda3;\r\nexports.lambda4 = Lambda_1.lambda4;\r\nexports.lambda5 = Lambda_1.lambda5;\r\nexports.lambda6 = Lambda_1.lambda6;\r\nvar Stream_1 = __webpack_require__(3);\r\nexports.Stream = Stream_1.Stream;\r\nexports.StreamLoop = Stream_1.StreamLoop;\r\nvar StreamSink_1 = __webpack_require__(19);\r\nexports.StreamSink = StreamSink_1.StreamSink;\r\nvar Cell_1 = __webpack_require__(7);\r\nexports.Cell = Cell_1.Cell;\r\nvar CellLoop_1 = __webpack_require__(29);\r\nexports.CellLoop = CellLoop_1.CellLoop;\r\nvar CellSink_1 = __webpack_require__(20);\r\nexports.CellSink = CellSink_1.CellSink;\r\nvar Transaction_1 = __webpack_require__(1);\r\nexports.Transaction = Transaction_1.Transaction;\r\nvar Tuple2_1 = __webpack_require__(30);\r\nexports.Tuple2 = Tuple2_1.Tuple2;\r\nvar Unit_1 = __webpack_require__(17);\r\nexports.Unit = Unit_1.Unit;\r\nvar Operational_1 = __webpack_require__(16);\r\nexports.Operational = Operational_1.Operational;\r\nvar Vertex_1 = __webpack_require__(2);\r\nexports.getTotalRegistrations = Vertex_1.getTotalRegistrations;\r\nexports.Vertex = Vertex_1.Vertex;\r\nvar TimerSystem_1 = __webpack_require__(9);\r\nexports.TimerSystemImpl = TimerSystem_1.TimerSystemImpl;\r\nexports.TimerSystem = TimerSystem_1.TimerSystem;\r\nvar SecondsTimerSystem_1 = __webpack_require__(31);\r\nexports.SecondsTimerSystem = SecondsTimerSystem_1.SecondsTimerSystem;\r\nvar MillisecondsTimerSystem_1 = __webpack_require__(32);\r\nexports.MillisecondsTimerSystem = MillisecondsTimerSystem_1.MillisecondsTimerSystem;\r\nvar IOAction_1 = __webpack_require__(33);\r\nexports.IOAction = IOAction_1.IOAction;\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar Dictionary_1 = __webpack_require__(5);\nvar Set_1 = __webpack_require__(11);\nvar Bag = (function () {\n    /**\n     * Creates an empty bag.\n     * @class <p>A bag is a special kind of set in which members are\n     * allowed to appear more than once.</p>\n     * <p>If the inserted elements are custom objects a function\n     * which converts elements to unique strings must be provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function used\n     * to convert elements to strings. If the elements aren't strings or if toString()\n     * is not appropriate, a custom function which receives an object and returns a\n     * unique string must be provided.\n     */\n    function Bag(toStrFunction) {\n        this.toStrF = toStrFunction || util.defaultToString;\n        this.dictionary = new Dictionary_1.default(this.toStrF);\n        this.nElements = 0;\n    }\n    /**\n    * Adds nCopies of the specified object to this bag.\n    * @param {Object} element element to add.\n    * @param {number=} nCopies the number of copies to add, if this argument is\n    * undefined 1 copy is added.\n    * @return {boolean} true unless element is undefined.\n    */\n    Bag.prototype.add = function (element, nCopies) {\n        if (nCopies === void 0) { nCopies = 1; }\n        if (util.isUndefined(element) || nCopies <= 0) {\n            return false;\n        }\n        if (!this.contains(element)) {\n            var node = {\n                value: element,\n                copies: nCopies\n            };\n            this.dictionary.setValue(element, node);\n        }\n        else {\n            this.dictionary.getValue(element).copies += nCopies;\n        }\n        this.nElements += nCopies;\n        return true;\n    };\n    /**\n    * Counts the number of copies of the specified object in this bag.\n    * @param {Object} element the object to search for..\n    * @return {number} the number of copies of the object, 0 if not found\n    */\n    Bag.prototype.count = function (element) {\n        if (!this.contains(element)) {\n            return 0;\n        }\n        else {\n            return this.dictionary.getValue(element).copies;\n        }\n    };\n    /**\n     * Returns true if this bag contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this bag contains the specified element,\n     * false otherwise.\n     */\n    Bag.prototype.contains = function (element) {\n        return this.dictionary.containsKey(element);\n    };\n    /**\n    * Removes nCopies of the specified object to this bag.\n    * If the number of copies to remove is greater than the actual number\n    * of copies in the Bag, all copies are removed.\n    * @param {Object} element element to remove.\n    * @param {number=} nCopies the number of copies to remove, if this argument is\n    * undefined 1 copy is removed.\n    * @return {boolean} true if at least 1 element was removed.\n    */\n    Bag.prototype.remove = function (element, nCopies) {\n        if (nCopies === void 0) { nCopies = 1; }\n        if (util.isUndefined(element) || nCopies <= 0) {\n            return false;\n        }\n        if (!this.contains(element)) {\n            return false;\n        }\n        else {\n            var node = this.dictionary.getValue(element);\n            if (nCopies > node.copies) {\n                this.nElements -= node.copies;\n            }\n            else {\n                this.nElements -= nCopies;\n            }\n            node.copies -= nCopies;\n            if (node.copies <= 0) {\n                this.dictionary.remove(element);\n            }\n            return true;\n        }\n    };\n    /**\n     * Returns an array containing all of the elements in this big in arbitrary order,\n     * including multiple copies.\n     * @return {Array} an array containing all of the elements in this bag.\n     */\n    Bag.prototype.toArray = function () {\n        var a = [];\n        var values = this.dictionary.values();\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var node = values_1[_i];\n            var element = node.value;\n            var copies = node.copies;\n            for (var j = 0; j < copies; j++) {\n                a.push(element);\n            }\n        }\n        return a;\n    };\n    /**\n     * Returns a set of unique elements in this bag.\n     * @return {collections.Set<T>} a set of unique elements in this bag.\n     */\n    Bag.prototype.toSet = function () {\n        var toret = new Set_1.default(this.toStrF);\n        var elements = this.dictionary.values();\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n            var ele = elements_1[_i];\n            var value = ele.value;\n            toret.add(value);\n        }\n        return toret;\n    };\n    /**\n     * Executes the provided function once for each element\n     * present in this bag, including multiple copies.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element. To break the iteration you can\n     * optionally return false.\n     */\n    Bag.prototype.forEach = function (callback) {\n        this.dictionary.forEach(function (k, v) {\n            var value = v.value;\n            var copies = v.copies;\n            for (var i = 0; i < copies; i++) {\n                if (callback(value) === false) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    };\n    /**\n     * Returns the number of elements in this bag.\n     * @return {number} the number of elements in this bag.\n     */\n    Bag.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this bag contains no elements.\n     * @return {boolean} true if this bag contains no elements.\n     */\n    Bag.prototype.isEmpty = function () {\n        return this.nElements === 0;\n    };\n    /**\n     * Removes all of the elements from this bag.\n     */\n    Bag.prototype.clear = function () {\n        this.nElements = 0;\n        this.dictionary.clear();\n    };\n    return Bag;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Bag; // End of bag\n//# sourceMappingURL=Bag.js.map\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar Queue_1 = __webpack_require__(12);\nvar BSTree = (function () {\n    /**\n     * Creates an empty binary search tree.\n     * @class <p>A binary search tree is a binary tree in which each\n     * internal node stores an element such that the elements stored in the\n     * left subtree are less than it and the elements\n     * stored in the right subtree are greater.</p>\n     * <p>Formally, a binary search tree is a node-based binary tree data structure which\n     * has the following properties:</p>\n     * <ul>\n     * <li>The left subtree of a node contains only nodes with elements less\n     * than the node's element</li>\n     * <li>The right subtree of a node contains only nodes with elements greater\n     * than the node's element</li>\n     * <li>Both the left and right subtrees must also be binary search trees.</li>\n     * </ul>\n     * <p>If the inserted elements are custom objects a compare function must\n     * be provided at construction time, otherwise the <=, === and >= operators are\n     * used to compare elements. Example:</p>\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two elements. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function BSTree(compareFunction) {\n        this.root = null;\n        this.compare = compareFunction || util.defaultCompare;\n        this.nElements = 0;\n    }\n    /**\n     * Adds the specified element to this tree if it is not already present.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if this tree did not already contain the specified element.\n     */\n    BSTree.prototype.add = function (element) {\n        if (util.isUndefined(element)) {\n            return false;\n        }\n        if (this.insertNode(this.createNode(element)) !== null) {\n            this.nElements++;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Removes all of the elements from this tree.\n     */\n    BSTree.prototype.clear = function () {\n        this.root = null;\n        this.nElements = 0;\n    };\n    /**\n     * Returns true if this tree contains no elements.\n     * @return {boolean} true if this tree contains no elements.\n     */\n    BSTree.prototype.isEmpty = function () {\n        return this.nElements === 0;\n    };\n    /**\n     * Returns the number of elements in this tree.\n     * @return {number} the number of elements in this tree.\n     */\n    BSTree.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this tree contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this tree contains the specified element,\n     * false otherwise.\n     */\n    BSTree.prototype.contains = function (element) {\n        if (util.isUndefined(element)) {\n            return false;\n        }\n        return this.searchNode(this.root, element) !== null;\n    };\n    /**\n     * Removes the specified element from this tree if it is present.\n     * @return {boolean} true if this tree contained the specified element.\n     */\n    BSTree.prototype.remove = function (element) {\n        var node = this.searchNode(this.root, element);\n        if (node === null) {\n            return false;\n        }\n        this.removeNode(node);\n        this.nElements--;\n        return true;\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in\n     * in-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.inorderTraversal = function (callback) {\n        this.inorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in pre-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.preorderTraversal = function (callback) {\n        this.preorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in post-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.postorderTraversal = function (callback) {\n        this.postorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in\n     * level-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.levelTraversal = function (callback) {\n        this.levelTraversalAux(this.root, callback);\n    };\n    /**\n     * Returns the minimum element of this tree.\n     * @return {*} the minimum element of this tree or undefined if this tree is\n     * is empty.\n     */\n    BSTree.prototype.minimum = function () {\n        if (this.isEmpty()) {\n            return undefined;\n        }\n        return this.minimumAux(this.root).element;\n    };\n    /**\n     * Returns the maximum element of this tree.\n     * @return {*} the maximum element of this tree or undefined if this tree is\n     * is empty.\n     */\n    BSTree.prototype.maximum = function () {\n        if (this.isEmpty()) {\n            return undefined;\n        }\n        return this.maximumAux(this.root).element;\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in inorder.\n     * Equivalent to inorderTraversal.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    BSTree.prototype.forEach = function (callback) {\n        this.inorderTraversal(callback);\n    };\n    /**\n     * Returns an array containing all of the elements in this tree in in-order.\n     * @return {Array} an array containing all of the elements in this tree in in-order.\n     */\n    BSTree.prototype.toArray = function () {\n        var array = [];\n        this.inorderTraversal(function (element) {\n            array.push(element);\n            return true;\n        });\n        return array;\n    };\n    /**\n     * Returns the height of this tree.\n     * @return {number} the height of this tree or -1 if is empty.\n     */\n    BSTree.prototype.height = function () {\n        return this.heightAux(this.root);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.searchNode = function (node, element) {\n        var cmp = null;\n        while (node !== null && cmp !== 0) {\n            cmp = this.compare(element, node.element);\n            if (cmp < 0) {\n                node = node.leftCh;\n            }\n            else if (cmp > 0) {\n                node = node.rightCh;\n            }\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.transplant = function (n1, n2) {\n        if (n1.parent === null) {\n            this.root = n2;\n        }\n        else if (n1 === n1.parent.leftCh) {\n            n1.parent.leftCh = n2;\n        }\n        else {\n            n1.parent.rightCh = n2;\n        }\n        if (n2 !== null) {\n            n2.parent = n1.parent;\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.removeNode = function (node) {\n        if (node.leftCh === null) {\n            this.transplant(node, node.rightCh);\n        }\n        else if (node.rightCh === null) {\n            this.transplant(node, node.leftCh);\n        }\n        else {\n            var y = this.minimumAux(node.rightCh);\n            if (y.parent !== node) {\n                this.transplant(y, y.rightCh);\n                y.rightCh = node.rightCh;\n                y.rightCh.parent = y;\n            }\n            this.transplant(node, y);\n            y.leftCh = node.leftCh;\n            y.leftCh.parent = y;\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.inorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        this.inorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n        if (signal.stop) {\n            return;\n        }\n        this.inorderTraversalAux(node.rightCh, callback, signal);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.levelTraversalAux = function (node, callback) {\n        var queue = new Queue_1.default();\n        if (node !== null) {\n            queue.enqueue(node);\n        }\n        while (!queue.isEmpty()) {\n            node = queue.dequeue();\n            if (callback(node.element) === false) {\n                return;\n            }\n            if (node.leftCh !== null) {\n                queue.enqueue(node.leftCh);\n            }\n            if (node.rightCh !== null) {\n                queue.enqueue(node.rightCh);\n            }\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.preorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n        if (signal.stop) {\n            return;\n        }\n        this.preorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        this.preorderTraversalAux(node.rightCh, callback, signal);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.postorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        this.postorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        this.postorderTraversalAux(node.rightCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.minimumAux = function (node) {\n        while (node.leftCh !== null) {\n            node = node.leftCh;\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.maximumAux = function (node) {\n        while (node.rightCh !== null) {\n            node = node.rightCh;\n        }\n        return node;\n    };\n    /**\n      * @private\n      */\n    BSTree.prototype.heightAux = function (node) {\n        if (node === null) {\n            return -1;\n        }\n        return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;\n    };\n    /*\n    * @private\n    */\n    BSTree.prototype.insertNode = function (node) {\n        var parent = null;\n        var position = this.root;\n        var cmp = null;\n        while (position !== null) {\n            cmp = this.compare(node.element, position.element);\n            if (cmp === 0) {\n                return null;\n            }\n            else if (cmp < 0) {\n                parent = position;\n                position = position.leftCh;\n            }\n            else {\n                parent = position;\n                position = position.rightCh;\n            }\n        }\n        node.parent = parent;\n        if (parent === null) {\n            // tree is empty\n            this.root = node;\n        }\n        else if (this.compare(node.element, parent.element) < 0) {\n            parent.leftCh = node;\n        }\n        else {\n            parent.rightCh = node;\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.createNode = function (element) {\n        return {\n            element: element,\n            leftCh: null,\n            rightCh: null,\n            parent: null\n        };\n    };\n    return BSTree;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BSTree;\n//# sourceMappingURL=BSTree.js.map\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Dictionary_1 = __webpack_require__(5);\nvar util = __webpack_require__(0);\n/**\n * This class is used by the LinkedDictionary Internally\n * Has to be a class, not an interface, because it needs to have\n * the 'unlink' function defined.\n */\nvar LinkedDictionaryPair = (function () {\n    function LinkedDictionaryPair(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    LinkedDictionaryPair.prototype.unlink = function () {\n        this.prev.next = this.next;\n        this.next.prev = this.prev;\n    };\n    return LinkedDictionaryPair;\n}());\nvar LinkedDictionary = (function (_super) {\n    __extends(LinkedDictionary, _super);\n    function LinkedDictionary(toStrFunction) {\n        _super.call(this, toStrFunction);\n        this.head = new LinkedDictionaryPair(null, null);\n        this.tail = new LinkedDictionaryPair(null, null);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    /**\n     * Inserts the new node to the 'tail' of the list, updating the\n     * neighbors, and moving 'this.tail' (the End of List indicator) that\n     * to the end.\n     */\n    LinkedDictionary.prototype.appendToTail = function (entry) {\n        var lastNode = this.tail.prev;\n        lastNode.next = entry;\n        entry.prev = lastNode;\n        entry.next = this.tail;\n        this.tail.prev = entry;\n    };\n    /**\n     * Retrieves a linked dictionary from the table internally\n     */\n    LinkedDictionary.prototype.getLinkedDictionaryPair = function (key) {\n        if (util.isUndefined(key)) {\n            return undefined;\n        }\n        var k = '$' + this.toStr(key);\n        var pair = (this.table[k]);\n        return pair;\n    };\n    /**\n     * Returns the value to which this dictionary maps the specified key.\n     * Returns undefined if this dictionary contains no mapping for this key.\n     * @param {Object} key key whose associated value is to be returned.\n     * @return {*} the value to which this dictionary maps the specified key or\n     * undefined if the map contains no mapping for this key.\n     */\n    LinkedDictionary.prototype.getValue = function (key) {\n        var pair = this.getLinkedDictionaryPair(key);\n        if (!util.isUndefined(pair)) {\n            return pair.value;\n        }\n        return undefined;\n    };\n    /**\n     * Removes the mapping for this key from this dictionary if it is present.\n     * Also, if a value is present for this key, the entry is removed from the\n     * insertion ordering.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @return {*} previous value associated with specified key, or undefined if\n     * there was no mapping for key.\n     */\n    LinkedDictionary.prototype.remove = function (key) {\n        var pair = this.getLinkedDictionaryPair(key);\n        if (!util.isUndefined(pair)) {\n            _super.prototype.remove.call(this, key); // This will remove it from the table\n            pair.unlink(); // This will unlink it from the chain\n            return pair.value;\n        }\n        return undefined;\n    };\n    /**\n    * Removes all mappings from this LinkedDictionary.\n    * @this {collections.LinkedDictionary}\n    */\n    LinkedDictionary.prototype.clear = function () {\n        _super.prototype.clear.call(this);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    };\n    /**\n     * Internal function used when updating an existing KeyValue pair.\n     * It places the new value indexed by key into the table, but maintains\n     * its place in the linked ordering.\n     */\n    LinkedDictionary.prototype.replace = function (oldPair, newPair) {\n        var k = '$' + this.toStr(newPair.key);\n        // set the new Pair's links to existingPair's links\n        newPair.next = oldPair.next;\n        newPair.prev = oldPair.prev;\n        // Delete Existing Pair from the table, unlink it from chain.\n        // As a result, the nElements gets decremented by this operation\n        this.remove(oldPair.key);\n        // Link new Pair in place of where oldPair was,\n        // by pointing the old pair's neighbors to it.\n        newPair.prev.next = newPair;\n        newPair.next.prev = newPair;\n        this.table[k] = newPair;\n        // To make up for the fact that the number of elements was decremented,\n        // We need to increase it by one.\n        ++this.nElements;\n    };\n    /**\n     * Associates the specified value with the specified key in this dictionary.\n     * If the dictionary previously contained a mapping for this key, the old\n     * value is replaced by the specified value.\n     * Updating of a key that already exists maintains its place in the\n     * insertion order into the map.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value value to be associated with the specified key.\n     * @return {*} previous value associated with the specified key, or undefined if\n     * there was no mapping for the key or if the key/value are undefined.\n     */\n    LinkedDictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return undefined;\n        }\n        var existingPair = this.getLinkedDictionaryPair(key);\n        var newPair = new LinkedDictionaryPair(key, value);\n        var k = '$' + this.toStr(key);\n        // If there is already an element for that key, we\n        // keep it's place in the LinkedList\n        if (!util.isUndefined(existingPair)) {\n            this.replace(existingPair, newPair);\n            return existingPair.value;\n        }\n        else {\n            this.appendToTail(newPair);\n            this.table[k] = newPair;\n            ++this.nElements;\n            return undefined;\n        }\n    };\n    /**\n     * Returns an array containing all of the keys in this LinkedDictionary, ordered\n     * by insertion order.\n     * @return {Array} an array containing all of the keys in this LinkedDictionary,\n     * ordered by insertion order.\n     */\n    LinkedDictionary.prototype.keys = function () {\n        var array = [];\n        this.forEach(function (key, value) {\n            array.push(key);\n        });\n        return array;\n    };\n    /**\n     * Returns an array containing all of the values in this LinkedDictionary, ordered by\n     * insertion order.\n     * @return {Array} an array containing all of the values in this LinkedDictionary,\n     * ordered by insertion order.\n     */\n    LinkedDictionary.prototype.values = function () {\n        var array = [];\n        this.forEach(function (key, value) {\n            array.push(value);\n        });\n        return array;\n    };\n    /**\n    * Executes the provided function once for each key-value pair\n    * present in this LinkedDictionary. It is done in the order of insertion\n    * into the LinkedDictionary\n    * @param {function(Object,Object):*} callback function to execute, it is\n    * invoked with two arguments: key and value. To break the iteration you can\n    * optionally return false.\n    */\n    LinkedDictionary.prototype.forEach = function (callback) {\n        var crawlNode = this.head.next;\n        while (crawlNode.next != null) {\n            var ret = callback(crawlNode.key, crawlNode.value);\n            if (ret === false) {\n                return;\n            }\n            crawlNode = crawlNode.next;\n        }\n    };\n    return LinkedDictionary;\n}(Dictionary_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedDictionary; // End of LinkedDictionary\n// /**\n//  * Returns true if this dictionary is equal to the given dictionary.\n//  * Two dictionaries are equal if they contain the same mappings.\n//  * @param {collections.Dictionary} other the other dictionary.\n//  * @param {function(Object,Object):boolean=} valuesEqualFunction optional\n//  * function used to check if two values are equal.\n//  * @return {boolean} true if this dictionary is equal to the given dictionary.\n//  */\n// collections.Dictionary.prototype.equals = function(other,valuesEqualFunction) {\n// \tconst eqF = valuesEqualFunction || collections.defaultEquals;\n// \tif(!(other instanceof collections.Dictionary)){\n// \t\treturn false;\n// \t}\n// \tif(this.size() !== other.size()){\n// \t\treturn false;\n// \t}\n// \treturn this.equalsAux(this.firstNode,other.firstNode,eqF);\n// }\n//# sourceMappingURL=LinkedDictionary.js.map\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar Dictionary_1 = __webpack_require__(5);\nvar arrays = __webpack_require__(4);\nvar MultiDictionary = (function () {\n    /**\n     * Creates an empty multi dictionary.\n     * @class <p>A multi dictionary is a special kind of dictionary that holds\n     * multiple values against each key. Setting a value into the dictionary will\n     * add the value to an array at that key. Getting a key will return an array,\n     * holding all the values set to that key.\n     * You can configure to allow duplicates in the values.\n     * This implementation accepts any kind of objects as keys.</p>\n     *\n     * <p>If the keys are custom objects a function which converts keys to strings must be\n     * provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n       *  return pet.name;\n       * }\n     * </pre>\n     * <p>If the values are custom objects a function to check equality between values\n     * must be provided. Example:</p>\n     *\n     * <pre>\n     * function petsAreEqualByAge(pet1,pet2) {\n       *  return pet1.age===pet2.age;\n       * }\n     * </pre>\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function\n     * to convert keys to strings. If the keys aren't strings or if toString()\n     * is not appropriate, a custom function which receives a key and returns a\n     * unique string must be provided.\n     * @param {function(Object,Object):boolean=} valuesEqualsFunction optional\n     * function to check if two values are equal.\n     *\n     * @param allowDuplicateValues\n     */\n    function MultiDictionary(toStrFunction, valuesEqualsFunction, allowDuplicateValues) {\n        if (allowDuplicateValues === void 0) { allowDuplicateValues = false; }\n        this.dict = new Dictionary_1.default(toStrFunction);\n        this.equalsF = valuesEqualsFunction || util.defaultEquals;\n        this.allowDuplicate = allowDuplicateValues;\n    }\n    /**\n    * Returns an array holding the values to which this dictionary maps\n    * the specified key.\n    * Returns an empty array if this dictionary contains no mappings for this key.\n    * @param {Object} key key whose associated values are to be returned.\n    * @return {Array} an array holding the values to which this dictionary maps\n    * the specified key.\n    */\n    MultiDictionary.prototype.getValue = function (key) {\n        var values = this.dict.getValue(key);\n        if (util.isUndefined(values)) {\n            return [];\n        }\n        return arrays.copy(values);\n    };\n    /**\n     * Adds the value to the array associated with the specified key, if\n     * it is not already present.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value the value to add to the array at the key\n     * @return {boolean} true if the value was not already associated with that key.\n     */\n    MultiDictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return false;\n        }\n        if (!this.containsKey(key)) {\n            this.dict.setValue(key, [value]);\n            return true;\n        }\n        var array = this.dict.getValue(key);\n        if (!this.allowDuplicate) {\n            if (arrays.contains(array, value, this.equalsF)) {\n                return false;\n            }\n        }\n        array.push(value);\n        return true;\n    };\n    /**\n     * Removes the specified values from the array of values associated with the\n     * specified key. If a value isn't given, all values associated with the specified\n     * key are removed.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @param {Object=} value optional argument to specify the value to remove\n     * from the array associated with the specified key.\n     * @return {*} true if the dictionary changed, false if the key doesn't exist or\n     * if the specified value isn't associated with the specified key.\n     */\n    MultiDictionary.prototype.remove = function (key, value) {\n        if (util.isUndefined(value)) {\n            var v = this.dict.remove(key);\n            return !util.isUndefined(v);\n        }\n        var array = this.dict.getValue(key);\n        if (arrays.remove(array, value, this.equalsF)) {\n            if (array.length === 0) {\n                this.dict.remove(key);\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns an array containing all of the keys in this dictionary.\n     * @return {Array} an array containing all of the keys in this dictionary.\n     */\n    MultiDictionary.prototype.keys = function () {\n        return this.dict.keys();\n    };\n    /**\n     * Returns an array containing all of the values in this dictionary.\n     * @return {Array} an array containing all of the values in this dictionary.\n     */\n    MultiDictionary.prototype.values = function () {\n        var values = this.dict.values();\n        var array = [];\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var v = values_1[_i];\n            for (var _a = 0, v_1 = v; _a < v_1.length; _a++) {\n                var w = v_1[_a];\n                array.push(w);\n            }\n        }\n        return array;\n    };\n    /**\n     * Returns true if this dictionary at least one value associatted the specified key.\n     * @param {Object} key key whose presence in this dictionary is to be\n     * tested.\n     * @return {boolean} true if this dictionary at least one value associatted\n     * the specified key.\n     */\n    MultiDictionary.prototype.containsKey = function (key) {\n        return this.dict.containsKey(key);\n    };\n    /**\n     * Removes all mappings from this dictionary.\n     */\n    MultiDictionary.prototype.clear = function () {\n        this.dict.clear();\n    };\n    /**\n     * Returns the number of keys in this dictionary.\n     * @return {number} the number of key-value mappings in this dictionary.\n     */\n    MultiDictionary.prototype.size = function () {\n        return this.dict.size();\n    };\n    /**\n     * Returns true if this dictionary contains no mappings.\n     * @return {boolean} true if this dictionary contains no mappings.\n     */\n    MultiDictionary.prototype.isEmpty = function () {\n        return this.dict.isEmpty();\n    };\n    return MultiDictionary;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MultiDictionary; // end of multi dictionary\n//# sourceMappingURL=MultiDictionary.js.map\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar util = __webpack_require__(0);\nvar Heap_1 = __webpack_require__(13);\nvar PriorityQueue = (function () {\n    /**\n     * Creates an empty priority queue.\n     * @class <p>In a priority queue each element is associated with a \"priority\",\n     * elements are dequeued in highest-priority-first order (the elements with the\n     * highest priority are dequeued first). Priority Queues are implemented as heaps.\n     * If the inserted elements are custom objects a compare function must be provided,\n     * otherwise the <=, === and >= operators are used to compare object priority.</p>\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two element priorities. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function PriorityQueue(compareFunction) {\n        this.heap = new Heap_1.default(util.reverseCompareFunction(compareFunction));\n    }\n    /**\n     * Inserts the specified element into this priority queue.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    PriorityQueue.prototype.enqueue = function (element) {\n        return this.heap.add(element);\n    };\n    /**\n     * Inserts the specified element into this priority queue.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    PriorityQueue.prototype.add = function (element) {\n        return this.heap.add(element);\n    };\n    /**\n     * Retrieves and removes the highest priority element of this queue.\n     * @return {*} the the highest priority element of this queue,\n     *  or undefined if this queue is empty.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        if (this.heap.size() !== 0) {\n            var el = this.heap.peek();\n            this.heap.removeRoot();\n            return el;\n        }\n        return undefined;\n    };\n    /**\n     * Retrieves, but does not remove, the highest priority element of this queue.\n     * @return {*} the highest priority element of this queue, or undefined if this queue is empty.\n     */\n    PriorityQueue.prototype.peek = function () {\n        return this.heap.peek();\n    };\n    /**\n     * Returns true if this priority queue contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this priority queue contains the specified element,\n     * false otherwise.\n     */\n    PriorityQueue.prototype.contains = function (element) {\n        return this.heap.contains(element);\n    };\n    /**\n     * Checks if this priority queue is empty.\n     * @return {boolean} true if and only if this priority queue contains no items; false\n     * otherwise.\n     */\n    PriorityQueue.prototype.isEmpty = function () {\n        return this.heap.isEmpty();\n    };\n    /**\n     * Returns the number of elements in this priority queue.\n     * @return {number} the number of elements in this priority queue.\n     */\n    PriorityQueue.prototype.size = function () {\n        return this.heap.size();\n    };\n    /**\n     * Removes all of the elements from this priority queue.\n     */\n    PriorityQueue.prototype.clear = function () {\n        this.heap.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this queue in\n     * no particular order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    PriorityQueue.prototype.forEach = function (callback) {\n        this.heap.forEach(callback);\n    };\n    return PriorityQueue;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = PriorityQueue; // end of priority queue\n//# sourceMappingURL=PriorityQueue.js.map\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LinkedList_1 = __webpack_require__(8);\nvar Stack = (function () {\n    /**\n     * Creates an empty Stack.\n     * @class A Stack is a Last-In-First-Out (LIFO) data structure, the last\n     * element added to the stack will be the first one to be removed. This\n     * implementation uses a linked list as a container.\n     * @constructor\n     */\n    function Stack() {\n        this.list = new LinkedList_1.default();\n    }\n    /**\n     * Pushes an item onto the top of this stack.\n     * @param {Object} elem the element to be pushed onto this stack.\n     * @return {boolean} true if the element was pushed or false if it is undefined.\n     */\n    Stack.prototype.push = function (elem) {\n        return this.list.add(elem, 0);\n    };\n    /**\n     * Pushes an item onto the top of this stack.\n     * @param {Object} elem the element to be pushed onto this stack.\n     * @return {boolean} true if the element was pushed or false if it is undefined.\n     */\n    Stack.prototype.add = function (elem) {\n        return this.list.add(elem, 0);\n    };\n    /**\n     * Removes the object at the top of this stack and returns that object.\n     * @return {*} the object at the top of this stack or undefined if the\n     * stack is empty.\n     */\n    Stack.prototype.pop = function () {\n        return this.list.removeElementAtIndex(0);\n    };\n    /**\n     * Looks at the object at the top of this stack without removing it from the\n     * stack.\n     * @return {*} the object at the top of this stack or undefined if the\n     * stack is empty.\n     */\n    Stack.prototype.peek = function () {\n        return this.list.first();\n    };\n    /**\n     * Returns the number of elements in this stack.\n     * @return {number} the number of elements in this stack.\n     */\n    Stack.prototype.size = function () {\n        return this.list.size();\n    };\n    /**\n     * Returns true if this stack contains the specified element.\n     * <p>If the elements inside this stack are\n     * not comparable with the === operator, a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName (pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} elem element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function to check if two elements are equal.\n     * @return {boolean} true if this stack contains the specified element,\n     * false otherwise.\n     */\n    Stack.prototype.contains = function (elem, equalsFunction) {\n        return this.list.contains(elem, equalsFunction);\n    };\n    /**\n     * Checks if this stack is empty.\n     * @return {boolean} true if and only if this stack contains no items; false\n     * otherwise.\n     */\n    Stack.prototype.isEmpty = function () {\n        return this.list.isEmpty();\n    };\n    /**\n     * Removes all of the elements from this stack.\n     */\n    Stack.prototype.clear = function () {\n        this.list.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this stack in\n     * LIFO order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Stack.prototype.forEach = function (callback) {\n        this.list.forEach(callback);\n    };\n    return Stack;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stack; // End of stack\n//# sourceMappingURL=Stack.js.map\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Listener = (function () {\r\n    function Listener(h, target) {\r\n        this.h = h;\r\n        this.target = target;\r\n    }\r\n    return Listener;\r\n}());\r\nexports.Listener = Listener;\r\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LazyCell_1 = __webpack_require__(18);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar Stream_1 = __webpack_require__(3);\r\n/**\r\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\r\n */\r\nvar CellLoop = (function (_super) {\r\n    __extends(CellLoop, _super);\r\n    function CellLoop() {\r\n        return _super.call(this, null, new Stream_1.StreamLoop()) || this;\r\n    }\r\n    /**\r\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    CellLoop.prototype.loop = function (a_out) {\r\n        var me = this;\r\n        Transaction_1.Transaction.run(function () {\r\n            me.getStream__().loop(a_out.getStream__());\r\n            me.lazyInitValue = a_out.sampleLazy();\r\n        });\r\n    };\r\n    CellLoop.prototype.sampleNoTrans__ = function () {\r\n        if (!this.getStream__().assigned__)\r\n            throw new Error(\"CellLoop sampled before it was looped\");\r\n        return _super.prototype.sampleNoTrans__.call(this);\r\n    };\r\n    return CellLoop;\r\n}(LazyCell_1.LazyCell));\r\nexports.CellLoop = CellLoop;\r\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Tuple2 = (function () {\r\n    function Tuple2(a, b) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    return Tuple2;\r\n}());\r\nexports.Tuple2 = Tuple2;\r\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TimerSystem_1 = __webpack_require__(9);\r\n/**\r\n * A timer system implementation using seconds as the time unit.\r\n */\r\nvar SecondsTimerSystem = (function (_super) {\r\n    __extends(SecondsTimerSystem, _super);\r\n    function SecondsTimerSystem() {\r\n        return _super.call(this, new SecondsTimerSystemImpl()) || this;\r\n    }\r\n    return SecondsTimerSystem;\r\n}(TimerSystem_1.TimerSystem));\r\nexports.SecondsTimerSystem = SecondsTimerSystem;\r\nvar SecondsTimerSystemImpl = (function (_super) {\r\n    __extends(SecondsTimerSystemImpl, _super);\r\n    function SecondsTimerSystemImpl() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    SecondsTimerSystemImpl.prototype.setTimer = function (t, callback) {\r\n        var timeout = setTimeout(callback, Math.max((t - this.now()) * 1000, 0));\r\n        return function () { clearTimeout(timeout); };\r\n    };\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    SecondsTimerSystemImpl.prototype.now = function () {\r\n        return Date.now() * 0.001;\r\n    };\r\n    return SecondsTimerSystemImpl;\r\n}(TimerSystem_1.TimerSystemImpl));\r\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TimerSystem_1 = __webpack_require__(9);\r\n/**\r\n * A timer system implementation using milliseconds as the time unit.\r\n */\r\nvar MillisecondsTimerSystem = (function (_super) {\r\n    __extends(MillisecondsTimerSystem, _super);\r\n    function MillisecondsTimerSystem() {\r\n        return _super.call(this, new MillisecondsTimerSystemImpl()) || this;\r\n    }\r\n    return MillisecondsTimerSystem;\r\n}(TimerSystem_1.TimerSystem));\r\nexports.MillisecondsTimerSystem = MillisecondsTimerSystem;\r\nvar MillisecondsTimerSystemImpl = (function (_super) {\r\n    __extends(MillisecondsTimerSystemImpl, _super);\r\n    function MillisecondsTimerSystemImpl() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    MillisecondsTimerSystemImpl.prototype.setTimer = function (t, callback) {\r\n        var timeout = setTimeout(callback, Math.max(t - this.now(), 0));\r\n        return function () { clearTimeout(timeout); };\r\n    };\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    MillisecondsTimerSystemImpl.prototype.now = function () {\r\n        return Date.now();\r\n    };\r\n    return MillisecondsTimerSystemImpl;\r\n}(TimerSystem_1.TimerSystemImpl));\r\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Stream_1 = __webpack_require__(3);\r\nvar Vertex_1 = __webpack_require__(2);\r\nvar Transaction_1 = __webpack_require__(1);\r\nvar IOAction = (function () {\r\n    function IOAction() {\r\n    }\r\n    /*!\r\n     * Convert a function that performs asynchronous I/O taking input A\r\n     * and returning a value of type B into an I/O action of type\r\n     * (sa : Stream<A>) => Stream<B>\r\n     */\r\n    IOAction.fromAsync = function (performIO) {\r\n        return function (sa) {\r\n            var out = new Stream_1.StreamWithSend(null);\r\n            out.setVertex__(new Vertex_1.Vertex(\"map\", 0, [\r\n                new Vertex_1.Source(sa.getVertex__(), function () {\r\n                    return sa.listen_(out.getVertex__(), function (a) {\r\n                        performIO(a, function (b) {\r\n                            Transaction_1.Transaction.run(function () {\r\n                                out.send_(b);\r\n                            });\r\n                        });\r\n                    }, false);\r\n                })\r\n            ]));\r\n            return out;\r\n        };\r\n    };\r\n    return IOAction;\r\n}());\r\nexports.IOAction = IOAction;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// sodium.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 77c2100eaa3515868b63","\"use strict\";\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexports.has = function (obj, prop) {\n    return _hasOwnProperty.call(obj, prop);\n};\n/**\n * Default function to compare element order.\n * @function\n */\nfunction defaultCompare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a === b) {\n        return 0;\n    }\n    else {\n        return 1;\n    }\n}\nexports.defaultCompare = defaultCompare;\n/**\n * Default function to test equality.\n * @function\n */\nfunction defaultEquals(a, b) {\n    return a === b;\n}\nexports.defaultEquals = defaultEquals;\n/**\n * Default function to convert an object to a string.\n * @function\n */\nfunction defaultToString(item) {\n    if (item === null) {\n        return 'COLLECTION_NULL';\n    }\n    else if (isUndefined(item)) {\n        return 'COLLECTION_UNDEFINED';\n    }\n    else if (isString(item)) {\n        return '$s' + item;\n    }\n    else {\n        return '$o' + item.toString();\n    }\n}\nexports.defaultToString = defaultToString;\n/**\n* Joins all the properies of the object using the provided join string\n*/\nfunction makeString(item, join) {\n    if (join === void 0) { join = ','; }\n    if (item === null) {\n        return 'COLLECTION_NULL';\n    }\n    else if (isUndefined(item)) {\n        return 'COLLECTION_UNDEFINED';\n    }\n    else if (isString(item)) {\n        return item.toString();\n    }\n    else {\n        var toret = '{';\n        var first = true;\n        for (var prop in item) {\n            if (exports.has(item, prop)) {\n                if (first) {\n                    first = false;\n                }\n                else {\n                    toret = toret + join;\n                }\n                toret = toret + prop + ':' + item[prop];\n            }\n        }\n        return toret + '}';\n    }\n}\nexports.makeString = makeString;\n/**\n * Checks if the given argument is a function.\n * @function\n */\nfunction isFunction(func) {\n    return (typeof func) === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Checks if the given argument is undefined.\n * @function\n */\nfunction isUndefined(obj) {\n    return (typeof obj) === 'undefined';\n}\nexports.isUndefined = isUndefined;\n/**\n * Checks if the given argument is a string.\n * @function\n */\nfunction isString(obj) {\n    return Object.prototype.toString.call(obj) === '[object String]';\n}\nexports.isString = isString;\n/**\n * Reverses a compare function.\n * @function\n */\nfunction reverseCompareFunction(compareFunction) {\n    if (!isFunction(compareFunction)) {\n        return function (a, b) {\n            if (a < b) {\n                return 1;\n            }\n            else if (a === b) {\n                return 0;\n            }\n            else {\n                return -1;\n            }\n        };\n    }\n    else {\n        return function (d, v) {\n            return compareFunction(d, v) * -1;\n        };\n    }\n}\nexports.reverseCompareFunction = reverseCompareFunction;\n/**\n * Returns an equal function given a compare function.\n * @function\n */\nfunction compareToEquals(compareFunction) {\n    return function (a, b) {\n        return compareFunction(a, b) === 0;\n    };\n}\nexports.compareToEquals = compareToEquals;\n//# sourceMappingURL=util.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/util.js\n// module id = 0\n// module chunks = 0","import {Vertex} from './Vertex';\nimport {Set, PriorityQueue} from 'typescript-collections';\n\nexport class Entry\n{\n  constructor(rank: Vertex, action: () => void)\n  {\n    this.rank = rank;\n    this.action = action;\n    this.seq = Entry.nextSeq++;\n  }\n\n  private static nextSeq: number = 0;\n  rank: Vertex;\n  action: () => void;\n  seq: number;\n\n  toString(): string\n  {\n    return this.seq.toString();\n  }\n}\n\nexport class Transaction\n{\n  public static currentTransaction: Transaction = null;\n  private static onStartHooks: (() => void)[] = [];\n  private static runningOnStartHooks: boolean = false;\n\n  constructor() {}\n\n  inCallback: number = 0;\n  private toRegen: boolean = false;\n\n  requestRegen(): void\n  {\n    this.toRegen = true;\n  }\n\n  prioritizedQ: PriorityQueue<Entry> = new PriorityQueue<Entry>((a, b) =>\n  {\n    // Note: Low priority numbers are treated as \"greater\" according to this\n    // comparison, so that the lowest numbers are highest priority and go first.\n    if (a.rank.rank < b.rank.rank) return 1;\n    if (a.rank.rank > b.rank.rank) return -1;\n    if (a.seq < b.seq) return 1;\n    if (a.seq > b.seq) return -1;\n    return 0;\n  });\n  private entries: Set<Entry> = new Set<Entry>((a) => a.toString());\n  private lastQ: Array<() => void> = [];\n  private postQ: Array<() => void> = null;\n\n  prioritized(target: Vertex, f: () => void): void\n  {\n    const e = new Entry(target, f);\n    this.prioritizedQ.enqueue(e);\n    this.entries.add(e);\n  }\n\n  last(h: () => void): void\n  {\n    this.lastQ.push(h);\n  }\n\n  /**\n   * Add an action to run after all last() actions.\n   */\n  post(childIx: number, action: () => void): void\n  {\n    if (this.postQ == null)\n      this.postQ = [];\n    // If an entry exists already, combine the old one with the new one.\n    while (this.postQ.length <= childIx)\n      this.postQ.push(null);\n    const existing = this.postQ[childIx],\n      neu =\n        existing === null ? action\n          : () =>\n        {\n          existing();\n          action();\n        };\n    this.postQ[childIx] = neu;\n  }\n\n  // If the priority queue has entries in it when we modify any of the nodes'\n  // ranks, then we need to re-generate it to make sure it's up-to-date.\n  private checkRegen(): void\n  {\n    if (this.toRegen)\n    {\n      this.toRegen = false;\n      this.prioritizedQ.clear();\n      const es = this.entries.toArray();\n      for (let i: number = 0; i < es.length; i++)\n        this.prioritizedQ.enqueue(es[i]);\n    }\n  }\n\n  public isActive() : boolean\n  {\n    return Transaction.currentTransaction ? true : false;\n  }\n\n  close(): void\n  {\n    while (true)\n    {\n      this.checkRegen();\n      if (this.prioritizedQ.isEmpty()) break;\n      const e = this.prioritizedQ.dequeue();\n      this.entries.remove(e);\n      e.action();\n    }\n    for (let i = 0; i < this.lastQ.length; i++)\n      this.lastQ[i]();\n    this.lastQ = [];\n    if (this.postQ != null)\n    {\n      for (let i = 0; i < this.postQ.length; i++)\n      {\n        if (this.postQ[i] != null)\n        {\n          const parent = Transaction.currentTransaction;\n          try\n          {\n            if (i > 0)\n            {\n              Transaction.currentTransaction = new Transaction();\n              try\n              {\n                this.postQ[i]();\n                Transaction.currentTransaction.close();\n              }\n              catch (err)\n              {\n                Transaction.currentTransaction.close();\n                throw err;\n              }\n            }\n            else\n            {\n              Transaction.currentTransaction = null;\n              this.postQ[i]();\n            }\n            Transaction.currentTransaction = parent;\n          }\n          catch (err)\n          {\n            Transaction.currentTransaction = parent;\n            throw err;\n          }\n        }\n      }\n      this.postQ = null;\n    }\n  }\n\n  /**\n   * Add a runnable that will be executed whenever a transaction is started.\n   * That runnable may start transactions itself, which will not cause the\n   * hooks to be run recursively.\n   *\n   * The main use case of this is the implementation of a time/alarm system.\n   */\n  static onStart(r: () => void): void\n  {\n    Transaction.onStartHooks.push(r);\n  }\n\n  public static run<A>(f: () => A): A\n  {\n    const transWas: Transaction = Transaction.currentTransaction;\n    if (transWas === null)\n    {\n      if (!Transaction.runningOnStartHooks)\n      {\n        Transaction.runningOnStartHooks = true;\n        try\n        {\n          for (let i = 0; i < Transaction.onStartHooks.length; i++)\n            Transaction.onStartHooks[i]();\n        }\n        finally\n        {\n          Transaction.runningOnStartHooks = false;\n        }\n      }\n      Transaction.currentTransaction = new Transaction();\n    }\n    try\n    {\n      const a: A = f();\n      if (transWas === null)\n      {\n        Transaction.currentTransaction.close();\n        Transaction.currentTransaction = null;\n      }\n      return a;\n    }\n    catch (err)\n    {\n      if (transWas === null)\n      {\n        Transaction.currentTransaction.close();\n        Transaction.currentTransaction = null;\n      }\n      throw err;\n    }\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Transaction.ts","import { Set } from \"typescript-collections\";\n\nlet totalRegistrations : number = 0;\nexport function getTotalRegistrations() : number {\n    return totalRegistrations;\n}\n\nexport class Source {\n    constructor(\n        origin : Vertex,\n        register_ : () => () => void\n    ) {\n        if (origin === null)\n            throw new Error(\"null origin!\");\n        this.origin = origin;\n        this.register_ = register_;\n    }\n    origin : Vertex;\n    private register_ : () => () => void;\n    private registered : boolean = false;\n    private deregister_ : () => void = null;\n\n    register(target : Vertex) : void {\n        if (!this.registered) {\n            this.registered = true;\n            if (this.register_ !== null)\n                this.deregister_ = this.register_();\n            else {\n                this.origin.increment(target);\n                this.deregister_ = () => this.origin.decrement(target);\n            }\n        }\n    }\n    deregister(target : Vertex) : void {\n        if (this.registered) {\n            this.registered = false;\n            if (this.deregister_ !== null)\n                this.deregister_();\n        }\n    }\n}\n\nexport enum Color { black, gray, white, purple };\nlet roots : Vertex[] = [];\nlet nextID : number = 0;\nlet verbose : boolean = false;\n\nexport function setVerbose(v : boolean) : void { verbose = v; }\n\nexport function describeAll(v : Vertex, visited : Set<number>)\n{\n    if (visited.contains(v.id)) return;\n    console.log(v.descr());\n    visited.add(v.id);\n    let chs = v.children();\n    for (let i = 0; i < chs.length; i++)\n        describeAll(chs[i], visited);\n}\n\nexport class Vertex {\n    static NULL : Vertex = new Vertex(\"user\", 1e12, []);\n    id : number;\n\n\tconstructor(name : string, rank : number, sources : Source[]) {\n\t    this.name = name;\n\t\tthis.rank = rank;\n\t\tthis.sources = sources;\n\t\tthis.id = nextID++;\n\t}\n\tname : string;\n    rank : number;\n    sources : Source[];\n    targets : Vertex[] = [];\n    childrn : Vertex[] = [];\n    refCount() : number { return this.targets.length; };\n    visited : boolean = false;\n    register(target : Vertex) : boolean {\n        return this.increment(target);\n    }\n    deregister(target : Vertex) : void {\n        if (verbose)\n            console.log(\"deregister \"+this.descr()+\" => \"+target.descr());\n        this.decrement(target);\n        Vertex.collectCycles();\n    }\n    private incRefCount(target : Vertex) : boolean {\n        let anyChanged : boolean = false;\n        if (this.refCount() == 0) {\n            for (let i = 0; i < this.sources.length; i++)\n                this.sources[i].register(this);\n        }\n        this.targets.push(target);\n        target.childrn.push(this);\n        if (target.ensureBiggerThan(this.rank))\n            anyChanged = true;\n        totalRegistrations++;\n        return anyChanged;\n    }\n\n    private decRefCount(target : Vertex) : void {\n        if (verbose)\n            console.log(\"DEC \"+this.descr());\n        let matched = false;\n        for (let i = 0; i < target.childrn.length; i++)\n            if (target.childrn[i] === this) {\n                target.childrn.splice(i, 1);\n            }\n        for (let i = 0; i < this.targets.length; i++)\n            if (this.targets[i] === target) {\n                this.targets.splice(i, 1);\n                matched = true;\n                break;\n            }\n        if (matched) {\n            if (this.refCount() == 0) {\n                for (let i = 0; i < this.sources.length; i++)\n                    this.sources[i].deregister(this);\n            }\n            totalRegistrations--;\n        }\n    }\n\n    addSource(src : Source) : void {\n        this.sources.push(src);\n        if (this.refCount() > 0)\n            src.register(this);\n    }\n\n\tprivate ensureBiggerThan(limit : number) : boolean {\n\t\tif (this.rank > limit || this.visited)\n\t\t\treturn false;\n\n        this.visited = true;\n\t\tthis.rank = limit + 1;\n\t\tfor (let i = 0; i < this.targets.length; i++)\n\t\t\tthis.targets[i].ensureBiggerThan(this.rank);\n        this.visited = false;\n\t\treturn true;\n\t}\n\n\tdescr() : string {\n        let colStr : string = null;\n        switch (this.color) {\n        case Color.black: colStr = \"black\"; break;\n        case Color.gray:  colStr = \"gray\"; break;\n        case Color.white: colStr = \"white\"; break;\n        case Color.purple: colStr = \"purple\"; break;\n        }\n        let str = this.id+\" \"+this.name+\" [\"+this.refCount()+\"/\"+this.refCountAdj+\"] \"+colStr+\" ->\";\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            str = str + \" \" + chs[i].id;\n        }\n        return str;\n\t}\n\n\t// --------------------------------------------------------\n\t// Synchronous Cycle Collection algorithm presented in \"Concurrent\n\t// Cycle Collection in Reference Counted Systems\" by David F. Bacon\n\t// and V.T. Rajan.\n\n    color : Color = Color.black;\n    buffered : boolean = false;\n    refCountAdj : number = 0;\n\n\tchildren() : Vertex[] { return this.childrn; }\n\n\tincrement(referrer : Vertex) : boolean {\n\t    return this.incRefCount(referrer);\n\t}\n\n\tdecrement(referrer : Vertex) : void {\n\t    this.decRefCount(referrer);\n\t    if (this.refCount() == 0)\n\t        this.release();\n        else\n            this.possibleRoots();\n\t}\n\n    release() : void {\n        this.color = Color.black;\n        if (!this.buffered)\n            this.free();\n    }\n\n    free() : void {\n        while (this.targets.length > 0)\n            this.decRefCount(this.targets[0]);\n    }\n\n\tpossibleRoots() : void {\n\t    if (this.color != Color.purple) {\n\t        this.color = Color.purple;\n\t        if (!this.buffered) {\n                this.buffered = true;\n                roots.push(this);\n            }\n        }\n\t}\n\n\tstatic collectCycles() : void {\n\t    Vertex.markRoots();\n\t    Vertex.scanRoots();\n\t    Vertex.collectRoots();\n\t}\n\n\tstatic markRoots() : void {\n\t    const newRoots : Vertex[] = [];\n\t    for (let i = 0; i < roots.length; i++) {\n            if (verbose)\n                console.log(\"markRoots \"+roots[i].descr());  // ###\n\t        if (roots[i].color == Color.purple) {\n\t            roots[i].markGray();\n\t            newRoots.push(roots[i]);\n            }\n\t        else {\n\t            roots[i].buffered = false;\n\t            if (roots[i].color == Color.black && roots[i].refCount() == 0)\n\t                roots[i].free();\n            }\n\t    }\n\t    roots = newRoots;\n\t}\n\n\tstatic scanRoots() : void {\n\t    for (let i = 0; i < roots.length; i++)\n\t        roots[i].scan();\n\t}\n\n\tstatic collectRoots() : void {\n\t    for (let i = 0; i < roots.length; i++) {\n\t        roots[i].buffered = false;\n\t        roots[i].collectWhite();\n\t    }\n\t    roots = [];\n\t}\n\n\tmarkGray() : void {\n\t    if (this.color != Color.gray) {\n\t        this.color = Color.gray;\n\t        let chs = this.children();\n\t        for (let i = 0; i < chs.length; i++) {\n\t            chs[i].refCountAdj--;\n                if (verbose)\n                    console.log(\"markGray \"+this.descr());\n\t            chs[i].markGray();\n            }\n\t    }\n\t}\n\n\tscan() : void {\n\t    if (verbose)\n            console.log(\"scan \"+this.descr());\n\t    if (this.color == Color.gray) {\n\t        if (this.refCount()+this.refCountAdj > 0)\n\t            this.scanBlack();\n\t        else {\n\t            this.color = Color.white;\n                if (verbose)\n                    console.log(\"scan WHITE \"+this.descr());\n                let chs = this.children();\n                for (let i = 0; i < chs.length; i++)\n                    chs[i].scan();\n\t        }\n\t    }\n\t}\n\n\tscanBlack() : void {\n\t    this.color = Color.black;\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            chs[i].refCountAdj++;\n            if (verbose)\n                console.log(\"scanBlack \"+this.descr());\n            if (chs[i].color != Color.black)\n                chs[i].scanBlack();\n        }\n\t}\n\n\tcollectWhite() : void {\n\t    if (this.color == Color.white && !this.buffered) {\n            if (verbose)\n                console.log(\"collectWhite \"+this.descr());\n\t        this.color = Color.black;\n\t        this.refCountAdj = 0;\n            let chs = this.children();\n            for (let i = 0; i < chs.length; i++)\n                chs[i].collectWhite();\n            this.free();\n\t    }\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Vertex.ts","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { Cell } from \"./Cell\";\n//import { StreamLoop } from \"./StreamLoop\";\nimport { Listener } from \"./Listener\";\nimport { Tuple2 } from \"./Tuple2\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\n\nexport class Stream<A> {\n    constructor(vertex? : Vertex) {\n        this.vertex = vertex ? vertex : new Vertex(\"Stream\", 0, []);\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    protected vertex : Vertex;\n    protected listeners : Array<Listener<A>> = [];\n    protected firings : A[] = [];\n\n    /**\n     * Transform the stream's event values according to the supplied function, so the returned\n     * Stream's event values reflect the value of the function applied to the input\n     * Stream's event values.\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"map\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a));\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Transform the stream's event values into the specified constant value.\n     * @param b Constant value.\n     */\n    mapTo<B>(b : B) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"mapTo\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(b);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\n     * in the simultaneous case.\n     * <p>\n     * In the case where two events are simultaneous (i.e. both\n     * within the same transaction), the event from <em>this</em> will take precedence, and\n     * the event from <em>s</em> will be dropped.\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\n     * <p>\n     * The name orElse() is used instead of merge() to make it really clear that care should\n     * be taken, because events can be dropped.\n     */\n    orElse(s : Stream<A>) : Stream<A> {\n        return this.merge(s, (left : A, right: A) => {\n            return left;\n        });\n    }\n\n    private merge_(s : Stream<A>) : Stream<A> {\n        const out = new StreamWithSend<A>();\n        const left = new Vertex(\"merge\", 0, []);\n        left.sources.push(new Source(this.vertex, () => {\n            return this.listen_(left, (a : A) => {\n                    out.send_(a);\n                }, false);\n        }));\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    left,\n                    () => {\n                        left.register(out.vertex);\n                        return () => { left.deregister(out.vertex); }\n                    }\n                ),\n                new Source(\n                    s.vertex,\n                    () => {\n                        return s.listen_(out.vertex, (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                )\n            ]);\n        return out;\n    }\n\n    coalesce__(f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {  // TO DO figure out how to hide this\n        const out = new StreamWithSend<A>();\n        const coalescer = new CoalesceHandler<A>(f, out);\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            coalescer.send_(a);\n                        }, false);\n                    }\n                )\n            ]).concat(toSources(Lambda2_deps(f)));\n        return out;\n    }\n\n    /**\n     * Merge two streams of the same type into one, so that events on either input appear\n     * on the returned stream.\n     * <p>\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\n     * occurring in the same transaction), combine them into one using the specified combining function\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\n     * The event from <em>this</em> will appear at the left input of the combining function, and\n     * the event from <em>s</em> will appear at the right.\n     * @param f Function to combine the values. It may construct FRP logic or use\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    merge(s : Stream<A>, f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {\n        return Transaction.run<Stream<A>>(() => {\n            return this.merge_(s).coalesce__(f);\n        });\n    }\n\n    /**\n     * Return a stream that only outputs events for which the predicate returns true.\n     */\n    filter(f : ((a : A) => boolean) | Lambda1<A,boolean>) : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"filter\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (ff(a))\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events that have present\n     * values, discarding null values.\n     */\n    filterNotNull() : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        out.vertex = new Vertex(\"filterNotNull\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (a !== null)\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events from the input stream\n     * when the specified cell's value is true.\n     */\n    gate(c : Cell<boolean>) : Stream<A> {\n        return this.snapshot(c, (a : A, pred : boolean) => {\n            return pred ? a : null;\n        }).filterNotNull();\n    }\n\n\t/**\n\t * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\n\t * at the time of the event firing, ignoring the stream's value.\n\t */\n\tsnapshot1<B>(c : Cell<B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"snapshot1\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(c.sampleNoTrans__());\n                        }, false);\n                    }\n                ),\n                new Source(c.getVertex__(), null)\n            ]\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cell at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot<B,C>(b : Cell<B>, f_ : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Stream<C>\n\t{\n        const out = new StreamWithSend<C>(null);\n        const ff = Lambda2_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null)\n            ].concat(toSources(Lambda2_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot3<B,C,D>(b : Cell<B>, c : Cell<C>, f_ : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : Stream<D>\n\t{\n        const out = new StreamWithSend<D>(null);\n        const ff = Lambda3_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null)\n            ].concat(toSources(Lambda3_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\n\t    f_ : ((a : A, b : B, c : C, d : D) => E) | Lambda4<A,B,C,D,E>) : Stream<E>\n\t{\n        const out = new StreamWithSend<E>(null);\n        const ff = Lambda4_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null)\n            ].concat(toSources(Lambda4_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E) => F) | Lambda5<A,B,C,D,E,F>) : Stream<F>\n\t{\n        const out = new StreamWithSend<F>(null);\n        const ff = Lambda5_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__(), e.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null),\n                new Source(e.getVertex__(), null)\n            ].concat(toSources(Lambda5_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) | Lambda6<A,B,C,D,E,F,G>) : Stream<G>\n\t{\n        const out = new StreamWithSend<G>(null);\n        const ff = Lambda6_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__(), e.sampleNoTrans__(),\n                                            f.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null),\n                new Source(e.getVertex__(), null),\n                new Source(f.getVertex__(), null)\n            ].concat(toSources(Lambda6_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Create a {@link Cell} with the specified initial value, that is updated\n     * by this stream's event values.\n     * <p>\n     * There is an implicit delay: State updates caused by event firings don't become\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\n     * until the following transaction. To put this another way,\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\n     * any state changes from the current transaction.\n     */\n    hold(initValue : A) : Cell<A> {\n        return new Cell<A>(initValue, this);\n\t}\n\n\t/**\n\t * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\n\t */\n\tholdLazy(initValue : Lazy<A>) : Cell<A> {\n\t    return new LazyCell<A>(initValue, this);\n\t}\n\n    /**\n     * Transform an event with a generalized state loop (a Mealy machine). The function\n     * is passed the input and the old state and returns the new state and output value.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    collect<B,S>(initState : S, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        return this.collectLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    collectLazy<B,S>(initState : Lazy<S>, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        const ea = this;\n        return Transaction.run(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                ebs = ea.snapshot(s, f),\n                eb = ebs.map((bs : Tuple2<B,S>) => { return bs.a; }),\n                es_out = ebs.map((bs : Tuple2<B,S>) => { return bs.b; });\n            es.loop(es_out);\n            return eb;\n        });\n    }\n\n    /**\n     * Accumulate on input event, outputting the new state each time.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    accum<S>(initState : S, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        return this.accumLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    accumLazy<S>(initState : Lazy<S>, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        const ea = this;\n        return Transaction.run(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                es_out = ea.snapshot(s, f);\n            es.loop(es_out);\n            return es_out.holdLazy(initState);\n        });\n    }\n\n    /**\n     * Return a stream that outputs only one value: the next event of the\n     * input stream, starting from the transaction in which once() was invoked.\n     */\n    once() : Stream<A> {\n    /*\n        return Transaction.run(() => {\n            const ev = this,\n                out = new StreamWithSend<A>();\n            let la : () => void = null;\n            la = ev.listen_(out.vertex, (a : A) => {\n                if (la !== null) {\n                    out.send_(a);\n                    la();\n                    la = null;\n                }\n            }, false);\n            return out;\n        });\n        */\n        // We can't use the implementation above, beacuse deregistering\n        // listeners triggers the exception\n        // \"send() was invoked before listeners were registered\"\n        // We can revisit this another time. For now we will use the less\n        // efficient implementation below.\n        const me = this;\n        return Transaction.run(() => me.gate(me.mapTo(false).hold(true)));\n    }\n\n    listen(h : (a : A) => void) : () => void {\n        return Transaction.run<() => void>(() => {\n            return this.listen_(Vertex.NULL, h, false);\n        });\n    }\n\n    listen_(target : Vertex,\n            h : (a : A) => void,\n            suppressEarlierFirings : boolean) : () => void {\n        if (this.vertex.register(target))\n            Transaction.currentTransaction.requestRegen();\n        const listener = new Listener<A>(h, target);\n        this.listeners.push(listener);\n        if (!suppressEarlierFirings && this.firings.length != 0) {\n            const firings = this.firings.slice();\n            Transaction.currentTransaction.prioritized(target, () => {\n                // Anything sent already in this transaction must be sent now so that\n                // there's no order dependency between send and listen.\n                for (let i = 0; i < firings.length; i++)\n                    h(firings[i]);\n            });\n        }\n        return () => {\n            let removed = false;\n            for (let i = 0; i < this.listeners.length; i++) {\n                if (this.listeners[i] == listener) {\n                    this.listeners.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (removed)\n                this.vertex.deregister(target);\n        };\n    }\n\n\n    /**\n     * Fantasy-land Algebraic Data Type Compatability.\n     * Stream satisfies the Functor and Monoid Categories (and hence Semigroup)\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\n     */\n\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Stream<B> {\n      return this.map(f);\n    }\n\n    //concat :: Semigroup a => a ~> a -> a\n    'fantasy-land/concat'(a:Stream<A>) : Stream<A> {\n      return this.orElse(a);\n    }\n\n    //empty :: Monoid m => () -> m\n    'fantasy-land/empty'() : Stream<A> {\n      return new Stream<A>();\n    }\n}\n\nexport class StreamWithSend<A> extends Stream<A> {\n    constructor(vertex? : Vertex) {\n        super(vertex);\n    }\n\n    setVertex__(vertex : Vertex) {  // TO DO figure out how to hide this\n        this.vertex = vertex;\n    }\n\n    send_(a : A) : void {\n        // We throw this error if we send into FRP logic that has been constructed\n        // but nothing is listening to it yet. We need to do it this way because\n        // it's the only way to manage memory in a language with no finalizers.\n        if (this.vertex.refCount() == 0)\n            throw new Error(\"send() was invoked before listeners were registered\");\n\t\tif (this.firings.length == 0)\n\t\t\tTransaction.currentTransaction.last(() => {\n\t\t\t    this.firings = [];\n            });\n\t\tthis.firings.push(a);\n\t\tconst listeners = this.listeners.slice();\n        for (let i = 0; i < listeners.length; i++) {\n            const h = listeners[i].h;\n            Transaction.currentTransaction.prioritized(listeners[i].target, () => {\n                Transaction.currentTransaction.inCallback++;\n                try {\n                    h(a);\n                    Transaction.currentTransaction.inCallback--;\n                }\n                catch (err) {\n                    Transaction.currentTransaction.inCallback--;\n                    throw err;\n                }\n            });\n        }\n    }\n}\n\n/**\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\n */\nexport class StreamLoop<A> extends StreamWithSend<A> {\n    assigned__ : boolean = false;  // to do: Figure out how to hide this\n\n    constructor()\n    {\n        super();\n        this.vertex.name = \"StreamLoop\";\n    \tif (Transaction.currentTransaction === null)\n    \t    throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\n    }\n\n    /**\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(sa_out : Stream<A>) : void {\n        if (this.assigned__)\n            throw new Error(\"StreamLoop looped more than once\");\n        this.assigned__ = true;\n        this.vertex.addSource(\n            new Source(\n                sa_out.getVertex__(),\n                () => {\n                    return sa_out.listen_(this.vertex, (a : A) => {\n                        this.send_(a);\n                    }, false);\n                }\n            )\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Stream.ts","\"use strict\";\nvar util = require('./util');\n/**\n * Returns the position of the first occurrence of the specified item\n * within the specified array.4\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the first occurrence of the specified element\n * within the specified array, or -1 if not found.\n */\nfunction indexOf(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    for (var i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.indexOf = indexOf;\n/**\n * Returns the position of the last occurrence of the specified element\n * within the specified array.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the last occurrence of the specified element\n * within the specified array or -1 if not found.\n */\nfunction lastIndexOf(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    for (var i = length - 1; i >= 0; i--) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.lastIndexOf = lastIndexOf;\n/**\n * Returns true if the specified array contains the specified element.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the specified array contains the specified element.\n */\nfunction contains(array, item, equalsFunction) {\n    return indexOf(array, item, equalsFunction) >= 0;\n}\nexports.contains = contains;\n/**\n * Removes the first ocurrence of the specified element from the specified array.\n * @param {*} array the array in which to search element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the array changed after this call.\n */\nfunction remove(array, item, equalsFunction) {\n    var index = indexOf(array, item, equalsFunction);\n    if (index < 0) {\n        return false;\n    }\n    array.splice(index, 1);\n    return true;\n}\nexports.remove = remove;\n/**\n * Returns the number of elements in the specified array equal\n * to the specified object.\n * @param {Array} array the array in which to determine the frequency of the element.\n * @param {Object} item the element whose frequency is to be determined.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the number of elements in the specified array\n * equal to the specified object.\n */\nfunction frequency(array, item, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    var length = array.length;\n    var freq = 0;\n    for (var i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            freq++;\n        }\n    }\n    return freq;\n}\nexports.frequency = frequency;\n/**\n * Returns true if the two specified arrays are equal to one another.\n * Two arrays are considered equal if both arrays contain the same number\n * of elements, and all corresponding pairs of elements in the two\n * arrays are equal and are in the same order.\n * @param {Array} array1 one array to be tested for equality.\n * @param {Array} array2 the other array to be tested for equality.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between elemements in the arrays.\n * @return {boolean} true if the two arrays are equal\n */\nfunction equals(array1, array2, equalsFunction) {\n    var equals = equalsFunction || util.defaultEquals;\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    var length = array1.length;\n    for (var i = 0; i < length; i++) {\n        if (!equals(array1[i], array2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equals = equals;\n/**\n * Returns shallow a copy of the specified array.\n * @param {*} array the array to copy.\n * @return {Array} a copy of the specified array\n */\nfunction copy(array) {\n    return array.concat();\n}\nexports.copy = copy;\n/**\n * Swaps the elements at the specified positions in the specified array.\n * @param {Array} array The array in which to swap elements.\n * @param {number} i the index of one element to be swapped.\n * @param {number} j the index of the other element to be swapped.\n * @return {boolean} true if the array is defined and the indexes are valid.\n */\nfunction swap(array, i, j) {\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\n        return false;\n    }\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n    return true;\n}\nexports.swap = swap;\nfunction toString(array) {\n    return '[' + array.toString() + ']';\n}\nexports.toString = toString;\n/**\n * Executes the provided function once for each element present in this array\n * starting from index 0 to length - 1.\n * @param {Array} array The array in which to iterate.\n * @param {function(Object):*} callback function to execute, it is\n * invoked with one argument: the element value, to break the iteration you can\n * optionally return false.\n */\nfunction forEach(array, callback) {\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n        var ele = array_1[_i];\n        if (callback(ele) === false) {\n            return;\n        }\n    }\n}\nexports.forEach = forEach;\n//# sourceMappingURL=arrays.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/arrays.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nvar util = require('./util');\nvar Dictionary = (function () {\n    /**\n     * Creates an empty dictionary.\n     * @class <p>Dictionaries map keys to values; each key can map to at most one value.\n     * This implementation accepts any kind of objects as keys.</p>\n     *\n     * <p>If the keys are custom objects a function which converts keys to unique\n     * strings must be provided. Example:</p>\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function used\n     * to convert keys to strings. If the keys aren't strings or if toString()\n     * is not appropriate, a custom function which receives a key and returns a\n     * unique string must be provided.\n     */\n    function Dictionary(toStrFunction) {\n        this.table = {};\n        this.nElements = 0;\n        this.toStr = toStrFunction || util.defaultToString;\n    }\n    /**\n     * Returns the value to which this dictionary maps the specified key.\n     * Returns undefined if this dictionary contains no mapping for this key.\n     * @param {Object} key key whose associated value is to be returned.\n     * @return {*} the value to which this dictionary maps the specified key or\n     * undefined if the map contains no mapping for this key.\n     */\n    Dictionary.prototype.getValue = function (key) {\n        var pair = this.table['$' + this.toStr(key)];\n        if (util.isUndefined(pair)) {\n            return undefined;\n        }\n        return pair.value;\n    };\n    /**\n     * Associates the specified value with the specified key in this dictionary.\n     * If the dictionary previously contained a mapping for this key, the old\n     * value is replaced by the specified value.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value value to be associated with the specified key.\n     * @return {*} previous value associated with the specified key, or undefined if\n     * there was no mapping for the key or if the key/value are undefined.\n     */\n    Dictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return undefined;\n        }\n        var ret;\n        var k = '$' + this.toStr(key);\n        var previousElement = this.table[k];\n        if (util.isUndefined(previousElement)) {\n            this.nElements++;\n            ret = undefined;\n        }\n        else {\n            ret = previousElement.value;\n        }\n        this.table[k] = {\n            key: key,\n            value: value\n        };\n        return ret;\n    };\n    /**\n     * Removes the mapping for this key from this dictionary if it is present.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @return {*} previous value associated with specified key, or undefined if\n     * there was no mapping for key.\n     */\n    Dictionary.prototype.remove = function (key) {\n        var k = '$' + this.toStr(key);\n        var previousElement = this.table[k];\n        if (!util.isUndefined(previousElement)) {\n            delete this.table[k];\n            this.nElements--;\n            return previousElement.value;\n        }\n        return undefined;\n    };\n    /**\n     * Returns an array containing all of the keys in this dictionary.\n     * @return {Array} an array containing all of the keys in this dictionary.\n     */\n    Dictionary.prototype.keys = function () {\n        var array = [];\n        for (var name_1 in this.table) {\n            if (util.has(this.table, name_1)) {\n                var pair = this.table[name_1];\n                array.push(pair.key);\n            }\n        }\n        return array;\n    };\n    /**\n     * Returns an array containing all of the values in this dictionary.\n     * @return {Array} an array containing all of the values in this dictionary.\n     */\n    Dictionary.prototype.values = function () {\n        var array = [];\n        for (var name_2 in this.table) {\n            if (util.has(this.table, name_2)) {\n                var pair = this.table[name_2];\n                array.push(pair.value);\n            }\n        }\n        return array;\n    };\n    /**\n    * Executes the provided function once for each key-value pair\n    * present in this dictionary.\n    * @param {function(Object,Object):*} callback function to execute, it is\n    * invoked with two arguments: key and value. To break the iteration you can\n    * optionally return false.\n    */\n    Dictionary.prototype.forEach = function (callback) {\n        for (var name_3 in this.table) {\n            if (util.has(this.table, name_3)) {\n                var pair = this.table[name_3];\n                var ret = callback(pair.key, pair.value);\n                if (ret === false) {\n                    return;\n                }\n            }\n        }\n    };\n    /**\n     * Returns true if this dictionary contains a mapping for the specified key.\n     * @param {Object} key key whose presence in this dictionary is to be\n     * tested.\n     * @return {boolean} true if this dictionary contains a mapping for the\n     * specified key.\n     */\n    Dictionary.prototype.containsKey = function (key) {\n        return !util.isUndefined(this.getValue(key));\n    };\n    /**\n    * Removes all mappings from this dictionary.\n    * @this {collections.Dictionary}\n    */\n    Dictionary.prototype.clear = function () {\n        this.table = {};\n        this.nElements = 0;\n    };\n    /**\n     * Returns the number of keys in this dictionary.\n     * @return {number} the number of key-value mappings in this dictionary.\n     */\n    Dictionary.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this dictionary contains no mappings.\n     * @return {boolean} true if this dictionary contains no mappings.\n     */\n    Dictionary.prototype.isEmpty = function () {\n        return this.nElements <= 0;\n    };\n    Dictionary.prototype.toString = function () {\n        var toret = '{';\n        this.forEach(function (k, v) {\n            toret += \"\\n\\t\" + k + \" : \" + v;\n        });\n        return toret + '\\n}';\n    };\n    return Dictionary;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Dictionary; // End of dictionary\n//# sourceMappingURL=Dictionary.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Dictionary.js\n// module id = 5\n// module chunks = 0","import { Stream } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { Source } from \"./Vertex\";\n\nexport class Lambda1<A,B> {\n    constructor(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A) => B;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda1<A,B>(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda1<A,B>\n{\n    return new Lambda1(f, deps);\n}\n\nexport function Lambda1_deps<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda1)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda1_toFunction<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : (a : A) => B {\n    if (f instanceof Lambda1)\n        return f.f;\n    else\n        return <(a : A) => B>f;\n}\n\nexport class Lambda2<A,B,C> {\n    constructor(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B) => C;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda2<A,B,C>(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda2<A,B,C>\n{\n    return new Lambda2(f, deps);\n}\n\nexport function Lambda2_deps<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda2)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda2_toFunction<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : (a : A, b : B) => C {\n    if (f instanceof Lambda2)\n        return f.f;\n    else\n        return <(a : A, b : B) => C>f;\n}\n\nexport class Lambda3<A,B,C,D> {\n    constructor(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C) => D;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda3<A,B,C,D>(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda3<A,B,C,D>\n{\n    return new Lambda3(f, deps);\n}\n\nexport function Lambda3_deps<A,B,C,D>(f : ((a : A, b : B, c : C) => D)\n        | Lambda3<A,B,C,D>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda3)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda3_toFunction<A,B,C,D>(f : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : (a : A, b : B, c : C) => D {\n    if (f instanceof Lambda3)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C) => D>f;\n}\n\nexport class Lambda4<A,B,C,D,E> {\n    constructor(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D) => E;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda4<A,B,C,D,E>(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda4<A,B,C,D,E>\n{\n    return new Lambda4(f, deps);\n}\n\nexport function Lambda4_deps<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda4)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda4_toFunction<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : (a : A, b : B, c : C, d : D) => E {\n    if (f instanceof Lambda4)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D) => E>f;\n}\n\nexport class Lambda5<A,B,C,D,E,F> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E) => F;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda5<A,B,C,D,E,F>(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda5<A,B,C,D,E,F>\n{\n    return new Lambda5(f, deps);\n}\n\nexport function Lambda5_deps<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda5)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda5_toFunction<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : (a : A, b : B, c : C, d : D, e : E) => F {\n    if (f instanceof Lambda5)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E) => F>f;\n}\n\nexport class Lambda6<A,B,C,D,E,F,G> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E, f : F) => G;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda6<A,B,C,D,E,F,G>(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda6<A,B,C,D,E,F,G>\n{\n    return new Lambda6(f, deps);\n}\n\nexport function Lambda6_deps<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda6)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda6_toFunction<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : (a : A, b : B, c : C, d : D, e : E, f : F) => G {\n    if (f instanceof Lambda6)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E, f : F) => G>f;\n}\n\nexport function toSources(deps : Array<Stream<any>|Cell<any>>) : Source[] {\n    const ss : Source[] = [];\n    for (let i = 0; i < deps.length; i++) {\n        const dep = deps[i];\n        ss.push(new Source(dep.getVertex__(), null));\n    }\n    return ss;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Lambda.ts","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\nimport { Lazy } from \"./Lazy\";\nimport { Listener } from \"./Listener\";\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { Operational } from \"./Operational\";\n\nclass LazySample<A> {\n    constructor(cell : Cell<A>) {\n        this.cell = cell;\n    }\n    cell : Cell<A>;\n    hasValue : boolean = false;\n    value : A = null;\n}\n\nclass ApplyState<A,B> {\n    constructor() {}\n    f : (a : A) => B = null;\n    f_present : boolean = false;\n    a : A = null;\n    a_present : boolean = false;\n}\n\nexport class Cell<A> {\n\tprivate str : Stream<A>;\n\tprotected value : A;\n\tprotected valueUpdate : A;\n\tprivate cleanup : () => void;\n\tprotected lazyInitValue : Lazy<A>;  // Used by LazyCell\n\tprivate vertex : Vertex;\n\n    constructor(initValue : A, str? : Stream<A>) {\n        this.value = initValue;\n        if (!str) {\n            this.str = new Stream<A>();\n            this.vertex = new Vertex(\"ConstCell\", 0, []);\n        }\n        else\n            Transaction.run(() => this.setStream(str));\n    }\n\n    protected setStream(str : Stream<A>) {\n        this.str = str;\n        const me = this,\n              src = new Source(\n                str.getVertex__(),\n                () => {\n                    return str.listen_(me.vertex, (a : A) => {\n                        if (me.valueUpdate == null) {\n                            Transaction.currentTransaction.last(() => {\n                                me.value = me.valueUpdate;\n                                me.lazyInitValue = null;\n                                me.valueUpdate = null;\n                            });\n                        }\n                        me.valueUpdate = a;\n                    }, false);\n                }\n            );\n        this.vertex = new Vertex(\"Cell\", 0, [src]);\n        // We do a trick here of registering the source for the duration of the current\n        // transaction so that we are guaranteed to catch any stream events that\n        // occur in the same transaction.\n        this.vertex.register(Vertex.NULL);\n        Transaction.currentTransaction.last(() => {\n            this.vertex.deregister(Vertex.NULL);\n        });\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    getStream__() : Stream<A> {  // TO DO: Figure out how to hide this\n        return this.str;\n    }\n\n    /**\n     * Sample the cell's current value.\n     * <p>\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\n     * miss any updates, but in many circumstances it makes sense.\n     * <p>\n     * NOTE: In the Java and other versions of Sodium, using sample() inside map(), filter() and\n     * merge() is encouraged. In the Javascript/Typescript version, not so much, for the\n     * following reason: The memory management is different in the Javascript version, and this\n     * requires us to track all dependencies. In order for the use of sample() inside\n     * a closure to be correct, the cell that was sample()d inside the closure would have to be\n     * declared explicitly using the helpers lambda1(), lambda2(), etc. Because this is\n     * something that can be got wrong, we don't encourage this kind of use of sample() in\n     * Javascript. Better and simpler to use snapshot().\n     * <p>\n     * NOTE: If you need to sample() a cell, you have to make sure it's \"alive\" in terms of\n     * memory management or it will ignore updates. To make a cell work correctly\n     * with sample(), you have to ensure that it's being used. One way to guarantee this is\n     * to register a dummy listener on the cell. It will also work to have it referenced\n     * by something that is ultimately being listened to.\n     */\n    sample() : A {\n        return Transaction.run(() => { return this.sampleNoTrans__(); });\n    }\n\n    sampleNoTrans__() : A {  // TO DO figure out how to hide this\n        return this.value;\n    }\n\n    /**\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\n     */\n    sampleLazy() : Lazy<A> {\n        const me = this;\n        return Transaction.run(() => me.sampleLazyNoTrans__());\n    }\n\n    sampleLazyNoTrans__() : Lazy<A> {  // TO DO figure out how to hide this\n        const me = this,\n            s = new LazySample<A>(me);\n        Transaction.currentTransaction.last(() => {\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\n            s.hasValue = true;\n            s.cell = null;\n        });\n        return new Lazy<A>(() => {\n            if (s.hasValue)\n                return s.value;\n            else\n                return s.cell.sample();\n        });\n    }\n\n    /**\n     * Transform the cell's value according to the supplied function, so the returned Cell\n     * always reflects the value of the function applied to the input Cell's value.\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Cell<B> {\n        const c = this;\n        return Transaction.run(() =>\n            Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda1_toFunction(f)))\n        );\n    }\n\n\t/**\n\t * Lift a binary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift<B,C>(b : Cell<B>,\n\t          fn0 : ((a : A, b : B) => C) |\n\t                Lambda2<A,B,C>) : Cell<C> {\n        const fn = Lambda2_toFunction(fn0),\n            cf = this.map((aa : A) => (bb : B) => fn(aa, bb));\n        return Cell.apply(cf, b,\n            toSources(Lambda2_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a ternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift3<B,C,D>(b : Cell<B>, c : Cell<C>,\n\t             fn0 : ((a : A, b : B, c : C) => D) |\n\t                   Lambda3<A,B,C,D>) : Cell<D> {\n        const fn = Lambda3_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => D =\n                 (aa : A) => (bb : B) => (cc : C) => fn(aa, bb, cc),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply<B, (c : C) => D>(cf, b),\n                   c,\n                   toSources(Lambda3_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a quaternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\n\t               fn0 : ((a : A, b : B, c : C, d : D) => E) |\n\t                     Lambda4<A,B,C,D,E>) : Cell<E> {\n        const fn = Lambda4_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => E =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => fn(aa, bb, cc, dd),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply<B, (c : C) => (d : D) => E>(cf, b),\n                       c),\n                   d,\n                   toSources(Lambda4_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\n\t                 fn0 : ((a : A, b : B, c : C, d : D, e : E) => F) |\n\t                       Lambda5<A,B,C,D,E,F>) : Cell<F> {\n        const fn = Lambda5_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => F =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => fn(aa, bb, cc, dd, ee),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply<B, (c : C) => (d : D) => (e : E) => F>(cf, b),\n                           c),\n                       d),\n                   e,\n                   toSources(Lambda5_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\n\t                   fn0 : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) |\n\t                         Lambda6<A,B,C,D,E,F,G>) : Cell<G> {\n        const fn = Lambda6_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => G =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => fn(aa, bb, cc, dd, ee, ff),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply(\n                               Cell.apply<B, (c : C) => (d : D) => (e : E) => (f : F) => G>(cf, b),\n                               c),\n                           d),\n                       e),\n                   f,\n                   toSources(Lambda6_deps(fn0)));\n\t}\n\n\t/**\n\t * Apply a value inside a cell to a function inside a cell. This is the\n\t * primitive for all function lifting.\n\t */\n\tstatic apply<A,B>(cf : Cell<(a : A) => B>, ca : Cell<A>, sources? : Source[]) : Cell<B> {\n    \treturn Transaction.run(() => {\n    \t    const state = new ApplyState<A,B>(),\n                out = new StreamWithSend<B>(),\n                cf_value = Operational.value(cf),\n                ca_value = Operational.value(ca),\n                src1 = new Source(\n                        cf_value.getVertex__(),\n                        () => {\n                            return cf_value.listen_(out.getVertex__(), (f : (a : A) => B) => {\n                                state.f = f;\n                                state.f_present = true;\n                                if (state.a_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    ),\n                src2 = new Source(\n                        ca_value.getVertex__(),\n                        () => {\n                            return ca_value.listen_(out.getVertex__(), (a : A) => {\n                                state.a = a;\n                                state.a_present = true;\n                                if (state.f_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    );\n            out.setVertex__(new Vertex(\"apply\", 0,\n                [src1, src2].concat(sources ? sources : [])\n            ));\n            return out.coalesce__((l, r) => r).holdLazy(new Lazy<B>(() =>\n                    cf.sampleNoTrans__()(ca.sampleNoTrans__())\n                ));\n        });\n\t}\n\n\t/**\n\t * Unwrap a cell inside another cell to give a time-varying cell implementation.\n\t */\n    static switchC<A>(cca : Cell<Cell<A>>) : Cell<A> {\n\t    return Transaction.run(() => {\n            const za = cca.sampleLazy().map((ba : Cell<A>) => ba.sample()),\n                out = new StreamWithSend<A>();\n            let last_ca : Cell<A> = null;\n            const cca_value = Operational.value(cca),\n                  src = new Source(\n                        cca_value.getVertex__(),\n                        () => {\n                            let kill2 : () => void = last_ca === null ? null :\n                                    Operational.value(last_ca).listen_(out.getVertex__(),\n                                        (a : A) => out.send_(a), false);\n                            const kill1 = cca_value.listen_(out.getVertex__(), (ca : Cell<A>) => {\n                                // Note: If any switch takes place during a transaction, then the\n                                // coalesce__() below will always cause a sample to be fetched\n                                // from the one we just switched to. So anything from the old input cell\n                                // that might have happened during this transaction will be suppressed.\n                                last_ca = ca;\n                                if (kill2 !== null)\n                                    kill2();\n                                kill2 = Operational.value(ca).listen_(out.getVertex__(),\n                                    (a : A) => out.send_(a), false);\n                            }, false);\n                            return () => { kill1(); kill2(); };\n                        }\n                    );\n            out.setVertex__(new Vertex(\"switchC\", 0, [src]));\n            return out.coalesce__((l, r) => r).holdLazy(za);\n        });\n\t}\n\n\t/**\n\t * Unwrap a stream inside a cell to give a time-varying stream implementation.\n\t */\n\tstatic switchS<A>(csa : Cell<Stream<A>>) : Stream<A> {\n\t    return Transaction.run(() => {\n            const out = new StreamWithSend<A>(),\n                  h2 = (a : A) => {\n                          out.send_(a);\n                      },\n                  src = new Source(\n                      csa.getVertex__(),\n                      () => {\n                          let kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\n                          const kill1 = csa.getStream__().listen_(out.getVertex__(), (sa : Stream<A>) => {\n                              kill2();\n                              kill2 = sa.listen_(out.getVertex__(), h2, true);\n                          }, false);\n                          return () => { kill1(); kill2(); };\n                      }\n                  );\n\t        out.setVertex__(new Vertex(\"switchS\", 0, [src]));\n\t        return out;\n\t    });\n    }\n\n\t/**\n\t * Listen for updates to the value of this cell. This is the observer pattern. The\n\t * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\n\t * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\n\t * the world of I/O and for FRP.\n\t * @param h The handler to execute when there's a new value.\n\t *   You should make no assumptions about what thread you are called on, and the\n\t *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\n\t *   or {@link StreamSink#send(Object)} in the handler.\n\t *   An exception will be thrown, because you are not meant to use this to create\n\t *   your own primitives.\n     */\n    listen(h : (a : A) => void) : () => void {\n        return Transaction.run(() => {\n            return Operational.value(this).listen(h);\n        });\n    }\n\n    /**\n     * Fantasy-land Algebraic Data Type Compatability.\n     * Cell satisfies the Monad and Comonad Categories (and hence Functor, Apply, Applicative, and Extend as well)\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\n     */\n\n    //of :: Applicative f => a -> f a\n    static 'fantasy-land/of'<A>(a:A):Cell<A> {\n      return new Cell<A>(a);\n    }\n\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Cell<B> {\n      return this.map(f);\n    }\n\n    //ap :: Apply f => f a ~> f (a -> b) -> f b\n    'fantasy-land/ap'<B>(cf: Cell<(a : A) => B>):Cell<B> {\n        return Cell.apply(cf, this);\n    }\n\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    'fantasy-land/chain'<B>(f: ((a:A) => Cell<B>)):Cell<B> {\n      return Cell.switchC(this.map(f));\n    }\n\n    //extend :: Extend w => w a ~> (w a -> b) -> w b\n    'fantasy-land/extend'<B>(f: ((a:Cell<A>) => B)):Cell<B> {\n      return new Cell<B>(f(this));\n    }\n\n    //extract :: Comonad w => w a ~> () -> a\n    'fantasy-land/extract'():A {\n      return this.sample();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Cell.ts","\"use strict\";\nvar util = require('./util');\nvar arrays = require('./arrays');\nvar LinkedList = (function () {\n    /**\n    * Creates an empty Linked List.\n    * @class A linked list is a data structure consisting of a group of nodes\n    * which together represent a sequence.\n    * @constructor\n    */\n    function LinkedList() {\n        /**\n        * First node in the list\n        * @type {Object}\n        * @private\n        */\n        this.firstNode = null;\n        /**\n        * Last node in the list\n        * @type {Object}\n        * @private\n        */\n        this.lastNode = null;\n        /**\n        * Number of elements in the list\n        * @type {number}\n        * @private\n        */\n        this.nElements = 0;\n    }\n    /**\n    * Adds an element to this list.\n    * @param {Object} item element to be added.\n    * @param {number=} index optional index to add the element. If no index is specified\n    * the element is added to the end of this list.\n    * @return {boolean} true if the element was added or false if the index is invalid\n    * or if the element is undefined.\n    */\n    LinkedList.prototype.add = function (item, index) {\n        if (util.isUndefined(index)) {\n            index = this.nElements;\n        }\n        if (index < 0 || index > this.nElements || util.isUndefined(item)) {\n            return false;\n        }\n        var newNode = this.createNode(item);\n        if (this.nElements === 0) {\n            // First node in the list.\n            this.firstNode = newNode;\n            this.lastNode = newNode;\n        }\n        else if (index === this.nElements) {\n            // Insert at the end.\n            this.lastNode.next = newNode;\n            this.lastNode = newNode;\n        }\n        else if (index === 0) {\n            // Change first node.\n            newNode.next = this.firstNode;\n            this.firstNode = newNode;\n        }\n        else {\n            var prev = this.nodeAtIndex(index - 1);\n            newNode.next = prev.next;\n            prev.next = newNode;\n        }\n        this.nElements++;\n        return true;\n    };\n    /**\n    * Returns the first element in this list.\n    * @return {*} the first element of the list or undefined if the list is\n    * empty.\n    */\n    LinkedList.prototype.first = function () {\n        if (this.firstNode !== null) {\n            return this.firstNode.element;\n        }\n        return undefined;\n    };\n    /**\n    * Returns the last element in this list.\n    * @return {*} the last element in the list or undefined if the list is\n    * empty.\n    */\n    LinkedList.prototype.last = function () {\n        if (this.lastNode !== null) {\n            return this.lastNode.element;\n        }\n        return undefined;\n    };\n    /**\n     * Returns the element at the specified position in this list.\n     * @param {number} index desired index.\n     * @return {*} the element at the given index or undefined if the index is\n     * out of bounds.\n     */\n    LinkedList.prototype.elementAtIndex = function (index) {\n        var node = this.nodeAtIndex(index);\n        if (node === null) {\n            return undefined;\n        }\n        return node.element;\n    };\n    /**\n     * Returns the index in this list of the first occurrence of the\n     * specified element, or -1 if the List does not contain this element.\n     * <p>If the elements inside this list are\n     * not comparable with the === operator a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName = function(pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} item element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction Optional\n     * function used to check if two elements are equal.\n     * @return {number} the index in this list of the first occurrence\n     * of the specified element, or -1 if this list does not contain the\n     * element.\n     */\n    LinkedList.prototype.indexOf = function (item, equalsFunction) {\n        var equalsF = equalsFunction || util.defaultEquals;\n        if (util.isUndefined(item)) {\n            return -1;\n        }\n        var currentNode = this.firstNode;\n        var index = 0;\n        while (currentNode !== null) {\n            if (equalsF(currentNode.element, item)) {\n                return index;\n            }\n            index++;\n            currentNode = currentNode.next;\n        }\n        return -1;\n    };\n    /**\n       * Returns true if this list contains the specified element.\n       * <p>If the elements inside the list are\n       * not comparable with the === operator a custom equals function should be\n       * provided to perform searches, the function must receive two arguments and\n       * return true if they are equal, false otherwise. Example:</p>\n       *\n       * <pre>\n       * const petsAreEqualByName = function(pet1, pet2) {\n       *  return pet1.name === pet2.name;\n       * }\n       * </pre>\n       * @param {Object} item element to search for.\n       * @param {function(Object,Object):boolean=} equalsFunction Optional\n       * function used to check if two elements are equal.\n       * @return {boolean} true if this list contains the specified element, false\n       * otherwise.\n       */\n    LinkedList.prototype.contains = function (item, equalsFunction) {\n        return (this.indexOf(item, equalsFunction) >= 0);\n    };\n    /**\n     * Removes the first occurrence of the specified element in this list.\n     * <p>If the elements inside the list are\n     * not comparable with the === operator a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName = function(pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} item element to be removed from this list, if present.\n     * @return {boolean} true if the list contained the specified element.\n     */\n    LinkedList.prototype.remove = function (item, equalsFunction) {\n        var equalsF = equalsFunction || util.defaultEquals;\n        if (this.nElements < 1 || util.isUndefined(item)) {\n            return false;\n        }\n        var previous = null;\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            if (equalsF(currentNode.element, item)) {\n                if (currentNode === this.firstNode) {\n                    this.firstNode = this.firstNode.next;\n                    if (currentNode === this.lastNode) {\n                        this.lastNode = null;\n                    }\n                }\n                else if (currentNode === this.lastNode) {\n                    this.lastNode = previous;\n                    previous.next = currentNode.next;\n                    currentNode.next = null;\n                }\n                else {\n                    previous.next = currentNode.next;\n                    currentNode.next = null;\n                }\n                this.nElements--;\n                return true;\n            }\n            previous = currentNode;\n            currentNode = currentNode.next;\n        }\n        return false;\n    };\n    /**\n     * Removes all of the elements from this list.\n     */\n    LinkedList.prototype.clear = function () {\n        this.firstNode = null;\n        this.lastNode = null;\n        this.nElements = 0;\n    };\n    /**\n     * Returns true if this list is equal to the given list.\n     * Two lists are equal if they have the same elements in the same order.\n     * @param {LinkedList} other the other list.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function used to check if two elements are equal. If the elements in the lists\n     * are custom objects you should provide a function, otherwise\n     * the === operator is used to check equality between elements.\n     * @return {boolean} true if this list is equal to the given list.\n     */\n    LinkedList.prototype.equals = function (other, equalsFunction) {\n        var eqF = equalsFunction || util.defaultEquals;\n        if (!(other instanceof LinkedList)) {\n            return false;\n        }\n        if (this.size() !== other.size()) {\n            return false;\n        }\n        return this.equalsAux(this.firstNode, other.firstNode, eqF);\n    };\n    /**\n    * @private\n    */\n    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {\n        while (n1 !== null) {\n            if (!eqF(n1.element, n2.element)) {\n                return false;\n            }\n            n1 = n1.next;\n            n2 = n2.next;\n        }\n        return true;\n    };\n    /**\n     * Removes the element at the specified position in this list.\n     * @param {number} index given index.\n     * @return {*} removed element or undefined if the index is out of bounds.\n     */\n    LinkedList.prototype.removeElementAtIndex = function (index) {\n        if (index < 0 || index >= this.nElements) {\n            return undefined;\n        }\n        var element;\n        if (this.nElements === 1) {\n            //First node in the list.\n            element = this.firstNode.element;\n            this.firstNode = null;\n            this.lastNode = null;\n        }\n        else {\n            var previous = this.nodeAtIndex(index - 1);\n            if (previous === null) {\n                element = this.firstNode.element;\n                this.firstNode = this.firstNode.next;\n            }\n            else if (previous.next === this.lastNode) {\n                element = this.lastNode.element;\n                this.lastNode = previous;\n            }\n            if (previous !== null) {\n                element = previous.next.element;\n                previous.next = previous.next.next;\n            }\n        }\n        this.nElements--;\n        return element;\n    };\n    /**\n     * Executes the provided function once for each element present in this list in order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    LinkedList.prototype.forEach = function (callback) {\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            if (callback(currentNode.element) === false) {\n                break;\n            }\n            currentNode = currentNode.next;\n        }\n    };\n    /**\n     * Reverses the order of the elements in this linked list (makes the last\n     * element first, and the first element last).\n     */\n    LinkedList.prototype.reverse = function () {\n        var previous = null;\n        var current = this.firstNode;\n        var temp = null;\n        while (current !== null) {\n            temp = current.next;\n            current.next = previous;\n            previous = current;\n            current = temp;\n        }\n        temp = this.firstNode;\n        this.firstNode = this.lastNode;\n        this.lastNode = temp;\n    };\n    /**\n     * Returns an array containing all of the elements in this list in proper\n     * sequence.\n     * @return {Array.<*>} an array containing all of the elements in this list,\n     * in proper sequence.\n     */\n    LinkedList.prototype.toArray = function () {\n        var array = [];\n        var currentNode = this.firstNode;\n        while (currentNode !== null) {\n            array.push(currentNode.element);\n            currentNode = currentNode.next;\n        }\n        return array;\n    };\n    /**\n     * Returns the number of elements in this list.\n     * @return {number} the number of elements in this list.\n     */\n    LinkedList.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this list contains no elements.\n     * @return {boolean} true if this list contains no elements.\n     */\n    LinkedList.prototype.isEmpty = function () {\n        return this.nElements <= 0;\n    };\n    LinkedList.prototype.toString = function () {\n        return arrays.toString(this.toArray());\n    };\n    /**\n     * @private\n     */\n    LinkedList.prototype.nodeAtIndex = function (index) {\n        if (index < 0 || index >= this.nElements) {\n            return null;\n        }\n        if (index === (this.nElements - 1)) {\n            return this.lastNode;\n        }\n        var node = this.firstNode;\n        for (var i = 0; i < index; i++) {\n            node = node.next;\n        }\n        return node;\n    };\n    /**\n     * @private\n     */\n    LinkedList.prototype.createNode = function (item) {\n        return {\n            element: item,\n            next: null\n        };\n    };\n    return LinkedList;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedList; // End of linked list\n//# sourceMappingURL=LinkedList.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/LinkedList.js\n// module id = 8\n// module chunks = 0","import { Vertex, Source } from \"./Vertex\";\nimport { BSTree } from 'typescript-collections';\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { StreamSink } from \"./StreamSink\";\nimport { Cell } from \"./Cell\";\nimport { CellSink } from \"./CellSink\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * An interface for implementations of FRP timer systems.\n */\nexport abstract class TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    abstract setTimer(t : number, callback : () => void) : () => void;\n\n    /**\n     * Return the current clock time.\n     */\n    abstract now() : number;\n}\n\nlet nextSeq : number = 0;\n\nclass Event {\n    constructor(t : number, sAlarm : StreamWithSend<number>) {\n        this.t = t;\n        this.sAlarm = sAlarm;\n        this.seq = ++nextSeq;\n    }\n    t : number;\n    sAlarm : StreamWithSend<number>;\n    seq : number;  // Used to guarantee uniqueness\n}\n\nexport class TimerSystem {\n    constructor(impl : TimerSystemImpl) {\n        Transaction.run(() => {\n            this.impl = impl;\n            this.tMinimum = 0;\n            const timeSnk = new CellSink<number>(impl.now());\n            this.time = timeSnk;\n            // A dummy listener to time to keep it alive even when there are no other listeners.\n            this.time.listen((t : number) => { });\n            Transaction.onStart(() => {\n                // Ensure the time is always increasing from the FRP's point of view.\n                const t = this.tMinimum = Math.max(this.tMinimum, impl.now());\n                // Pop and execute all events earlier than or equal to t (the current time).\n                while (true) {\n                    let ev : Event = null;\n                    if (!this.eventQueue.isEmpty()) {\n                        let mev = this.eventQueue.minimum();\n                        if (mev.t <= t) {\n                            ev = mev;\n                            // TO DO: Detect infinite loops!\n                        }\n                    }\n                    if (ev != null) {\n                        timeSnk.send(ev.t);\n                        Transaction.run(() => ev.sAlarm.send_(ev.t));\n                    }\n                    else\n                        break;\n                }\n                timeSnk.send(t);\n            });\n        });\n    }\n\n    private impl : TimerSystemImpl;\n    private tMinimum : number;  // A guard to allow us to guarantee that the time as\n                                // seen by the FRP is always increasing.\n\n    /**\n     * A cell giving the current clock time.\n     */\n    time : Cell<number>;\n\n    private eventQueue : BSTree<Event> = new BSTree<Event>((a, b) => {\n        if (a.t < b.t) return -1;\n        if (a.t > b.t) return 1;\n        if (a.seq < b.seq) return -1;\n        if (a.seq > b.seq) return 1;\n        return 0;\n    });\n\n    /**\n     * A timer that fires at the specified time, which can be null, meaning\n     * that the alarm is not set.\n     */\n    at(tAlarm : Cell<number>) : Stream<number> {\n        let current : Event = null,\n            cancelCurrent : () => void = null,\n            active : boolean = false,\n            tAl : number = null,\n            sampled : boolean = false;\n        const sAlarm = new StreamWithSend<number>(null),\n            updateTimer = () => {\n                if (cancelCurrent !== null) {\n                    cancelCurrent();\n                    this.eventQueue.remove(current);\n                }\n                cancelCurrent = null;\n                current = null;\n                if (active) {\n                    if (!sampled) {\n                        sampled = true;\n                        tAl = tAlarm.sampleNoTrans__();\n                    }\n                    if (tAl !== null) {\n                        current = new Event(tAl, sAlarm);\n                        this.eventQueue.add(current);\n                        cancelCurrent = this.impl.setTimer(tAl, () => {\n                                    // Correction to ensure the clock time appears to be >= the\n                                    // alarm time. It can be a few milliseconds early, and\n                                    // this breaks things otherwise, because it doesn't think\n                                    // it's time to fire the alarm yet.\n                                    this.tMinimum = Math.max(this.tMinimum, tAl);\n                                    // Open and close a transaction to trigger queued\n                                    // events to run.\n                                    Transaction.run(() => {});\n                                });\n                    }\n                }\n            };\n        sAlarm.setVertex__(new Vertex(\"at\", 0, [\n                new Source(\n                    tAlarm.getVertex__(),\n                    () => {\n                        active = true;\n                        sampled = false;\n                        Transaction.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\n                        const kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), (oAlarm : number) => {\n                            tAl = oAlarm;\n                            sampled = true;\n                            updateTimer();\n                        }, false);\n                        return () => {\n                            active = false;\n                            updateTimer();\n                            kill();\n                        };\n                    }\n                )\n            ]\n        ));\n        return sAlarm;\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/TimerSystem.ts","\"use strict\";\n// Copyright 2013 Basarat Ali Syed. All Rights Reserved.\n//\n// Licensed under MIT open source license http://opensource.org/licenses/MIT\n//\n// Orginal javascript code was by Mauricio Santos\n//\nvar _arrays = require('./arrays');\nexports.arrays = _arrays;\nvar Bag_1 = require('./Bag');\nexports.Bag = Bag_1.default;\nvar BSTree_1 = require('./BSTree');\nexports.BSTree = BSTree_1.default;\nvar Dictionary_1 = require('./Dictionary');\nexports.Dictionary = Dictionary_1.default;\nvar Heap_1 = require('./Heap');\nexports.Heap = Heap_1.default;\nvar LinkedDictionary_1 = require('./LinkedDictionary');\nexports.LinkedDictionary = LinkedDictionary_1.default;\nvar LinkedList_1 = require('./LinkedList');\nexports.LinkedList = LinkedList_1.default;\nvar MultiDictionary_1 = require('./MultiDictionary');\nexports.MultiDictionary = MultiDictionary_1.default;\nvar Queue_1 = require('./Queue');\nexports.Queue = Queue_1.default;\nvar PriorityQueue_1 = require('./PriorityQueue');\nexports.PriorityQueue = PriorityQueue_1.default;\nvar Set_1 = require('./Set');\nexports.Set = Set_1.default;\nvar Stack_1 = require('./Stack');\nexports.Stack = Stack_1.default;\nvar _util = require('./util');\nexports.util = _util;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/index.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nvar util = require('./util');\nvar arrays = require('./arrays');\nvar Dictionary_1 = require('./Dictionary');\nvar Set = (function () {\n    /**\n     * Creates an empty set.\n     * @class <p>A set is a data structure that contains no duplicate items.</p>\n     * <p>If the inserted elements are custom objects a function\n     * which converts elements to strings must be provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object):string=} toStringFunction optional function used\n     * to convert elements to strings. If the elements aren't strings or if toString()\n     * is not appropriate, a custom function which receives a onject and returns a\n     * unique string must be provided.\n     */\n    function Set(toStringFunction) {\n        this.dictionary = new Dictionary_1.default(toStringFunction);\n    }\n    /**\n     * Returns true if this set contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this set contains the specified element,\n     * false otherwise.\n     */\n    Set.prototype.contains = function (element) {\n        return this.dictionary.containsKey(element);\n    };\n    /**\n     * Adds the specified element to this set if it is not already present.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if this set did not already contain the specified element.\n     */\n    Set.prototype.add = function (element) {\n        if (this.contains(element) || util.isUndefined(element)) {\n            return false;\n        }\n        else {\n            this.dictionary.setValue(element, element);\n            return true;\n        }\n    };\n    /**\n     * Performs an intersecion between this an another set.\n     * Removes all values that are not present this set and the given set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.intersection = function (otherSet) {\n        var set = this;\n        this.forEach(function (element) {\n            if (!otherSet.contains(element)) {\n                set.remove(element);\n            }\n            return true;\n        });\n    };\n    /**\n     * Performs a union between this an another set.\n     * Adds all values from the given set to this set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.union = function (otherSet) {\n        var set = this;\n        otherSet.forEach(function (element) {\n            set.add(element);\n            return true;\n        });\n    };\n    /**\n     * Performs a difference between this an another set.\n     * Removes from this set all the values that are present in the given set.\n     * @param {collections.Set} otherSet other set.\n     */\n    Set.prototype.difference = function (otherSet) {\n        var set = this;\n        otherSet.forEach(function (element) {\n            set.remove(element);\n            return true;\n        });\n    };\n    /**\n     * Checks whether the given set contains all the elements in this set.\n     * @param {collections.Set} otherSet other set.\n     * @return {boolean} true if this set is a subset of the given set.\n     */\n    Set.prototype.isSubsetOf = function (otherSet) {\n        if (this.size() > otherSet.size()) {\n            return false;\n        }\n        var isSub = true;\n        this.forEach(function (element) {\n            if (!otherSet.contains(element)) {\n                isSub = false;\n                return false;\n            }\n            return true;\n        });\n        return isSub;\n    };\n    /**\n     * Removes the specified element from this set if it is present.\n     * @return {boolean} true if this set contained the specified element.\n     */\n    Set.prototype.remove = function (element) {\n        if (!this.contains(element)) {\n            return false;\n        }\n        else {\n            this.dictionary.remove(element);\n            return true;\n        }\n    };\n    /**\n     * Executes the provided function once for each element\n     * present in this set.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one arguments: the element. To break the iteration you can\n     * optionally return false.\n     */\n    Set.prototype.forEach = function (callback) {\n        this.dictionary.forEach(function (k, v) {\n            return callback(v);\n        });\n    };\n    /**\n     * Returns an array containing all of the elements in this set in arbitrary order.\n     * @return {Array} an array containing all of the elements in this set.\n     */\n    Set.prototype.toArray = function () {\n        return this.dictionary.values();\n    };\n    /**\n     * Returns true if this set contains no elements.\n     * @return {boolean} true if this set contains no elements.\n     */\n    Set.prototype.isEmpty = function () {\n        return this.dictionary.isEmpty();\n    };\n    /**\n     * Returns the number of elements in this set.\n     * @return {number} the number of elements in this set.\n     */\n    Set.prototype.size = function () {\n        return this.dictionary.size();\n    };\n    /**\n     * Removes all of the elements from this set.\n     */\n    Set.prototype.clear = function () {\n        this.dictionary.clear();\n    };\n    /*\n    * Provides a string representation for display\n    */\n    Set.prototype.toString = function () {\n        return arrays.toString(this.toArray());\n    };\n    return Set;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Set; // end of Set\n//# sourceMappingURL=Set.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Set.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nvar LinkedList_1 = require('./LinkedList');\nvar Queue = (function () {\n    /**\n     * Creates an empty queue.\n     * @class A queue is a First-In-First-Out (FIFO) data structure, the first\n     * element added to the queue will be the first one to be removed. This\n     * implementation uses a linked list as a container.\n     * @constructor\n     */\n    function Queue() {\n        this.list = new LinkedList_1.default();\n    }\n    /**\n     * Inserts the specified element into the end of this queue.\n     * @param {Object} elem the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    Queue.prototype.enqueue = function (elem) {\n        return this.list.add(elem);\n    };\n    /**\n     * Inserts the specified element into the end of this queue.\n     * @param {Object} elem the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    Queue.prototype.add = function (elem) {\n        return this.list.add(elem);\n    };\n    /**\n     * Retrieves and removes the head of this queue.\n     * @return {*} the head of this queue, or undefined if this queue is empty.\n     */\n    Queue.prototype.dequeue = function () {\n        if (this.list.size() !== 0) {\n            var el = this.list.first();\n            this.list.removeElementAtIndex(0);\n            return el;\n        }\n        return undefined;\n    };\n    /**\n     * Retrieves, but does not remove, the head of this queue.\n     * @return {*} the head of this queue, or undefined if this queue is empty.\n     */\n    Queue.prototype.peek = function () {\n        if (this.list.size() !== 0) {\n            return this.list.first();\n        }\n        return undefined;\n    };\n    /**\n     * Returns the number of elements in this queue.\n     * @return {number} the number of elements in this queue.\n     */\n    Queue.prototype.size = function () {\n        return this.list.size();\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * <p>If the elements inside this stack are\n     * not comparable with the === operator, a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName (pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} elem element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function to check if two elements are equal.\n     * @return {boolean} true if this queue contains the specified element,\n     * false otherwise.\n     */\n    Queue.prototype.contains = function (elem, equalsFunction) {\n        return this.list.contains(elem, equalsFunction);\n    };\n    /**\n     * Checks if this queue is empty.\n     * @return {boolean} true if and only if this queue contains no items; false\n     * otherwise.\n     */\n    Queue.prototype.isEmpty = function () {\n        return this.list.size() <= 0;\n    };\n    /**\n     * Removes all of the elements from this queue.\n     */\n    Queue.prototype.clear = function () {\n        this.list.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this queue in\n     * FIFO order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Queue.prototype.forEach = function (callback) {\n        this.list.forEach(callback);\n    };\n    return Queue;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Queue; // End of queue\n//# sourceMappingURL=Queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Queue.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar collections = require('./util');\nvar arrays = require('./arrays');\nvar Heap = (function () {\n    /**\n     * Creates an empty Heap.\n     * @class\n     * <p>A heap is a binary tree, where the nodes maintain the heap property:\n     * each node is smaller than each of its children and therefore a MinHeap\n     * This implementation uses an array to store elements.</p>\n     * <p>If the inserted elements are custom objects a compare function must be provided,\n     *  at construction time, otherwise the <=, === and >= operators are\n     * used to compare elements. Example:</p>\n     *\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     *\n     * <p>If a Max-Heap is wanted (greater elements on top) you can a provide a\n     * reverse compare function to accomplish that behavior. Example:</p>\n     *\n     * <pre>\n     * function reverseCompare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return 1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return -1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two elements. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function Heap(compareFunction) {\n        /**\n         * Array used to store the elements od the heap.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.data = [];\n        this.compare = compareFunction || collections.defaultCompare;\n    }\n    /**\n     * Returns the index of the left child of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the left child\n     * for.\n     * @return {number} The index of the left child.\n     * @private\n     */\n    Heap.prototype.leftChildIndex = function (nodeIndex) {\n        return (2 * nodeIndex) + 1;\n    };\n    /**\n     * Returns the index of the right child of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the right child\n     * for.\n     * @return {number} The index of the right child.\n     * @private\n     */\n    Heap.prototype.rightChildIndex = function (nodeIndex) {\n        return (2 * nodeIndex) + 2;\n    };\n    /**\n     * Returns the index of the parent of the node at the given index.\n     * @param {number} nodeIndex The index of the node to get the parent for.\n     * @return {number} The index of the parent.\n     * @private\n     */\n    Heap.prototype.parentIndex = function (nodeIndex) {\n        return Math.floor((nodeIndex - 1) / 2);\n    };\n    /**\n     * Returns the index of the smaller child node (if it exists).\n     * @param {number} leftChild left child index.\n     * @param {number} rightChild right child index.\n     * @return {number} the index with the minimum value or -1 if it doesn't\n     * exists.\n     * @private\n     */\n    Heap.prototype.minIndex = function (leftChild, rightChild) {\n        if (rightChild >= this.data.length) {\n            if (leftChild >= this.data.length) {\n                return -1;\n            }\n            else {\n                return leftChild;\n            }\n        }\n        else {\n            if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {\n                return leftChild;\n            }\n            else {\n                return rightChild;\n            }\n        }\n    };\n    /**\n     * Moves the node at the given index up to its proper place in the heap.\n     * @param {number} index The index of the node to move up.\n     * @private\n     */\n    Heap.prototype.siftUp = function (index) {\n        var parent = this.parentIndex(index);\n        while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {\n            arrays.swap(this.data, parent, index);\n            index = parent;\n            parent = this.parentIndex(index);\n        }\n    };\n    /**\n     * Moves the node at the given index down to its proper place in the heap.\n     * @param {number} nodeIndex The index of the node to move down.\n     * @private\n     */\n    Heap.prototype.siftDown = function (nodeIndex) {\n        //smaller child index\n        var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\n        while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {\n            arrays.swap(this.data, min, nodeIndex);\n            nodeIndex = min;\n            min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\n        }\n    };\n    /**\n     * Retrieves but does not remove the root element of this heap.\n     * @return {*} The value at the root of the heap. Returns undefined if the\n     * heap is empty.\n     */\n    Heap.prototype.peek = function () {\n        if (this.data.length > 0) {\n            return this.data[0];\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Adds the given element into the heap.\n     * @param {*} element the element.\n     * @return true if the element was added or fals if it is undefined.\n     */\n    Heap.prototype.add = function (element) {\n        if (collections.isUndefined(element)) {\n            return undefined;\n        }\n        this.data.push(element);\n        this.siftUp(this.data.length - 1);\n        return true;\n    };\n    /**\n     * Retrieves and removes the root element of this heap.\n     * @return {*} The value removed from the root of the heap. Returns\n     * undefined if the heap is empty.\n     */\n    Heap.prototype.removeRoot = function () {\n        if (this.data.length > 0) {\n            var obj = this.data[0];\n            this.data[0] = this.data[this.data.length - 1];\n            this.data.splice(this.data.length - 1, 1);\n            if (this.data.length > 0) {\n                this.siftDown(0);\n            }\n            return obj;\n        }\n        return undefined;\n    };\n    /**\n     * Returns true if this heap contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this Heap contains the specified element, false\n     * otherwise.\n     */\n    Heap.prototype.contains = function (element) {\n        var equF = collections.compareToEquals(this.compare);\n        return arrays.contains(this.data, element, equF);\n    };\n    /**\n     * Returns the number of elements in this heap.\n     * @return {number} the number of elements in this heap.\n     */\n    Heap.prototype.size = function () {\n        return this.data.length;\n    };\n    /**\n     * Checks if this heap is empty.\n     * @return {boolean} true if and only if this heap contains no items; false\n     * otherwise.\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.data.length <= 0;\n    };\n    /**\n     * Removes all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.data.length = 0;\n    };\n    /**\n     * Executes the provided function once for each element present in this heap in\n     * no particular order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Heap.prototype.forEach = function (callback) {\n        arrays.forEach(this.data, callback);\n    };\n    return Heap;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Heap;\n//# sourceMappingURL=Heap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Heap.js\n// module id = 13\n// module chunks = 0","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         toSources } from \"./Lambda\";\nimport { Transaction } from \"./Transaction\";\nimport { StreamWithSend } from \"./Stream\";\nimport { Vertex } from \"./Vertex\";\n\nexport class CoalesceHandler<A>\n{\n\tconstructor(f : ((l : A, r : A) => A) | Lambda2<A,A,A>, out : StreamWithSend<A>)\n\t{\n\t    this.f = Lambda2_toFunction(f);\n\t    this.out = out;\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(\n            toSources(Lambda2_deps(f)));\n        this.accumValid = false;\n    }\n\tprivate f : (l : A, r : A) => A;\n\tprivate out : StreamWithSend<A>;\n\tprivate accumValid : boolean;\n    private accum : A;\n    private verbose : boolean;\n    send_(a : A) {\n        if (this.accumValid)\n            this.accum = this.f(this.accum, a);\n        else {\n            Transaction.currentTransaction.prioritized(this.out.getVertex__(), () => {\n                this.out.send_(this.accum);\n                this.accumValid = false;\n                this.accum = null;\n            });\n            this.accum = a;\n            this.accumValid = true;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/CoalesceHandler.ts","/**\n * A representation for a value that may not be available until the current\n * transaction is closed.\n */\nexport class Lazy<A> {\n    constructor(f : () => A) {\n        this.f = f;\n    }\n\n    private f : () => A;\n\n    /**\n     * Get the value if available, throwing an exception if not.\n     * In the general case this should only be used in subsequent transactions to\n     * when the Lazy was obtained.\n     */\n    get() : A {\n        return this.f();\n    }\n\n    /**\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\n     * the value of the function applied to the input Lazy's value.\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : (a : A) => B) {\n        return new Lazy<B>(() => { return f(this.f()); });\n    }\n\n\t/**\n\t * Lift a binary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift<B,C>(b : Lazy<B>, f : (a : A, b : B) => C) : Lazy<C> {\n        return new Lazy<C>(() => { return f(this.f(), b.f()); });\n    }\n\n\t/**\n\t * Lift a ternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift3<B,C,D>(b : Lazy<B>, c : Lazy<C>, f : (a : A, b : B, c : C) => D) : Lazy<D> {\n        return new Lazy<D>(() => { return f(this.f(), b.f(), c.f()); });\n    }\n\n\t/**\n\t * Lift a quaternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift4<B,C,D,E>(b : Lazy<B>, c : Lazy<C>, d : Lazy<D>, f : (a : A, b : B, c : C, d : D) => E) : Lazy<E> {\n        return new Lazy<E>(() => { return f(this.f(), b.f(), c.f(), d.f()); });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Lazy.ts","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { Transaction } from \"./Transaction\";\nimport { Unit } from \"./Unit\";\nimport { Source, Vertex } from \"./Vertex\";\n\nexport class Operational {\n    /**\n     * A stream that gives the updates/steps for a {@link Cell}.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static updates<A>(c : Cell<A>) : Stream<A> {\n        /*  Don't think this is needed\n        const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"updates\", 0, [\n                new Source(\n                    c.getStream__().getVertex__(),\n                    () => {\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                ),\n                new Source(\n                    c.getVertex__(),\n                    () => {\n                        return () => { };\n                    }\n                )\n            ]\n        ));\n        return out;\n        */\n        return c.getStream__();\n    }\n\n    /**\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\n     * firing for each update/step of the cell's value.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static value<A>(c : Cell<A>) : Stream<A> {\n        return Transaction.run(() => {\n            const sSpark = new StreamWithSend<Unit>();\n            Transaction.currentTransaction.prioritized(sSpark.getVertex__(), () => {\n                sSpark.send_(Unit.UNIT);\n            });\n            const sInitial = sSpark.snapshot1(c);\n            return Operational.updates(c).orElse(sInitial);\n        });\n    }\n\n\t/**\n\t * Push each event onto a new transaction guaranteed to come before the next externally\n\t * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\n\t */\n\tstatic defer<A>(s : Stream<A>) : Stream<A> {\n\t    return Operational.split<A>(s.map((a : A) => {\n\t        return [a];\n\t    }));\n    }\n\n\t/**\n\t * Push each event in the list onto a newly created transaction guaranteed\n\t * to come before the next externally initiated transaction. Note that the semantics\n\t * are such that two different invocations of split() can put events into the same\n\t * new transaction, so the resulting stream's events could be simultaneous with\n\t * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\n\t */\n\tstatic split<A>(s : Stream<Array<A>>) : Stream<A> {\n\t    const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"split\", 0, [\n                new Source(\n                    s.getVertex__(),\n                    () => {\n                        return s.listen_(out.getVertex__(), (as : Array<A>) => {\n                            for (let i = 0; i < as.length; i++) {\n                                Transaction.currentTransaction.post(i, () => {\n                                    Transaction.run(() => {\n                                        out.send_(as[i]);\n                                    });\n                                });\n                            }\n                        }, false);\n                    }\n                )\n            ]\n        ));\n        return out;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Operational.ts","export class Unit {\n    static UNIT : Unit = new Unit();\n    constructor() {}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Unit.ts","import { Lazy } from \"./Lazy\";\nimport { Cell } from \"./Cell\";\nimport { Stream } from \"./Stream\";\nimport { Transaction } from \"./Transaction\";\n\nexport class LazyCell<A> extends Cell<A> {\n    constructor(lazyInitValue : Lazy<A>, str? : Stream<A>) {\n        super(null, null);\n        Transaction.run(() => {\n            if (str)\n                this.setStream(str);\n            this.lazyInitValue = lazyInitValue;\n        });\n    }\n\n    sampleNoTrans__() : A {  // Override\n        if (this.value == null && this.lazyInitValue != null) {\n            this.value = this.lazyInitValue.get();\n            this.lazyInitValue = null;\n        }\n        return this.value;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/LazyCell.ts","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { StreamWithSend } from \"./Stream\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * A stream that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\n * should downcast to {@link Stream}.\n */\nexport class StreamSink<A> extends StreamWithSend<A> {\n    constructor(f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n        super();\n        if (!f)\n            f = <(l : A, r : A) => A>((l : A, r : A) => {\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\n            });\n        this.coalescer = new CoalesceHandler<A>(f, this);\n    }\n\n    private coalescer : CoalesceHandler<A>;\n\n    send(a : A) : void {\n        Transaction.run<void>(\n            () => {\n                if (Transaction.currentTransaction.inCallback > 0)\n                    throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\n                this.coalescer.send_(a);\n            }\n        )\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/StreamSink.ts","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { Cell } from \"./Cell\";\nimport { StreamSink } from \"./StreamSink\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * A cell that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\n * should downcast to {@link Cell}.\n */\nexport class CellSink<A> extends Cell<A> {\n    /**\n     * Construct a writable cell with the specified initial value. If multiple values are\n     * sent in the same transaction, the specified function is used to combine them.\n     *\n     * If the function is not supplied, then an exception will be thrown in this case.\n     */\n    constructor(initValue : A, f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n    \tsuper(initValue, new StreamSink<A>(f));\n    }\n\n    /**\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\n     * You are not meant to use this to define your own primitives.\n     * @param a Value to push into the cell.\n     */\n    send(a : A) : void {\n        (<StreamSink<A>>this.getStream__()).send(a);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/CellSink.ts","export { lambda1, lambda2, lambda3, lambda4, lambda5, lambda6 } from \"./Lambda\";\nexport { Stream, StreamLoop } from \"./Stream\";\nexport { StreamSink } from \"./StreamSink\";\nexport { Cell } from \"./Cell\";\nexport { CellLoop } from \"./CellLoop\";\nexport { CellSink } from \"./CellSink\";\nexport { Transaction } from \"./Transaction\";\nexport { Tuple2 } from \"./Tuple2\";\nexport { Unit } from \"./Unit\";\nexport { Operational } from \"./Operational\";\nexport { getTotalRegistrations, Vertex } from \"./Vertex\";\nexport { TimerSystemImpl, TimerSystem } from \"./TimerSystem\";\nexport { SecondsTimerSystem } from \"./SecondsTimerSystem\";\nexport { MillisecondsTimerSystem } from \"./MillisecondsTimerSystem\";\nexport { IOAction } from \"./IOAction\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Sodium.ts","\"use strict\";\nvar util = require('./util');\nvar Dictionary_1 = require('./Dictionary');\nvar Set_1 = require('./Set');\nvar Bag = (function () {\n    /**\n     * Creates an empty bag.\n     * @class <p>A bag is a special kind of set in which members are\n     * allowed to appear more than once.</p>\n     * <p>If the inserted elements are custom objects a function\n     * which converts elements to unique strings must be provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     *\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function used\n     * to convert elements to strings. If the elements aren't strings or if toString()\n     * is not appropriate, a custom function which receives an object and returns a\n     * unique string must be provided.\n     */\n    function Bag(toStrFunction) {\n        this.toStrF = toStrFunction || util.defaultToString;\n        this.dictionary = new Dictionary_1.default(this.toStrF);\n        this.nElements = 0;\n    }\n    /**\n    * Adds nCopies of the specified object to this bag.\n    * @param {Object} element element to add.\n    * @param {number=} nCopies the number of copies to add, if this argument is\n    * undefined 1 copy is added.\n    * @return {boolean} true unless element is undefined.\n    */\n    Bag.prototype.add = function (element, nCopies) {\n        if (nCopies === void 0) { nCopies = 1; }\n        if (util.isUndefined(element) || nCopies <= 0) {\n            return false;\n        }\n        if (!this.contains(element)) {\n            var node = {\n                value: element,\n                copies: nCopies\n            };\n            this.dictionary.setValue(element, node);\n        }\n        else {\n            this.dictionary.getValue(element).copies += nCopies;\n        }\n        this.nElements += nCopies;\n        return true;\n    };\n    /**\n    * Counts the number of copies of the specified object in this bag.\n    * @param {Object} element the object to search for..\n    * @return {number} the number of copies of the object, 0 if not found\n    */\n    Bag.prototype.count = function (element) {\n        if (!this.contains(element)) {\n            return 0;\n        }\n        else {\n            return this.dictionary.getValue(element).copies;\n        }\n    };\n    /**\n     * Returns true if this bag contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this bag contains the specified element,\n     * false otherwise.\n     */\n    Bag.prototype.contains = function (element) {\n        return this.dictionary.containsKey(element);\n    };\n    /**\n    * Removes nCopies of the specified object to this bag.\n    * If the number of copies to remove is greater than the actual number\n    * of copies in the Bag, all copies are removed.\n    * @param {Object} element element to remove.\n    * @param {number=} nCopies the number of copies to remove, if this argument is\n    * undefined 1 copy is removed.\n    * @return {boolean} true if at least 1 element was removed.\n    */\n    Bag.prototype.remove = function (element, nCopies) {\n        if (nCopies === void 0) { nCopies = 1; }\n        if (util.isUndefined(element) || nCopies <= 0) {\n            return false;\n        }\n        if (!this.contains(element)) {\n            return false;\n        }\n        else {\n            var node = this.dictionary.getValue(element);\n            if (nCopies > node.copies) {\n                this.nElements -= node.copies;\n            }\n            else {\n                this.nElements -= nCopies;\n            }\n            node.copies -= nCopies;\n            if (node.copies <= 0) {\n                this.dictionary.remove(element);\n            }\n            return true;\n        }\n    };\n    /**\n     * Returns an array containing all of the elements in this big in arbitrary order,\n     * including multiple copies.\n     * @return {Array} an array containing all of the elements in this bag.\n     */\n    Bag.prototype.toArray = function () {\n        var a = [];\n        var values = this.dictionary.values();\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var node = values_1[_i];\n            var element = node.value;\n            var copies = node.copies;\n            for (var j = 0; j < copies; j++) {\n                a.push(element);\n            }\n        }\n        return a;\n    };\n    /**\n     * Returns a set of unique elements in this bag.\n     * @return {collections.Set<T>} a set of unique elements in this bag.\n     */\n    Bag.prototype.toSet = function () {\n        var toret = new Set_1.default(this.toStrF);\n        var elements = this.dictionary.values();\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n            var ele = elements_1[_i];\n            var value = ele.value;\n            toret.add(value);\n        }\n        return toret;\n    };\n    /**\n     * Executes the provided function once for each element\n     * present in this bag, including multiple copies.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element. To break the iteration you can\n     * optionally return false.\n     */\n    Bag.prototype.forEach = function (callback) {\n        this.dictionary.forEach(function (k, v) {\n            var value = v.value;\n            var copies = v.copies;\n            for (var i = 0; i < copies; i++) {\n                if (callback(value) === false) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    };\n    /**\n     * Returns the number of elements in this bag.\n     * @return {number} the number of elements in this bag.\n     */\n    Bag.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this bag contains no elements.\n     * @return {boolean} true if this bag contains no elements.\n     */\n    Bag.prototype.isEmpty = function () {\n        return this.nElements === 0;\n    };\n    /**\n     * Removes all of the elements from this bag.\n     */\n    Bag.prototype.clear = function () {\n        this.nElements = 0;\n        this.dictionary.clear();\n    };\n    return Bag;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Bag; // End of bag\n//# sourceMappingURL=Bag.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Bag.js\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar util = require('./util');\nvar Queue_1 = require('./Queue');\nvar BSTree = (function () {\n    /**\n     * Creates an empty binary search tree.\n     * @class <p>A binary search tree is a binary tree in which each\n     * internal node stores an element such that the elements stored in the\n     * left subtree are less than it and the elements\n     * stored in the right subtree are greater.</p>\n     * <p>Formally, a binary search tree is a node-based binary tree data structure which\n     * has the following properties:</p>\n     * <ul>\n     * <li>The left subtree of a node contains only nodes with elements less\n     * than the node's element</li>\n     * <li>The right subtree of a node contains only nodes with elements greater\n     * than the node's element</li>\n     * <li>Both the left and right subtrees must also be binary search trees.</li>\n     * </ul>\n     * <p>If the inserted elements are custom objects a compare function must\n     * be provided at construction time, otherwise the <=, === and >= operators are\n     * used to compare elements. Example:</p>\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two elements. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function BSTree(compareFunction) {\n        this.root = null;\n        this.compare = compareFunction || util.defaultCompare;\n        this.nElements = 0;\n    }\n    /**\n     * Adds the specified element to this tree if it is not already present.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if this tree did not already contain the specified element.\n     */\n    BSTree.prototype.add = function (element) {\n        if (util.isUndefined(element)) {\n            return false;\n        }\n        if (this.insertNode(this.createNode(element)) !== null) {\n            this.nElements++;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Removes all of the elements from this tree.\n     */\n    BSTree.prototype.clear = function () {\n        this.root = null;\n        this.nElements = 0;\n    };\n    /**\n     * Returns true if this tree contains no elements.\n     * @return {boolean} true if this tree contains no elements.\n     */\n    BSTree.prototype.isEmpty = function () {\n        return this.nElements === 0;\n    };\n    /**\n     * Returns the number of elements in this tree.\n     * @return {number} the number of elements in this tree.\n     */\n    BSTree.prototype.size = function () {\n        return this.nElements;\n    };\n    /**\n     * Returns true if this tree contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this tree contains the specified element,\n     * false otherwise.\n     */\n    BSTree.prototype.contains = function (element) {\n        if (util.isUndefined(element)) {\n            return false;\n        }\n        return this.searchNode(this.root, element) !== null;\n    };\n    /**\n     * Removes the specified element from this tree if it is present.\n     * @return {boolean} true if this tree contained the specified element.\n     */\n    BSTree.prototype.remove = function (element) {\n        var node = this.searchNode(this.root, element);\n        if (node === null) {\n            return false;\n        }\n        this.removeNode(node);\n        this.nElements--;\n        return true;\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in\n     * in-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.inorderTraversal = function (callback) {\n        this.inorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in pre-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.preorderTraversal = function (callback) {\n        this.preorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in post-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.postorderTraversal = function (callback) {\n        this.postorderTraversalAux(this.root, callback, {\n            stop: false\n        });\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in\n     * level-order.\n     * @param {function(Object):*} callback function to execute, it is invoked with one\n     * argument: the element value, to break the iteration you can optionally return false.\n     */\n    BSTree.prototype.levelTraversal = function (callback) {\n        this.levelTraversalAux(this.root, callback);\n    };\n    /**\n     * Returns the minimum element of this tree.\n     * @return {*} the minimum element of this tree or undefined if this tree is\n     * is empty.\n     */\n    BSTree.prototype.minimum = function () {\n        if (this.isEmpty()) {\n            return undefined;\n        }\n        return this.minimumAux(this.root).element;\n    };\n    /**\n     * Returns the maximum element of this tree.\n     * @return {*} the maximum element of this tree or undefined if this tree is\n     * is empty.\n     */\n    BSTree.prototype.maximum = function () {\n        if (this.isEmpty()) {\n            return undefined;\n        }\n        return this.maximumAux(this.root).element;\n    };\n    /**\n     * Executes the provided function once for each element present in this tree in inorder.\n     * Equivalent to inorderTraversal.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    BSTree.prototype.forEach = function (callback) {\n        this.inorderTraversal(callback);\n    };\n    /**\n     * Returns an array containing all of the elements in this tree in in-order.\n     * @return {Array} an array containing all of the elements in this tree in in-order.\n     */\n    BSTree.prototype.toArray = function () {\n        var array = [];\n        this.inorderTraversal(function (element) {\n            array.push(element);\n            return true;\n        });\n        return array;\n    };\n    /**\n     * Returns the height of this tree.\n     * @return {number} the height of this tree or -1 if is empty.\n     */\n    BSTree.prototype.height = function () {\n        return this.heightAux(this.root);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.searchNode = function (node, element) {\n        var cmp = null;\n        while (node !== null && cmp !== 0) {\n            cmp = this.compare(element, node.element);\n            if (cmp < 0) {\n                node = node.leftCh;\n            }\n            else if (cmp > 0) {\n                node = node.rightCh;\n            }\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.transplant = function (n1, n2) {\n        if (n1.parent === null) {\n            this.root = n2;\n        }\n        else if (n1 === n1.parent.leftCh) {\n            n1.parent.leftCh = n2;\n        }\n        else {\n            n1.parent.rightCh = n2;\n        }\n        if (n2 !== null) {\n            n2.parent = n1.parent;\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.removeNode = function (node) {\n        if (node.leftCh === null) {\n            this.transplant(node, node.rightCh);\n        }\n        else if (node.rightCh === null) {\n            this.transplant(node, node.leftCh);\n        }\n        else {\n            var y = this.minimumAux(node.rightCh);\n            if (y.parent !== node) {\n                this.transplant(y, y.rightCh);\n                y.rightCh = node.rightCh;\n                y.rightCh.parent = y;\n            }\n            this.transplant(node, y);\n            y.leftCh = node.leftCh;\n            y.leftCh.parent = y;\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.inorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        this.inorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n        if (signal.stop) {\n            return;\n        }\n        this.inorderTraversalAux(node.rightCh, callback, signal);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.levelTraversalAux = function (node, callback) {\n        var queue = new Queue_1.default();\n        if (node !== null) {\n            queue.enqueue(node);\n        }\n        while (!queue.isEmpty()) {\n            node = queue.dequeue();\n            if (callback(node.element) === false) {\n                return;\n            }\n            if (node.leftCh !== null) {\n                queue.enqueue(node.leftCh);\n            }\n            if (node.rightCh !== null) {\n                queue.enqueue(node.rightCh);\n            }\n        }\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.preorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n        if (signal.stop) {\n            return;\n        }\n        this.preorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        this.preorderTraversalAux(node.rightCh, callback, signal);\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.postorderTraversalAux = function (node, callback, signal) {\n        if (node === null || signal.stop) {\n            return;\n        }\n        this.postorderTraversalAux(node.leftCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        this.postorderTraversalAux(node.rightCh, callback, signal);\n        if (signal.stop) {\n            return;\n        }\n        signal.stop = callback(node.element) === false;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.minimumAux = function (node) {\n        while (node.leftCh !== null) {\n            node = node.leftCh;\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.maximumAux = function (node) {\n        while (node.rightCh !== null) {\n            node = node.rightCh;\n        }\n        return node;\n    };\n    /**\n      * @private\n      */\n    BSTree.prototype.heightAux = function (node) {\n        if (node === null) {\n            return -1;\n        }\n        return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;\n    };\n    /*\n    * @private\n    */\n    BSTree.prototype.insertNode = function (node) {\n        var parent = null;\n        var position = this.root;\n        var cmp = null;\n        while (position !== null) {\n            cmp = this.compare(node.element, position.element);\n            if (cmp === 0) {\n                return null;\n            }\n            else if (cmp < 0) {\n                parent = position;\n                position = position.leftCh;\n            }\n            else {\n                parent = position;\n                position = position.rightCh;\n            }\n        }\n        node.parent = parent;\n        if (parent === null) {\n            // tree is empty\n            this.root = node;\n        }\n        else if (this.compare(node.element, parent.element) < 0) {\n            parent.leftCh = node;\n        }\n        else {\n            parent.rightCh = node;\n        }\n        return node;\n    };\n    /**\n    * @private\n    */\n    BSTree.prototype.createNode = function (element) {\n        return {\n            element: element,\n            leftCh: null,\n            rightCh: null,\n            parent: null\n        };\n    };\n    return BSTree;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BSTree;\n//# sourceMappingURL=BSTree.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/BSTree.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Dictionary_1 = require('./Dictionary');\nvar util = require('./util');\n/**\n * This class is used by the LinkedDictionary Internally\n * Has to be a class, not an interface, because it needs to have\n * the 'unlink' function defined.\n */\nvar LinkedDictionaryPair = (function () {\n    function LinkedDictionaryPair(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    LinkedDictionaryPair.prototype.unlink = function () {\n        this.prev.next = this.next;\n        this.next.prev = this.prev;\n    };\n    return LinkedDictionaryPair;\n}());\nvar LinkedDictionary = (function (_super) {\n    __extends(LinkedDictionary, _super);\n    function LinkedDictionary(toStrFunction) {\n        _super.call(this, toStrFunction);\n        this.head = new LinkedDictionaryPair(null, null);\n        this.tail = new LinkedDictionaryPair(null, null);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    /**\n     * Inserts the new node to the 'tail' of the list, updating the\n     * neighbors, and moving 'this.tail' (the End of List indicator) that\n     * to the end.\n     */\n    LinkedDictionary.prototype.appendToTail = function (entry) {\n        var lastNode = this.tail.prev;\n        lastNode.next = entry;\n        entry.prev = lastNode;\n        entry.next = this.tail;\n        this.tail.prev = entry;\n    };\n    /**\n     * Retrieves a linked dictionary from the table internally\n     */\n    LinkedDictionary.prototype.getLinkedDictionaryPair = function (key) {\n        if (util.isUndefined(key)) {\n            return undefined;\n        }\n        var k = '$' + this.toStr(key);\n        var pair = (this.table[k]);\n        return pair;\n    };\n    /**\n     * Returns the value to which this dictionary maps the specified key.\n     * Returns undefined if this dictionary contains no mapping for this key.\n     * @param {Object} key key whose associated value is to be returned.\n     * @return {*} the value to which this dictionary maps the specified key or\n     * undefined if the map contains no mapping for this key.\n     */\n    LinkedDictionary.prototype.getValue = function (key) {\n        var pair = this.getLinkedDictionaryPair(key);\n        if (!util.isUndefined(pair)) {\n            return pair.value;\n        }\n        return undefined;\n    };\n    /**\n     * Removes the mapping for this key from this dictionary if it is present.\n     * Also, if a value is present for this key, the entry is removed from the\n     * insertion ordering.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @return {*} previous value associated with specified key, or undefined if\n     * there was no mapping for key.\n     */\n    LinkedDictionary.prototype.remove = function (key) {\n        var pair = this.getLinkedDictionaryPair(key);\n        if (!util.isUndefined(pair)) {\n            _super.prototype.remove.call(this, key); // This will remove it from the table\n            pair.unlink(); // This will unlink it from the chain\n            return pair.value;\n        }\n        return undefined;\n    };\n    /**\n    * Removes all mappings from this LinkedDictionary.\n    * @this {collections.LinkedDictionary}\n    */\n    LinkedDictionary.prototype.clear = function () {\n        _super.prototype.clear.call(this);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    };\n    /**\n     * Internal function used when updating an existing KeyValue pair.\n     * It places the new value indexed by key into the table, but maintains\n     * its place in the linked ordering.\n     */\n    LinkedDictionary.prototype.replace = function (oldPair, newPair) {\n        var k = '$' + this.toStr(newPair.key);\n        // set the new Pair's links to existingPair's links\n        newPair.next = oldPair.next;\n        newPair.prev = oldPair.prev;\n        // Delete Existing Pair from the table, unlink it from chain.\n        // As a result, the nElements gets decremented by this operation\n        this.remove(oldPair.key);\n        // Link new Pair in place of where oldPair was,\n        // by pointing the old pair's neighbors to it.\n        newPair.prev.next = newPair;\n        newPair.next.prev = newPair;\n        this.table[k] = newPair;\n        // To make up for the fact that the number of elements was decremented,\n        // We need to increase it by one.\n        ++this.nElements;\n    };\n    /**\n     * Associates the specified value with the specified key in this dictionary.\n     * If the dictionary previously contained a mapping for this key, the old\n     * value is replaced by the specified value.\n     * Updating of a key that already exists maintains its place in the\n     * insertion order into the map.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value value to be associated with the specified key.\n     * @return {*} previous value associated with the specified key, or undefined if\n     * there was no mapping for the key or if the key/value are undefined.\n     */\n    LinkedDictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return undefined;\n        }\n        var existingPair = this.getLinkedDictionaryPair(key);\n        var newPair = new LinkedDictionaryPair(key, value);\n        var k = '$' + this.toStr(key);\n        // If there is already an element for that key, we\n        // keep it's place in the LinkedList\n        if (!util.isUndefined(existingPair)) {\n            this.replace(existingPair, newPair);\n            return existingPair.value;\n        }\n        else {\n            this.appendToTail(newPair);\n            this.table[k] = newPair;\n            ++this.nElements;\n            return undefined;\n        }\n    };\n    /**\n     * Returns an array containing all of the keys in this LinkedDictionary, ordered\n     * by insertion order.\n     * @return {Array} an array containing all of the keys in this LinkedDictionary,\n     * ordered by insertion order.\n     */\n    LinkedDictionary.prototype.keys = function () {\n        var array = [];\n        this.forEach(function (key, value) {\n            array.push(key);\n        });\n        return array;\n    };\n    /**\n     * Returns an array containing all of the values in this LinkedDictionary, ordered by\n     * insertion order.\n     * @return {Array} an array containing all of the values in this LinkedDictionary,\n     * ordered by insertion order.\n     */\n    LinkedDictionary.prototype.values = function () {\n        var array = [];\n        this.forEach(function (key, value) {\n            array.push(value);\n        });\n        return array;\n    };\n    /**\n    * Executes the provided function once for each key-value pair\n    * present in this LinkedDictionary. It is done in the order of insertion\n    * into the LinkedDictionary\n    * @param {function(Object,Object):*} callback function to execute, it is\n    * invoked with two arguments: key and value. To break the iteration you can\n    * optionally return false.\n    */\n    LinkedDictionary.prototype.forEach = function (callback) {\n        var crawlNode = this.head.next;\n        while (crawlNode.next != null) {\n            var ret = callback(crawlNode.key, crawlNode.value);\n            if (ret === false) {\n                return;\n            }\n            crawlNode = crawlNode.next;\n        }\n    };\n    return LinkedDictionary;\n}(Dictionary_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedDictionary; // End of LinkedDictionary\n// /**\n//  * Returns true if this dictionary is equal to the given dictionary.\n//  * Two dictionaries are equal if they contain the same mappings.\n//  * @param {collections.Dictionary} other the other dictionary.\n//  * @param {function(Object,Object):boolean=} valuesEqualFunction optional\n//  * function used to check if two values are equal.\n//  * @return {boolean} true if this dictionary is equal to the given dictionary.\n//  */\n// collections.Dictionary.prototype.equals = function(other,valuesEqualFunction) {\n// \tconst eqF = valuesEqualFunction || collections.defaultEquals;\n// \tif(!(other instanceof collections.Dictionary)){\n// \t\treturn false;\n// \t}\n// \tif(this.size() !== other.size()){\n// \t\treturn false;\n// \t}\n// \treturn this.equalsAux(this.firstNode,other.firstNode,eqF);\n// }\n//# sourceMappingURL=LinkedDictionary.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/LinkedDictionary.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nvar util = require('./util');\nvar Dictionary_1 = require('./Dictionary');\nvar arrays = require('./arrays');\nvar MultiDictionary = (function () {\n    /**\n     * Creates an empty multi dictionary.\n     * @class <p>A multi dictionary is a special kind of dictionary that holds\n     * multiple values against each key. Setting a value into the dictionary will\n     * add the value to an array at that key. Getting a key will return an array,\n     * holding all the values set to that key.\n     * You can configure to allow duplicates in the values.\n     * This implementation accepts any kind of objects as keys.</p>\n     *\n     * <p>If the keys are custom objects a function which converts keys to strings must be\n     * provided. Example:</p>\n     *\n     * <pre>\n     * function petToString(pet) {\n       *  return pet.name;\n       * }\n     * </pre>\n     * <p>If the values are custom objects a function to check equality between values\n     * must be provided. Example:</p>\n     *\n     * <pre>\n     * function petsAreEqualByAge(pet1,pet2) {\n       *  return pet1.age===pet2.age;\n       * }\n     * </pre>\n     * @constructor\n     * @param {function(Object):string=} toStrFunction optional function\n     * to convert keys to strings. If the keys aren't strings or if toString()\n     * is not appropriate, a custom function which receives a key and returns a\n     * unique string must be provided.\n     * @param {function(Object,Object):boolean=} valuesEqualsFunction optional\n     * function to check if two values are equal.\n     *\n     * @param allowDuplicateValues\n     */\n    function MultiDictionary(toStrFunction, valuesEqualsFunction, allowDuplicateValues) {\n        if (allowDuplicateValues === void 0) { allowDuplicateValues = false; }\n        this.dict = new Dictionary_1.default(toStrFunction);\n        this.equalsF = valuesEqualsFunction || util.defaultEquals;\n        this.allowDuplicate = allowDuplicateValues;\n    }\n    /**\n    * Returns an array holding the values to which this dictionary maps\n    * the specified key.\n    * Returns an empty array if this dictionary contains no mappings for this key.\n    * @param {Object} key key whose associated values are to be returned.\n    * @return {Array} an array holding the values to which this dictionary maps\n    * the specified key.\n    */\n    MultiDictionary.prototype.getValue = function (key) {\n        var values = this.dict.getValue(key);\n        if (util.isUndefined(values)) {\n            return [];\n        }\n        return arrays.copy(values);\n    };\n    /**\n     * Adds the value to the array associated with the specified key, if\n     * it is not already present.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value the value to add to the array at the key\n     * @return {boolean} true if the value was not already associated with that key.\n     */\n    MultiDictionary.prototype.setValue = function (key, value) {\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return false;\n        }\n        if (!this.containsKey(key)) {\n            this.dict.setValue(key, [value]);\n            return true;\n        }\n        var array = this.dict.getValue(key);\n        if (!this.allowDuplicate) {\n            if (arrays.contains(array, value, this.equalsF)) {\n                return false;\n            }\n        }\n        array.push(value);\n        return true;\n    };\n    /**\n     * Removes the specified values from the array of values associated with the\n     * specified key. If a value isn't given, all values associated with the specified\n     * key are removed.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @param {Object=} value optional argument to specify the value to remove\n     * from the array associated with the specified key.\n     * @return {*} true if the dictionary changed, false if the key doesn't exist or\n     * if the specified value isn't associated with the specified key.\n     */\n    MultiDictionary.prototype.remove = function (key, value) {\n        if (util.isUndefined(value)) {\n            var v = this.dict.remove(key);\n            return !util.isUndefined(v);\n        }\n        var array = this.dict.getValue(key);\n        if (arrays.remove(array, value, this.equalsF)) {\n            if (array.length === 0) {\n                this.dict.remove(key);\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns an array containing all of the keys in this dictionary.\n     * @return {Array} an array containing all of the keys in this dictionary.\n     */\n    MultiDictionary.prototype.keys = function () {\n        return this.dict.keys();\n    };\n    /**\n     * Returns an array containing all of the values in this dictionary.\n     * @return {Array} an array containing all of the values in this dictionary.\n     */\n    MultiDictionary.prototype.values = function () {\n        var values = this.dict.values();\n        var array = [];\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var v = values_1[_i];\n            for (var _a = 0, v_1 = v; _a < v_1.length; _a++) {\n                var w = v_1[_a];\n                array.push(w);\n            }\n        }\n        return array;\n    };\n    /**\n     * Returns true if this dictionary at least one value associatted the specified key.\n     * @param {Object} key key whose presence in this dictionary is to be\n     * tested.\n     * @return {boolean} true if this dictionary at least one value associatted\n     * the specified key.\n     */\n    MultiDictionary.prototype.containsKey = function (key) {\n        return this.dict.containsKey(key);\n    };\n    /**\n     * Removes all mappings from this dictionary.\n     */\n    MultiDictionary.prototype.clear = function () {\n        this.dict.clear();\n    };\n    /**\n     * Returns the number of keys in this dictionary.\n     * @return {number} the number of key-value mappings in this dictionary.\n     */\n    MultiDictionary.prototype.size = function () {\n        return this.dict.size();\n    };\n    /**\n     * Returns true if this dictionary contains no mappings.\n     * @return {boolean} true if this dictionary contains no mappings.\n     */\n    MultiDictionary.prototype.isEmpty = function () {\n        return this.dict.isEmpty();\n    };\n    return MultiDictionary;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MultiDictionary; // end of multi dictionary\n//# sourceMappingURL=MultiDictionary.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/MultiDictionary.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nvar util = require('./util');\nvar Heap_1 = require('./Heap');\nvar PriorityQueue = (function () {\n    /**\n     * Creates an empty priority queue.\n     * @class <p>In a priority queue each element is associated with a \"priority\",\n     * elements are dequeued in highest-priority-first order (the elements with the\n     * highest priority are dequeued first). Priority Queues are implemented as heaps.\n     * If the inserted elements are custom objects a compare function must be provided,\n     * otherwise the <=, === and >= operators are used to compare object priority.</p>\n     * <pre>\n     * function compare(a, b) {\n     *  if (a is less than b by some ordering criterion) {\n     *     return -1;\n     *  } if (a is greater than b by the ordering criterion) {\n     *     return 1;\n     *  }\n     *  // a must be equal to b\n     *  return 0;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object,Object):number=} compareFunction optional\n     * function used to compare two element priorities. Must return a negative integer,\n     * zero, or a positive integer as the first argument is less than, equal to,\n     * or greater than the second.\n     */\n    function PriorityQueue(compareFunction) {\n        this.heap = new Heap_1.default(util.reverseCompareFunction(compareFunction));\n    }\n    /**\n     * Inserts the specified element into this priority queue.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    PriorityQueue.prototype.enqueue = function (element) {\n        return this.heap.add(element);\n    };\n    /**\n     * Inserts the specified element into this priority queue.\n     * @param {Object} element the element to insert.\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\n     */\n    PriorityQueue.prototype.add = function (element) {\n        return this.heap.add(element);\n    };\n    /**\n     * Retrieves and removes the highest priority element of this queue.\n     * @return {*} the the highest priority element of this queue,\n     *  or undefined if this queue is empty.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        if (this.heap.size() !== 0) {\n            var el = this.heap.peek();\n            this.heap.removeRoot();\n            return el;\n        }\n        return undefined;\n    };\n    /**\n     * Retrieves, but does not remove, the highest priority element of this queue.\n     * @return {*} the highest priority element of this queue, or undefined if this queue is empty.\n     */\n    PriorityQueue.prototype.peek = function () {\n        return this.heap.peek();\n    };\n    /**\n     * Returns true if this priority queue contains the specified element.\n     * @param {Object} element element to search for.\n     * @return {boolean} true if this priority queue contains the specified element,\n     * false otherwise.\n     */\n    PriorityQueue.prototype.contains = function (element) {\n        return this.heap.contains(element);\n    };\n    /**\n     * Checks if this priority queue is empty.\n     * @return {boolean} true if and only if this priority queue contains no items; false\n     * otherwise.\n     */\n    PriorityQueue.prototype.isEmpty = function () {\n        return this.heap.isEmpty();\n    };\n    /**\n     * Returns the number of elements in this priority queue.\n     * @return {number} the number of elements in this priority queue.\n     */\n    PriorityQueue.prototype.size = function () {\n        return this.heap.size();\n    };\n    /**\n     * Removes all of the elements from this priority queue.\n     */\n    PriorityQueue.prototype.clear = function () {\n        this.heap.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this queue in\n     * no particular order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    PriorityQueue.prototype.forEach = function (callback) {\n        this.heap.forEach(callback);\n    };\n    return PriorityQueue;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = PriorityQueue; // end of priority queue\n//# sourceMappingURL=PriorityQueue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/PriorityQueue.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar LinkedList_1 = require('./LinkedList');\nvar Stack = (function () {\n    /**\n     * Creates an empty Stack.\n     * @class A Stack is a Last-In-First-Out (LIFO) data structure, the last\n     * element added to the stack will be the first one to be removed. This\n     * implementation uses a linked list as a container.\n     * @constructor\n     */\n    function Stack() {\n        this.list = new LinkedList_1.default();\n    }\n    /**\n     * Pushes an item onto the top of this stack.\n     * @param {Object} elem the element to be pushed onto this stack.\n     * @return {boolean} true if the element was pushed or false if it is undefined.\n     */\n    Stack.prototype.push = function (elem) {\n        return this.list.add(elem, 0);\n    };\n    /**\n     * Pushes an item onto the top of this stack.\n     * @param {Object} elem the element to be pushed onto this stack.\n     * @return {boolean} true if the element was pushed or false if it is undefined.\n     */\n    Stack.prototype.add = function (elem) {\n        return this.list.add(elem, 0);\n    };\n    /**\n     * Removes the object at the top of this stack and returns that object.\n     * @return {*} the object at the top of this stack or undefined if the\n     * stack is empty.\n     */\n    Stack.prototype.pop = function () {\n        return this.list.removeElementAtIndex(0);\n    };\n    /**\n     * Looks at the object at the top of this stack without removing it from the\n     * stack.\n     * @return {*} the object at the top of this stack or undefined if the\n     * stack is empty.\n     */\n    Stack.prototype.peek = function () {\n        return this.list.first();\n    };\n    /**\n     * Returns the number of elements in this stack.\n     * @return {number} the number of elements in this stack.\n     */\n    Stack.prototype.size = function () {\n        return this.list.size();\n    };\n    /**\n     * Returns true if this stack contains the specified element.\n     * <p>If the elements inside this stack are\n     * not comparable with the === operator, a custom equals function should be\n     * provided to perform searches, the function must receive two arguments and\n     * return true if they are equal, false otherwise. Example:</p>\n     *\n     * <pre>\n     * const petsAreEqualByName (pet1, pet2) {\n     *  return pet1.name === pet2.name;\n     * }\n     * </pre>\n     * @param {Object} elem element to search for.\n     * @param {function(Object,Object):boolean=} equalsFunction optional\n     * function to check if two elements are equal.\n     * @return {boolean} true if this stack contains the specified element,\n     * false otherwise.\n     */\n    Stack.prototype.contains = function (elem, equalsFunction) {\n        return this.list.contains(elem, equalsFunction);\n    };\n    /**\n     * Checks if this stack is empty.\n     * @return {boolean} true if and only if this stack contains no items; false\n     * otherwise.\n     */\n    Stack.prototype.isEmpty = function () {\n        return this.list.isEmpty();\n    };\n    /**\n     * Removes all of the elements from this stack.\n     */\n    Stack.prototype.clear = function () {\n        this.list.clear();\n    };\n    /**\n     * Executes the provided function once for each element present in this stack in\n     * LIFO order.\n     * @param {function(Object):*} callback function to execute, it is\n     * invoked with one argument: the element value, to break the iteration you can\n     * optionally return false.\n     */\n    Stack.prototype.forEach = function (callback) {\n        this.list.forEach(callback);\n    };\n    return Stack;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stack; // End of stack\n//# sourceMappingURL=Stack.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-collections/dist/lib/Stack.js\n// module id = 27\n// module chunks = 0","import { Source, Vertex } from \"./Vertex\";\n\nexport class Listener<A> {\n    constructor(h : (a : A) => void, target : Vertex) {\n        this.h = h;\n        this.target = target;\n    }\n    h : (a : A) => void;\n    target : Vertex;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Listener.ts","import { Cell } from \"./Cell\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\nimport { Transaction } from \"./Transaction\";\nimport { StreamLoop } from \"./Stream\";\n\n/**\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\n */\nexport class CellLoop<A> extends LazyCell<A> {\n    constructor() {\n    \tsuper(null, new StreamLoop<A>());\n    }\n\n    /**\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(a_out : Cell<A>) : void {\n        const me = this;\n        Transaction.run(() => {\n            (<StreamLoop<A>>me.getStream__()).loop(a_out.getStream__());\n            me.lazyInitValue = a_out.sampleLazy();\n        });\n    }\n\n    sampleNoTrans__() : A\n    {\n        if (!(<StreamLoop<A>>this.getStream__()).assigned__)\n            throw new Error(\"CellLoop sampled before it was looped\");\n        return super.sampleNoTrans__();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/CellLoop.ts","export class Tuple2<A,B> {\n    constructor(a : A, b : B) {\n        this.a = a;\n        this.b = b;\n    }\n    a : A;\n    b : B;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Tuple2.ts","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using seconds as the time unit.\n */\nexport class SecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new SecondsTimerSystemImpl());\n    }\n}\n\nclass SecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, Math.max((t - this.now()) * 1000, 0));\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now() * 0.001;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/SecondsTimerSystem.ts","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using milliseconds as the time unit.\n */\nexport class MillisecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new MillisecondsTimerSystemImpl());\n    }\n}\n\nclass MillisecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, Math.max(t - this.now(), 0));\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/MillisecondsTimerSystem.ts","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Vertex, Source } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\n\nexport class IOAction {\n    /*!\n     * Convert a function that performs asynchronous I/O taking input A\n     * and returning a value of type B into an I/O action of type\n     * (sa : Stream<A>) => Stream<B>\n     */\n    static fromAsync<A,B>(performIO : (a : A, result : (b : B) => void) => void)\n            : (sa : Stream<A>) => Stream<B> {\n        return (sa : Stream<A>) => {\n            const out = new StreamWithSend<B>(null);\n            out.setVertex__(new Vertex(\"map\", 0, [\n                    new Source(\n                        sa.getVertex__(),\n                        () => {\n                            return sa.listen_(out.getVertex__(), (a : A) => {\n                                performIO(a, (b : B) => {\n                                    Transaction.run(() => {\n                                        out.send_(b);\n                                    });\n                                });\n                            }, false);\n                        }\n                    )\n                ]\n            ));\n            return out;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/IOAction.ts"],"sourceRoot":""}