{"version":3,"file":"sodium.umd.min.js","sources":["../src/lib/sodium/Transaction.ts","../src/lib/sodium/Vertex.ts","../src/lib/sodium/Lambda.ts","../src/lib/sodium/CoalesceHandler.ts","../src/lib/sodium/Lazy.ts","../src/lib/sodium/Unit.ts","../src/lib/sodium/Operational.ts","../src/lib/sodium/Cell.ts","../src/lib/sodium/Listener.ts","../src/lib/sodium/LazyCell.ts","../src/lib/sodium/Stream.ts","../src/lib/sodium/StreamSink.ts","../src/lib/sodium/CellLoop.ts","../src/lib/sodium/CellSink.ts","../src/lib/sodium/Tuple2.ts","../src/lib/sodium/TimerSystem.ts","../src/lib/sodium/SecondsTimerSystem.ts","../src/lib/sodium/MillisecondsTimerSystem.ts","../src/lib/sodium/IOAction.ts"],"sourcesContent":["import {Vertex} from './Vertex';\r\nimport * as Collections from 'typescript-collections';\r\n\r\nexport class Entry\r\n{\r\n  constructor(rank: Vertex, action: () => void)\r\n  {\r\n    this.rank = rank;\r\n    this.action = action;\r\n    this.seq = Entry.nextSeq++;\r\n  }\r\n\r\n  private static nextSeq: number = 0;\r\n  rank: Vertex;\r\n  action: () => void;\r\n  seq: number;\r\n\r\n  toString(): string\r\n  {\r\n    return this.seq.toString();\r\n  }\r\n}\r\n\r\nexport class Transaction\r\n{\r\n  public static currentTransaction: Transaction = null;\r\n  private static onStartHooks: (() => void)[] = [];\r\n  private static runningOnStartHooks: boolean = false;\r\n\r\n  constructor() {}\r\n\r\n  inCallback: number = 0;\r\n  private toRegen: boolean = false;\r\n\r\n  requestRegen(): void\r\n  {\r\n    this.toRegen = true;\r\n  }\r\n\r\n  prioritizedQ: Collections.PriorityQueue<Entry> = new Collections.PriorityQueue<Entry>((a, b) =>\r\n  {\r\n    // Note: Low priority numbers are treated as \"greater\" according to this\r\n    // comparison, so that the lowest numbers are highest priority and go first.\r\n    if (a.rank.rank < b.rank.rank) return 1;\r\n    if (a.rank.rank > b.rank.rank) return -1;\r\n    if (a.seq < b.seq) return 1;\r\n    if (a.seq > b.seq) return -1;\r\n    return 0;\r\n  });\r\n  private entries: Collections.Set<Entry> = new Collections.Set<Entry>((a) => a.toString());\r\n  private sampleQ: Array<() => void> = [];\r\n  private lastQ: Array<() => void> = [];\r\n  private postQ: Array<() => void> = null;\r\n  private collectCyclesAtEnd: boolean = false;\r\n\r\n  prioritized(target: Vertex, action: () => void): void\r\n  {\r\n    const e = new Entry(target, action);\r\n    this.prioritizedQ.enqueue(e);\r\n    this.entries.add(e);\r\n  }\r\n\r\n  sample(h: () => void): void\r\n  {\r\n    this.sampleQ.push(h);\r\n  }\r\n\r\n  last(h: () => void): void\r\n  {\r\n    this.lastQ.push(h);\r\n  }\r\n\r\n  public static _collectCyclesAtEnd(): void\r\n  {\r\n    Transaction.run(() => Transaction.currentTransaction.collectCyclesAtEnd = true);\r\n  }\r\n\r\n  /**\r\n   * Add an action to run after all last() actions.\r\n   */\r\n  post(childIx: number, action: () => void): void\r\n  {\r\n    if (this.postQ == null)\r\n      this.postQ = [];\r\n    // If an entry exists already, combine the old one with the new one.\r\n    while (this.postQ.length <= childIx)\r\n      this.postQ.push(null);\r\n    const existing = this.postQ[childIx],\r\n      neu =\r\n        existing === null ? action\r\n          : () =>\r\n        {\r\n          existing();\r\n          action();\r\n        };\r\n    this.postQ[childIx] = neu;\r\n  }\r\n\r\n  // If the priority queue has entries in it when we modify any of the nodes'\r\n  // ranks, then we need to re-generate it to make sure it's up-to-date.\r\n  private checkRegen(): void\r\n  {\r\n    if (this.toRegen)\r\n    {\r\n      this.toRegen = false;\r\n      this.prioritizedQ.clear();\r\n      const es = this.entries.toArray();\r\n      for (let i: number = 0; i < es.length; i++)\r\n        this.prioritizedQ.enqueue(es[i]);\r\n    }\r\n  }\r\n\r\n  public isActive() : boolean\r\n  {\r\n    return Transaction.currentTransaction ? true : false;\r\n  }\r\n\r\n  close(): void\r\n  {\r\n    while(true)\r\n    {\r\n      while (true)\r\n      {\r\n        this.checkRegen();\r\n        if (this.prioritizedQ.isEmpty()) break;\r\n        const e = this.prioritizedQ.dequeue();\r\n        this.entries.remove(e);\r\n        e.action();\r\n      }\r\n\r\n      const sq = this.sampleQ;\r\n      this.sampleQ = [];\r\n      for (let i = 0; i < sq.length; i++)\r\n        sq[i]();\r\n\r\n      if(this.prioritizedQ.isEmpty() && this.sampleQ.length < 1) break;\r\n    }\r\n\r\n    for (let i = 0; i < this.lastQ.length; i++)\r\n      this.lastQ[i]();\r\n    this.lastQ = [];\r\n    if (this.postQ != null)\r\n    {\r\n      for (let i = 0; i < this.postQ.length; i++)\r\n      {\r\n        if (this.postQ[i] != null)\r\n        {\r\n          const parent = Transaction.currentTransaction;\r\n          try\r\n          {\r\n            if (i > 0)\r\n            {\r\n              Transaction.currentTransaction = new Transaction();\r\n              try\r\n              {\r\n                this.postQ[i]();\r\n                Transaction.currentTransaction.close();\r\n              }\r\n              catch (err)\r\n              {\r\n                Transaction.currentTransaction.close();\r\n                throw err;\r\n              }\r\n            }\r\n            else\r\n            {\r\n              Transaction.currentTransaction = null;\r\n              this.postQ[i]();\r\n            }\r\n            Transaction.currentTransaction = parent;\r\n          }\r\n          catch (err)\r\n          {\r\n            Transaction.currentTransaction = parent;\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n      this.postQ = null;\r\n    }\r\n    if (this.collectCyclesAtEnd) {\r\n      Vertex.collectCycles();\r\n      this.collectCyclesAtEnd = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a runnable that will be executed whenever a transaction is started.\r\n   * That runnable may start transactions itself, which will not cause the\r\n   * hooks to be run recursively.\r\n   *\r\n   * The main use case of this is the implementation of a time/alarm system.\r\n   */\r\n  static onStart(r: () => void): void\r\n  {\r\n    Transaction.onStartHooks.push(r);\r\n  }\r\n\r\n  public static run<A>(f: () => A): A\r\n  {\r\n    const transWas: Transaction = Transaction.currentTransaction;\r\n    if (transWas === null)\r\n    {\r\n      if (!Transaction.runningOnStartHooks)\r\n      {\r\n        Transaction.runningOnStartHooks = true;\r\n        try\r\n        {\r\n          for (let i = 0; i < Transaction.onStartHooks.length; i++)\r\n            Transaction.onStartHooks[i]();\r\n        }\r\n        finally\r\n        {\r\n          Transaction.runningOnStartHooks = false;\r\n        }\r\n      }\r\n      Transaction.currentTransaction = new Transaction();\r\n    }\r\n    try\r\n    {\r\n      const a: A = f();\r\n      if (transWas === null)\r\n      {\r\n        Transaction.currentTransaction.close();\r\n        Transaction.currentTransaction = null;\r\n      }\r\n      return a;\r\n    }\r\n    catch (err)\r\n    {\r\n      if (transWas === null)\r\n      {\r\n        Transaction.currentTransaction.close();\r\n        Transaction.currentTransaction = null;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","import { Transaction } from \"./Transaction\";\r\nimport { Set } from \"typescript-collections\";\r\n\r\nlet totalRegistrations : number = 0;\r\nexport function getTotalRegistrations() : number {\r\n    return totalRegistrations;\r\n}\r\n\r\nexport class Source {\r\n    constructor(\r\n        origin : Vertex,\r\n        register_ : () => () => void\r\n    ) {\r\n        if (origin === null)\r\n            throw new Error(\"null origin!\");\r\n        this.origin = origin;\r\n        this.register_ = register_;\r\n    }\r\n    origin : Vertex;\r\n    private register_ : () => () => void;\r\n    private registered : boolean = false;\r\n    private deregister_ : () => void = null;\r\n\r\n    register(target : Vertex) : void {\r\n        if (!this.registered) {\r\n            this.registered = true;\r\n            if (this.register_ !== null)\r\n                this.deregister_ = this.register_();\r\n            else {\r\n                this.origin.increment(target);\r\n                this.deregister_ = () => this.origin.decrement(target);\r\n            }\r\n        }\r\n    }\r\n    deregister(target : Vertex) : void {\r\n        if (this.registered) {\r\n            this.registered = false;\r\n            if (this.deregister_ !== null)\r\n                this.deregister_();\r\n        }\r\n    }\r\n}\r\n\r\nexport enum Color { black, gray, white, purple };\r\nlet roots : Vertex[] = [];\r\nlet nextID : number = 0;\r\nlet verbose : boolean = false;\r\n\r\nexport function setVerbose(v : boolean) : void { verbose = v; }\r\n\r\nexport function describeAll(v : Vertex, visited : Set<number>)\r\n{\r\n    if (visited.contains(v.id)) return;\r\n    console.log(v.descr());\r\n    visited.add(v.id);\r\n    let chs = v.children();\r\n    for (let i = 0; i < chs.length; i++)\r\n        describeAll(chs[i], visited);\r\n}\r\n\r\nexport class Vertex {\r\n    static NULL : Vertex = new Vertex(\"user\", 1e12, []);\r\n    static collectingCycles : boolean = false;\r\n    id : number;\r\n\r\n\tconstructor(name : string, rank : number, sources : Source[]) {\r\n\t    this.name = name;\r\n\t\tthis.rank = rank;\r\n\t\tthis.sources = sources;\r\n\t\tthis.id = nextID++;\r\n\t}\r\n\tname : string;\r\n    rank : number;\r\n    sources : Source[];\r\n    targets : Vertex[] = [];\r\n    childrn : Vertex[] = [];\r\n    refCount() : number { return this.targets.length; };\r\n    visited : boolean = false;\r\n    register(target : Vertex) : boolean {\r\n        return this.increment(target);\r\n    }\r\n    deregister(target : Vertex) : void {\r\n        if (verbose)\r\n            console.log(\"deregister \"+this.descr()+\" => \"+target.descr());\r\n        this.decrement(target);\r\n        Transaction._collectCyclesAtEnd();\r\n    }\r\n    private incRefCount(target : Vertex) : boolean {\r\n        let anyChanged : boolean = false;\r\n        if (this.refCount() == 0) {\r\n            for (let i = 0; i < this.sources.length; i++)\r\n                this.sources[i].register(this);\r\n        }\r\n        this.targets.push(target);\r\n        target.childrn.push(this);\r\n        if (target.ensureBiggerThan(this.rank))\r\n            anyChanged = true;\r\n        totalRegistrations++;\r\n        return anyChanged;\r\n    }\r\n\r\n    private decRefCount(target : Vertex) : void {\r\n        if (verbose)\r\n            console.log(\"DEC \"+this.descr());\r\n        let matched = false;\r\n        for (let i = target.childrn.length-1; i >= 0; i--)\r\n            if (target.childrn[i] === this) {\r\n                target.childrn.splice(i, 1);\r\n            }\r\n        for (let i = 0; i < this.targets.length; i++)\r\n            if (this.targets[i] === target) {\r\n                this.targets.splice(i, 1);\r\n                matched = true;\r\n                break;\r\n            }\r\n        if (matched) {\r\n            if (this.refCount() == 0) {\r\n                for (let i = 0; i < this.sources.length; i++)\r\n                    this.sources[i].deregister(this);\r\n            }\r\n            totalRegistrations--;\r\n        }\r\n    }\r\n\r\n    addSource(src : Source) : void {\r\n        this.sources.push(src);\r\n        if (this.refCount() > 0)\r\n            src.register(this);\r\n    }\r\n\r\n\tprivate ensureBiggerThan(limit : number) : boolean {\r\n\t\tif (this.rank > limit || this.visited)\r\n\t\t\treturn false;\r\n\r\n        this.visited = true;\r\n\t\tthis.rank = limit + 1;\r\n\t\tfor (let i = 0; i < this.targets.length; i++)\r\n\t\t\tthis.targets[i].ensureBiggerThan(this.rank);\r\n        this.visited = false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tdescr() : string {\r\n        let colStr : string = null;\r\n        switch (this.color) {\r\n        case Color.black: colStr = \"black\"; break;\r\n        case Color.gray:  colStr = \"gray\"; break;\r\n        case Color.white: colStr = \"white\"; break;\r\n        case Color.purple: colStr = \"purple\"; break;\r\n        }\r\n        let str = this.id+\" \"+this.name+\" [\"+this.refCount()+\"/\"+this.refCountAdj+\"] \"+colStr+\" ->\";\r\n        let chs = this.children();\r\n        for (let i = 0; i < chs.length; i++) {\r\n            str = str + \" \" + chs[i].id;\r\n        }\r\n        return str;\r\n\t}\r\n\r\n\t// --------------------------------------------------------\r\n\t// Synchronous Cycle Collection algorithm presented in \"Concurrent\r\n\t// Cycle Collection in Reference Counted Systems\" by David F. Bacon\r\n\t// and V.T. Rajan.\r\n\r\n    color : Color = Color.black;\r\n    buffered : boolean = false;\r\n    refCountAdj : number = 0;\r\n\r\n\tchildren() : Vertex[] { return this.childrn; }\r\n\r\n\tincrement(referrer : Vertex) : boolean {\r\n\t    return this.incRefCount(referrer);\r\n\t}\r\n\r\n\tdecrement(referrer : Vertex) : void {\r\n\t    this.decRefCount(referrer);\r\n\t    if (this.refCount() == 0)\r\n\t        this.release();\r\n        else\r\n            this.possibleRoots();\r\n\t}\r\n\r\n    release() : void {\r\n        this.color = Color.black;\r\n        if (!this.buffered)\r\n            this.free();\r\n    }\r\n\r\n    free() : void {\r\n        while (this.targets.length > 0)\r\n            this.decRefCount(this.targets[0]);\r\n    }\r\n\r\n\tpossibleRoots() : void {\r\n\t    if (this.color != Color.purple) {\r\n\t        this.color = Color.purple;\r\n\t        if (!this.buffered) {\r\n                this.buffered = true;\r\n                roots.push(this);\r\n            }\r\n        }\r\n\t}\r\n\r\n\tstatic collectCycles() : void {\r\n        if (Vertex.collectingCycles) {\r\n            return;\r\n        }\r\n        try {\r\n            Vertex.collectingCycles = true;\r\n            Vertex.markRoots();\r\n            Vertex.scanRoots();\r\n            Vertex.collectRoots();\r\n        } finally {\r\n            Vertex.collectingCycles = false;\r\n        }\r\n\t}\r\n\r\n\tstatic markRoots() : void {\r\n\t    const newRoots : Vertex[] = [];\r\n\t    for (let i = 0; i < roots.length; i++) {\r\n            if (verbose)\r\n                console.log(\"markRoots \"+roots[i].descr());  // ###\r\n\t        if (roots[i].color == Color.purple) {\r\n\t            roots[i].markGray();\r\n\t            newRoots.push(roots[i]);\r\n            }\r\n\t        else {\r\n\t            roots[i].buffered = false;\r\n\t            if (roots[i].color == Color.black && roots[i].refCount() == 0)\r\n\t                roots[i].free();\r\n            }\r\n\t    }\r\n\t    roots = newRoots;\r\n\t}\r\n\r\n\tstatic scanRoots() : void {\r\n\t    for (let i = 0; i < roots.length; i++)\r\n\t        roots[i].scan();\r\n\t}\r\n\r\n\tstatic collectRoots() : void {\r\n\t    for (let i = 0; i < roots.length; i++) {\r\n\t        roots[i].buffered = false;\r\n\t        roots[i].collectWhite();\r\n\t    }\r\n\t    roots = [];\r\n\t}\r\n\r\n\tmarkGray() : void {\r\n\t    if (this.color != Color.gray) {\r\n\t        this.color = Color.gray;\r\n\t        let chs = this.children();\r\n\t        for (let i = 0; i < chs.length; i++) {\r\n\t            chs[i].refCountAdj--;\r\n                if (verbose)\r\n                    console.log(\"markGray \"+this.descr());\r\n\t            chs[i].markGray();\r\n            }\r\n\t    }\r\n\t}\r\n\r\n\tscan() : void {\r\n\t    if (verbose)\r\n            console.log(\"scan \"+this.descr());\r\n\t    if (this.color == Color.gray) {\r\n\t        if (this.refCount()+this.refCountAdj > 0)\r\n\t            this.scanBlack();\r\n\t        else {\r\n\t            this.color = Color.white;\r\n                if (verbose)\r\n                    console.log(\"scan WHITE \"+this.descr());\r\n                let chs = this.children();\r\n                for (let i = 0; i < chs.length; i++)\r\n                    chs[i].scan();\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tscanBlack() : void {\r\n\t    this.color = Color.black;\r\n        let chs = this.children();\r\n        for (let i = 0; i < chs.length; i++) {\r\n            chs[i].refCountAdj++;\r\n            if (verbose)\r\n                console.log(\"scanBlack \"+this.descr());\r\n            if (chs[i].color != Color.black)\r\n                chs[i].scanBlack();\r\n        }\r\n\t}\r\n\r\n\tcollectWhite() : void {\r\n\t    if (this.color == Color.white && !this.buffered) {\r\n            if (verbose)\r\n                console.log(\"collectWhite \"+this.descr());\r\n\t        this.color = Color.black;\r\n\t        this.refCountAdj = 0;\r\n            let chs = this.children();\r\n            for (let i = 0; i < chs.length; i++)\r\n                chs[i].collectWhite();\r\n            this.free();\r\n\t    }\r\n\t}\r\n}\r\n","import { Stream } from \"./Stream\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Source } from \"./Vertex\";\r\n\r\nexport class Lambda1<A,B> {\r\n    constructor(f : (a : A) => B,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A) => B;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda1<A,B>(f : (a : A) => B,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda1<A,B>\r\n{\r\n    return new Lambda1(f, deps);\r\n}\r\n\r\nexport function Lambda1_deps<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda1)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda1_toFunction<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : (a : A) => B {\r\n    if (f instanceof Lambda1)\r\n        return f.f;\r\n    else\r\n        return <(a : A) => B>f;\r\n}\r\n\r\nexport class Lambda2<A,B,C> {\r\n    constructor(f : (a : A, b : B) => C,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B) => C;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda2<A,B,C>(f : (a : A, b : B) => C,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda2<A,B,C>\r\n{\r\n    return new Lambda2(f, deps);\r\n}\r\n\r\nexport function Lambda2_deps<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda2)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda2_toFunction<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : (a : A, b : B) => C {\r\n    if (f instanceof Lambda2)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B) => C>f;\r\n}\r\n\r\nexport class Lambda3<A,B,C,D> {\r\n    constructor(f : (a : A, b : B, c : C) => D,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C) => D;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda3<A,B,C,D>(f : (a : A, b : B, c : C) => D,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda3<A,B,C,D>\r\n{\r\n    return new Lambda3(f, deps);\r\n}\r\n\r\nexport function Lambda3_deps<A,B,C,D>(f : ((a : A, b : B, c : C) => D)\r\n        | Lambda3<A,B,C,D>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda3)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda3_toFunction<A,B,C,D>(f : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : (a : A, b : B, c : C) => D {\r\n    if (f instanceof Lambda3)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C) => D>f;\r\n}\r\n\r\nexport class Lambda4<A,B,C,D,E> {\r\n    constructor(f : (a : A, b : B, c : C, d : D) => E,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D) => E;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda4<A,B,C,D,E>(f : (a : A, b : B, c : C, d : D) => E,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda4<A,B,C,D,E>\r\n{\r\n    return new Lambda4(f, deps);\r\n}\r\n\r\nexport function Lambda4_deps<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\r\n        | Lambda4<A,B,C,D,E>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda4)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda4_toFunction<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\r\n        | Lambda4<A,B,C,D,E>) : (a : A, b : B, c : C, d : D) => E {\r\n    if (f instanceof Lambda4)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D) => E>f;\r\n}\r\n\r\nexport class Lambda5<A,B,C,D,E,F> {\r\n    constructor(f : (a : A, b : B, c : C, d : D, e : E) => F,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D, e : E) => F;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda5<A,B,C,D,E,F>(f : (a : A, b : B, c : C, d : D, e : E) => F,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda5<A,B,C,D,E,F>\r\n{\r\n    return new Lambda5(f, deps);\r\n}\r\n\r\nexport function Lambda5_deps<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\r\n        | Lambda5<A,B,C,D,E,F>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda5)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda5_toFunction<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\r\n        | Lambda5<A,B,C,D,E,F>) : (a : A, b : B, c : C, d : D, e : E) => F {\r\n    if (f instanceof Lambda5)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D, e : E) => F>f;\r\n}\r\n\r\nexport class Lambda6<A,B,C,D,E,F,G> {\r\n    constructor(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\r\n                deps : Array<Stream<any>|Cell<any>>) {\r\n        this.f = f;\r\n        this.deps = deps;\r\n    }\r\n    f : (a : A, b : B, c : C, d : D, e : E, f : F) => G;\r\n    deps : Array<Stream<any>|Cell<any>>;\r\n}\r\n\r\nexport function lambda6<A,B,C,D,E,F,G>(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\r\n                deps : Array<Stream<any>|Cell<any>>) : Lambda6<A,B,C,D,E,F,G>\r\n{\r\n    return new Lambda6(f, deps);\r\n}\r\n\r\nexport function Lambda6_deps<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\r\n        | Lambda6<A,B,C,D,E,F,G>) : Array<Stream<any>|Cell<any>> {\r\n    if (f instanceof Lambda6)\r\n        return f.deps;\r\n    else\r\n        return [];\r\n}\r\n\r\nexport function Lambda6_toFunction<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\r\n        | Lambda6<A,B,C,D,E,F,G>) : (a : A, b : B, c : C, d : D, e : E, f : F) => G {\r\n    if (f instanceof Lambda6)\r\n        return f.f;\r\n    else\r\n        return <(a : A, b : B, c : C, d : D, e : E, f : F) => G>f;\r\n}\r\n\r\nexport function toSources(deps : Array<Stream<any>|Cell<any>>) : Source[] {\r\n    const ss : Source[] = [];\r\n    for (let i = 0; i < deps.length; i++) {\r\n        const dep = deps[i];\r\n        ss.push(new Source(dep.getVertex__(), null));\r\n    }\r\n    return ss;\r\n}\r\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         toSources } from \"./Lambda\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { StreamWithSend } from \"./Stream\";\r\nimport { Vertex } from \"./Vertex\";\r\n\r\nexport class CoalesceHandler<A>\r\n{\r\n\tconstructor(f : ((l : A, r : A) => A) | Lambda2<A,A,A>, out : StreamWithSend<A>)\r\n\t{\r\n\t    this.f = Lambda2_toFunction(f);\r\n\t    this.out = out;\r\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(\r\n            toSources(Lambda2_deps(f)));\r\n        this.accumValid = false;\r\n    }\r\n\tprivate f : (l : A, r : A) => A;\r\n\tprivate out : StreamWithSend<A>;\r\n\tprivate accumValid : boolean;\r\n    private accum : A;\r\n    private verbose : boolean;\r\n    send_(a : A) {\r\n        if (this.accumValid)\r\n            this.accum = this.f(this.accum, a);\r\n        else {\r\n            Transaction.currentTransaction.prioritized(this.out.getVertex__(), () => {\r\n                this.out.send_(this.accum);\r\n                this.accumValid = false;\r\n                this.accum = null;\r\n            });\r\n            this.accum = a;\r\n            this.accumValid = true;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * A representation for a value that may not be available until the current\r\n * transaction is closed.\r\n */\r\nexport class Lazy<A> {\r\n    constructor(f : () => A) {\r\n        this.f = f;\r\n    }\r\n\r\n    private f : () => A;\r\n\r\n    /**\r\n     * Get the value if available, throwing an exception if not.\r\n     * In the general case this should only be used in subsequent transactions to\r\n     * when the Lazy was obtained.\r\n     */\r\n    get() : A {\r\n        return this.f();\r\n    }\r\n\r\n    /**\r\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazy's value.\r\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : (a : A) => B) {\r\n        return new Lazy<B>(() => { return f(this.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a binary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift<B,C>(b : Lazy<B>, f : (a : A, b : B) => C) : Lazy<C> {\r\n        return new Lazy<C>(() => { return f(this.f(), b.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a ternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift3<B,C,D>(b : Lazy<B>, c : Lazy<C>, f : (a : A, b : B, c : C) => D) : Lazy<D> {\r\n        return new Lazy<D>(() => { return f(this.f(), b.f(), c.f()); });\r\n    }\r\n\r\n\t/**\r\n\t * Lift a quaternary function into lazy values, so the returned Lazy reflects\r\n     * the value of the function applied to the input Lazys' values.\r\n\t */\r\n    lift4<B,C,D,E>(b : Lazy<B>, c : Lazy<C>, d : Lazy<D>, f : (a : A, b : B, c : C, d : D) => E) : Lazy<E> {\r\n        return new Lazy<E>(() => { return f(this.f(), b.f(), c.f(), d.f()); });\r\n    }\r\n}\r\n","export class Unit {\r\n    static UNIT : Unit = new Unit();\r\n    constructor() {}\r\n}\r\n","import { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { Unit } from \"./Unit\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\n\r\nexport class Operational {\r\n    /**\r\n     * A stream that gives the updates/steps for a {@link Cell}.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    static updates<A>(c : Cell<A>) : Stream<A> {\r\n        /*  Don't think this is needed\r\n        const out = new StreamWithSend<A>(null);\r\n        out.setVertex__(new Vertex(\"updates\", 0, [\r\n                new Source(\r\n                    c.getStream__().getVertex__(),\r\n                    () => {\r\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\r\n                            out.send_(a);\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(\r\n                    c.getVertex__(),\r\n                    () => {\r\n                        return () => { };\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return out;\r\n        */\r\n        return c.getStream__();\r\n    }\r\n\r\n    /**\r\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\r\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\r\n     * firing for each update/step of the cell's value.\r\n     * <P>\r\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n     * API. It breaks the property of non-detectability of cell steps/updates.\r\n     * The rule with this primitive is that you should only use it in functions\r\n     * that do not allow the caller to detect the cell updates.\r\n     */\r\n    static value<A>(c : Cell<A>) : Stream<A> {\r\n        return Transaction.run(() => {\r\n            const sSpark = new StreamWithSend<Unit>();\r\n            Transaction.currentTransaction.prioritized(sSpark.getVertex__(), () => {\r\n                sSpark.send_(Unit.UNIT);\r\n            });\r\n            const sInitial = sSpark.snapshot1(c);\r\n            return Operational.updates(c).orElse(sInitial);\r\n        });\r\n    }\r\n\r\n\t/**\r\n\t * Push each event onto a new transaction guaranteed to come before the next externally\r\n\t * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\r\n\t */\r\n\tstatic defer<A>(s : Stream<A>) : Stream<A> {\r\n\t    return Operational.split<A>(s.map((a : A) => {\r\n\t        return [a];\r\n\t    }));\r\n    }\r\n\r\n\t/**\r\n\t * Push each event in the list onto a newly created transaction guaranteed\r\n\t * to come before the next externally initiated transaction. Note that the semantics\r\n\t * are such that two different invocations of split() can put events into the same\r\n\t * new transaction, so the resulting stream's events could be simultaneous with\r\n\t * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\r\n\t */\r\n\tstatic split<A>(s : Stream<Array<A>>) : Stream<A> {\r\n\t    const out = new StreamWithSend<A>(null);\r\n        out.setVertex__(new Vertex(\"split\", 0, [\r\n                new Source(\r\n                    s.getVertex__(),\r\n                    () => {\r\n                        return s.listen_(out.getVertex__(), (as : Array<A>) => {\r\n                            for (let i = 0; i < as.length; i++) {\r\n                                Transaction.currentTransaction.post(i, () => {\r\n                                    Transaction.run(() => {\r\n                                        out.send_(as[i]);\r\n                                    });\r\n                                });\r\n                            }\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return out;\r\n    }\r\n}\r\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\r\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\r\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\r\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\r\n         toSources, lambda1 } from \"./Lambda\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { Listener } from \"./Listener\";\r\nimport { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Operational } from \"./Operational\";\r\n\r\nclass LazySample<A> {\r\n    constructor(cell : Cell<A>) {\r\n        this.cell = cell;\r\n    }\r\n    cell : Cell<A>;\r\n    hasValue : boolean = false;\r\n    value : A = null;\r\n}\r\n\r\nclass ApplyState<A,B> {\r\n    constructor() {}\r\n    f : (a : A) => B = null;\r\n    f_present : boolean = false;\r\n    a : A = null;\r\n    a_present : boolean = false;\r\n}\r\n\r\nexport class Cell<A> {\r\n\tprivate str : Stream<A>;\r\n\tprotected value : A;\r\n\tprotected valueUpdate : A;\r\n\tprivate cleanup : () => void;\r\n\tprotected lazyInitValue : Lazy<A>;  // Used by LazyCell\r\n\tprivate vertex : Vertex;\r\n\r\n    constructor(initValue : A, str? : Stream<A>) {\r\n        this.value = initValue;\r\n        if (!str) {\r\n            this.str = new Stream<A>();\r\n            this.vertex = new Vertex(\"ConstCell\", 0, []);\r\n        }\r\n        else\r\n            Transaction.run(() => this.setStream(str));\r\n    }\r\n\r\n    protected setStream(str : Stream<A>) {\r\n        this.str = str;\r\n        const me = this,\r\n              src = new Source(\r\n                str.getVertex__(),\r\n                () => {\r\n                    return str.listen_(me.vertex, (a : A) => {\r\n                        if (me.valueUpdate == null) {\r\n                            Transaction.currentTransaction.last(() => {\r\n                                me.value = me.valueUpdate;\r\n                                me.lazyInitValue = null;\r\n                                me.valueUpdate = null;\r\n                            });\r\n                        }\r\n                        me.valueUpdate = a;\r\n                    }, false);\r\n                }\r\n            );\r\n        this.vertex = new Vertex(\"Cell\", 0, [src]);\r\n        // We do a trick here of registering the source for the duration of the current\r\n        // transaction so that we are guaranteed to catch any stream events that\r\n        // occur in the same transaction.\r\n        this.vertex.register(Vertex.NULL);\r\n        Transaction.currentTransaction.last(() => {\r\n            this.vertex.deregister(Vertex.NULL);\r\n        });\r\n    }\r\n\r\n    getVertex__() : Vertex {\r\n        return this.vertex;\r\n    }\r\n\r\n    getStream__() : Stream<A> {  // TO DO: Figure out how to hide this\r\n        return this.str;\r\n    }\r\n\r\n    /**\r\n     * Sample the cell's current value.\r\n     * <p>\r\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\r\n     * miss any updates, but in many circumstances it makes sense.\r\n     * <p>\r\n     * NOTE: In the Java and other versions of Sodium, using sample() inside map(), filter() and\r\n     * merge() is encouraged. In the Javascript/Typescript version, not so much, for the\r\n     * following reason: The memory management is different in the Javascript version, and this\r\n     * requires us to track all dependencies. In order for the use of sample() inside\r\n     * a closure to be correct, the cell that was sample()d inside the closure would have to be\r\n     * declared explicitly using the helpers lambda1(), lambda2(), etc. Because this is\r\n     * something that can be got wrong, we don't encourage this kind of use of sample() in\r\n     * Javascript. Better and simpler to use snapshot().\r\n     * <p>\r\n     * NOTE: If you need to sample() a cell, you have to make sure it's \"alive\" in terms of\r\n     * memory management or it will ignore updates. To make a cell work correctly\r\n     * with sample(), you have to ensure that it's being used. One way to guarantee this is\r\n     * to register a dummy listener on the cell. It will also work to have it referenced\r\n     * by something that is ultimately being listened to.\r\n     */\r\n    sample() : A {\r\n        return Transaction.run(() => { return this.sampleNoTrans__(); });\r\n    }\r\n\r\n    sampleNoTrans__() : A {  // TO DO figure out how to hide this\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\r\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\r\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\r\n     */\r\n    sampleLazy() : Lazy<A> {\r\n        const me = this;\r\n        return Transaction.run(() => me.sampleLazyNoTrans__());\r\n    }\r\n\r\n    sampleLazyNoTrans__() : Lazy<A> {  // TO DO figure out how to hide this\r\n        const me = this,\r\n            s = new LazySample<A>(me);\r\n        Transaction.currentTransaction.sample(() => {\r\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\r\n            s.hasValue = true;\r\n            s.cell = null;\r\n        });\r\n        return new Lazy<A>(() => {\r\n            if (s.hasValue)\r\n                return s.value;\r\n            else\r\n                return s.cell.sample();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the cell's value according to the supplied function, so the returned Cell\r\n     * always reflects the value of the function applied to the input Cell's value.\r\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Cell<B> {\r\n        const c = this;\r\n        return Transaction.run(() =>\r\n            Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda1_toFunction(f)))\r\n        );\r\n    }\r\n\r\n\t/**\r\n\t * Lift a binary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift<B,C>(b : Cell<B>,\r\n\t          fn0 : ((a : A, b : B) => C) |\r\n\t                Lambda2<A,B,C>) : Cell<C> {\r\n        const fn = Lambda2_toFunction(fn0),\r\n            cf = this.map((aa : A) => (bb : B) => fn(aa, bb));\r\n        return Cell.apply(cf, b,\r\n            toSources(Lambda2_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a ternary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift3<B,C,D>(b : Cell<B>, c : Cell<C>,\r\n\t             fn0 : ((a : A, b : B, c : C) => D) |\r\n\t                   Lambda3<A,B,C,D>) : Cell<D> {\r\n        const fn = Lambda3_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => D =\r\n                 (aa : A) => (bb : B) => (cc : C) => fn(aa, bb, cc),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply<B, (c : C) => D>(cf, b),\r\n                   c,\r\n                   toSources(Lambda3_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a quaternary function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\r\n\t               fn0 : ((a : A, b : B, c : C, d : D) => E) |\r\n\t                     Lambda4<A,B,C,D,E>) : Cell<E> {\r\n        const fn = Lambda4_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => E =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => fn(aa, bb, cc, dd),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply<B, (c : C) => (d : D) => E>(cf, b),\r\n                       c),\r\n                   d,\r\n                   toSources(Lambda4_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\r\n\t                 fn0 : ((a : A, b : B, c : C, d : D, e : E) => F) |\r\n\t                       Lambda5<A,B,C,D,E,F>) : Cell<F> {\r\n        const fn = Lambda5_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => F =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => fn(aa, bb, cc, dd, ee),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply(\r\n                           Cell.apply<B, (c : C) => (d : D) => (e : E) => F>(cf, b),\r\n                           c),\r\n                       d),\r\n                   e,\r\n                   toSources(Lambda5_deps(fn0)));\r\n\t}\r\n\r\n\t/**\r\n\t * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\r\n\t * function applied to the input cells' values.\r\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t */\r\n\tlift6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\r\n\t                   fn0 : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) |\r\n\t                         Lambda6<A,B,C,D,E,F,G>) : Cell<G> {\r\n        const fn = Lambda6_toFunction(fn0),\r\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => G =\r\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => fn(aa, bb, cc, dd, ee, ff),\r\n            cf = this.map(mf);\r\n        return Cell.apply(\r\n                   Cell.apply(\r\n                       Cell.apply(\r\n                           Cell.apply(\r\n                               Cell.apply<B, (c : C) => (d : D) => (e : E) => (f : F) => G>(cf, b),\r\n                               c),\r\n                           d),\r\n                       e),\r\n                   f,\r\n                   toSources(Lambda6_deps(fn0)));\r\n    }\r\n\r\n    /**\r\n     * High order depenency tracing. If any newly created sodium objects within a value of a cell of a sodium object\r\n     * happen to accumulate state, this method will keep the accumulation of state up to date.\r\n     */\r\n    public trace(extractor: (a: A) => (Stream<any>|Cell<any>)[]) : Cell<A> {\r\n        let cKeepAlive = Cell.switchC(this.map(\r\n            a =>\r\n                Cell.liftArray(\r\n                    extractor(a).map(\r\n                        x => {\r\n                            if (x instanceof Stream) {\r\n                                return x.hold({} as any);\r\n                            } else {\r\n                                return x;\r\n                            }\r\n                        }\r\n                    )\r\n                )\r\n        ));\r\n        return this.map(lambda1(a => a, [cKeepAlive]));\r\n    }\r\n\r\n    /**\r\n     * Lift an array of cells into a cell of an array.\r\n     */\r\n    public static liftArray<A>(ca : Cell<A>[]) : Cell<A[]> {\r\n        return Cell._liftArray(ca, 0, ca.length);\r\n    }\r\n\r\n    private static _liftArray<A>(ca : Cell<A>[], fromInc: number, toExc: number) : Cell<A[]> {\r\n        if (toExc - fromInc == 0) {\r\n            return new Cell<A[]>([]);\r\n        } else if (toExc - fromInc == 1) {\r\n            return ca[fromInc].map(a => [a]);\r\n        } else {\r\n            let pivot = Math.floor((fromInc + toExc) / 2);\r\n            // the thunk boxing/unboxing here is a performance hack for lift when there are simutaneous changing cells.\r\n            return Cell._liftArray(ca, fromInc, pivot).lift(\r\n                    Cell._liftArray(ca, pivot, toExc),\r\n                    (array1, array2) => () => array1.concat(array2)\r\n                )\r\n                .map(x => x());\r\n        }\r\n    }\r\n\r\n\t/**\r\n\t * Apply a value inside a cell to a function inside a cell. This is the\r\n\t * primitive for all function lifting.\r\n\t */\r\n\tstatic apply<A,B>(cf : Cell<(a : A) => B>, ca : Cell<A>, sources? : Source[]) : Cell<B> {\r\n    \treturn Transaction.run(() => {\r\n    \t    const state = new ApplyState<A,B>(),\r\n                out = new StreamWithSend<B>(),\r\n                cf_value = Operational.value(cf),\r\n                ca_value = Operational.value(ca),\r\n                src1 = new Source(\r\n                        cf_value.getVertex__(),\r\n                        () => {\r\n                            return cf_value.listen_(out.getVertex__(), (f : (a : A) => B) => {\r\n                                state.f = f;\r\n                                state.f_present = true;\r\n                                if (state.a_present)\r\n                                    out.send_(state.f(state.a));\r\n                            }, false);\r\n                        }\r\n                    ),\r\n                src2 = new Source(\r\n                        ca_value.getVertex__(),\r\n                        () => {\r\n                            return ca_value.listen_(out.getVertex__(), (a : A) => {\r\n                                state.a = a;\r\n                                state.a_present = true;\r\n                                if (state.f_present)\r\n                                    out.send_(state.f(state.a));\r\n                            }, false);\r\n                        }\r\n                    );\r\n            out.setVertex__(new Vertex(\"apply\", 0,\r\n                [src1, src2].concat(sources ? sources : [])\r\n            ));\r\n            return out.coalesce__((l, r) => r).holdLazy(new Lazy<B>(() =>\r\n                    cf.sampleNoTrans__()(ca.sampleNoTrans__())\r\n                ));\r\n        });\r\n\t}\r\n\r\n\t/**\r\n\t * Unwrap a cell inside another cell to give a time-varying cell implementation.\r\n\t */\r\n    static switchC<A>(cca : Cell<Cell<A>>) : Cell<A> {\r\n\t    return Transaction.run(() => {\r\n            const za = cca.sampleLazy().map((ba : Cell<A>) => ba.sample()),\r\n                out = new StreamWithSend<A>();\r\n            let last_ca : Cell<A> = null;\r\n            const cca_value = Operational.value(cca),\r\n                  src = new Source(\r\n                        cca_value.getVertex__(),\r\n                        () => {\r\n                            let kill2 : () => void = last_ca === null ? null :\r\n                                    Operational.value(last_ca).listen_(out.getVertex__(),\r\n                                        (a : A) => out.send_(a), false);\r\n                            const kill1 = cca_value.listen_(out.getVertex__(), (ca : Cell<A>) => {\r\n                                // Note: If any switch takes place during a transaction, then the\r\n                                // coalesce__() below will always cause a sample to be fetched\r\n                                // from the one we just switched to. So anything from the old input cell\r\n                                // that might have happened during this transaction will be suppressed.\r\n                                last_ca = ca;\r\n                                if (kill2 !== null)\r\n                                    kill2();\r\n                                kill2 = Operational.value(ca).listen_(out.getVertex__(),\r\n                                    (a : A) => out.send_(a), false);\r\n                            }, false);\r\n                            return () => { kill1(); kill2(); };\r\n                        }\r\n                    );\r\n            out.setVertex__(new Vertex(\"switchC\", 0, [src]));\r\n            return out.coalesce__((l, r) => r).holdLazy(za);\r\n        });\r\n\t}\r\n\r\n\t/**\r\n\t * Unwrap a stream inside a cell to give a time-varying stream implementation.\r\n\t */\r\n\tstatic switchS<A>(csa : Cell<Stream<A>>) : Stream<A> {\r\n\t    return Transaction.run(() => {\r\n            const out = new StreamWithSend<A>(),\r\n                  h2 = (a : A) => {\r\n                          out.send_(a);\r\n                      },\r\n                  src = new Source(\r\n                      csa.getVertex__(),\r\n                      () => {\r\n                          let kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\r\n                          const kill1 = csa.getStream__().listen_(out.getVertex__(), (sa : Stream<A>) => {\r\n                              kill2();\r\n                              kill2 = sa.listen_(out.getVertex__(), h2, true);\r\n                          }, false);\r\n                          return () => { kill1(); kill2(); };\r\n                      }\r\n                  );\r\n\t        out.setVertex__(new Vertex(\"switchS\", 0, [src]));\r\n\t        return out;\r\n\t    });\r\n    }\r\n\r\n\t/**\r\n\t * Listen for updates to the value of this cell. This is the observer pattern. The\r\n\t * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\r\n\t * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\r\n\t * the world of I/O and for FRP.\r\n\t * @param h The handler to execute when there's a new value.\r\n\t *   You should make no assumptions about what thread you are called on, and the\r\n\t *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\r\n\t *   or {@link StreamSink#send(Object)} in the handler.\r\n\t *   An exception will be thrown, because you are not meant to use this to create\r\n\t *   your own primitives.\r\n     */\r\n    listen(h : (a : A) => void) : () => void {\r\n        return Transaction.run(() => {\r\n            return Operational.value(this).listen(h);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Cell satisfies the Functor, Apply, Applicative categories\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n\r\n    //of :: Applicative f => a -> f a\r\n    static 'fantasy-land/of'<A>(a:A):Cell<A> {\r\n      return new Cell<A>(a);\r\n    }\r\n\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Cell<B> {\r\n      return this.map(f);\r\n    }\r\n\r\n    //ap :: Apply f => f a ~> f (a -> b) -> f b\r\n    'fantasy-land/ap'<B>(cf: Cell<(a : A) => B>):Cell<B> {\r\n        return Cell.apply(cf, this);\r\n    }\r\n}\r\n","import { Source, Vertex } from \"./Vertex\";\r\n\r\nexport class Listener<A> {\r\n    constructor(h : (a : A) => void, target : Vertex) {\r\n        this.h = h;\r\n        this.target = target;\r\n    }\r\n    h : (a : A) => void;\r\n    target : Vertex;\r\n}\r\n","import { Lazy } from \"./Lazy\";\r\nimport { Cell } from \"./Cell\";\r\nimport { Stream } from \"./Stream\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\nexport class LazyCell<A> extends Cell<A> {\r\n    constructor(lazyInitValue : Lazy<A>, str? : Stream<A>) {\r\n        super(null, null);\r\n        Transaction.run(() => {\r\n            if (str)\r\n                this.setStream(str);\r\n            this.lazyInitValue = lazyInitValue;\r\n        });\r\n    }\r\n\r\n    sampleNoTrans__() : A {  // Override\r\n        if (this.value == null && this.lazyInitValue != null) {\r\n            this.value = this.lazyInitValue.get();\r\n            this.lazyInitValue = null;\r\n        }\r\n        return this.value;\r\n    }\r\n}\r\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\r\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\r\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\r\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\r\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\r\n         toSources } from \"./Lambda\";\r\nimport { Source, Vertex } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { CoalesceHandler } from \"./CoalesceHandler\";\r\nimport { Cell } from \"./Cell\";\r\n//import { StreamLoop } from \"./StreamLoop\";\r\nimport { Listener } from \"./Listener\";\r\nimport { Tuple2 } from \"./Tuple2\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { LazyCell } from \"./LazyCell\";\r\nimport * as Z from \"sanctuary-type-classes\";\r\n\r\nexport class Stream<A> {\r\n    constructor(vertex? : Vertex) {\r\n        this.vertex = vertex ? vertex : new Vertex(\"Stream\", 0, []);\r\n    }\r\n\r\n    getVertex__() : Vertex {\r\n        return this.vertex;\r\n    }\r\n\r\n    protected vertex : Vertex;\r\n    protected listeners : Array<Listener<A>> = [];\r\n    protected firings : A[] = [];\r\n\r\n    /**\r\n     * Transform the stream's event values according to the supplied function, so the returned\r\n     * Stream's event values reflect the value of the function applied to the input\r\n     * Stream's event values.\r\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        const ff = Lambda1_toFunction(f);\r\n        out.vertex = new Vertex(\"map\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a));\r\n                        }, false);\r\n                    }\r\n                )\r\n            ].concat(toSources(Lambda1_deps(f)))\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform the stream's event values into the specified constant value.\r\n     * @param b Constant value.\r\n     */\r\n    mapTo<B>(b : B) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        out.vertex = new Vertex(\"mapTo\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(b);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\r\n     * in the simultaneous case.\r\n     * <p>\r\n     * In the case where two events are simultaneous (i.e. both\r\n     * within the same transaction), the event from <em>this</em> will take precedence, and\r\n     * the event from <em>s</em> will be dropped.\r\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\r\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\r\n     * <p>\r\n     * The name orElse() is used instead of merge() to make it really clear that care should\r\n     * be taken, because events can be dropped.\r\n     */\r\n    orElse(s : Stream<A>) : Stream<A> {\r\n        return this.merge(s, (left : A, right: A) => {\r\n            return left;\r\n        });\r\n    }\r\n\r\n    private merge_(s : Stream<A>) : Stream<A> {\r\n        const out = new StreamWithSend<A>();\r\n        const left = new Vertex(\"merge\", 0, []);\r\n        left.sources.push(new Source(this.vertex, () => {\r\n            return this.listen_(left, (a : A) => {\r\n                    out.send_(a);\r\n                }, false);\r\n        }));\r\n        out.vertex.sources = out.vertex.sources.concat([\r\n                new Source(\r\n                    left,\r\n                    () => {\r\n                        left.register(out.vertex);\r\n                        return () => { left.deregister(out.vertex); }\r\n                    }\r\n                ),\r\n                new Source(\r\n                    s.vertex,\r\n                    () => {\r\n                        return s.listen_(out.vertex, (a : A) => {\r\n                            out.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]);\r\n        return out;\r\n    }\r\n\r\n    coalesce__(f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {  // TO DO figure out how to hide this\r\n        const out = new StreamWithSend<A>();\r\n        const coalescer = new CoalesceHandler<A>(f, out);\r\n        out.vertex.sources = out.vertex.sources.concat([\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            coalescer.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]).concat(toSources(Lambda2_deps(f)));\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Merge two streams of the same type into one, so that events on either input appear\r\n     * on the returned stream.\r\n     * <p>\r\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\r\n     * occurring in the same transaction), combine them into one using the specified combining function\r\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\r\n     * The event from <em>this</em> will appear at the left input of the combining function, and\r\n     * the event from <em>s</em> will appear at the right.\r\n     * @param f Function to combine the values. It may construct FRP logic or use\r\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    merge(s : Stream<A>, f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {\r\n        return Transaction.run<Stream<A>>(() => {\r\n            return this.merge_(s).coalesce__(f);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events for which the predicate returns true.\r\n     */\r\n    filter(f : ((a : A) => boolean) | Lambda1<A,boolean>) : Stream<A> {\r\n        const out = new StreamWithSend<A>(null);\r\n        const ff = Lambda1_toFunction(f);\r\n        out.vertex = new Vertex(\"filter\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            if (ff(a))\r\n                                out.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ].concat(toSources(Lambda1_deps(f)))\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events that have present\r\n     * values, discarding null values.\r\n     */\r\n    filterNotNull() : Stream<A> {\r\n        const out = new StreamWithSend<A>(null);\r\n        out.vertex = new Vertex(\"filterNotNull\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            if (a !== null)\r\n                                out.send_(a);\r\n                        }, false);\r\n                    }\r\n                )\r\n            ]\r\n        );\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Return a stream that only outputs events from the input stream\r\n     * when the specified cell's value is true.\r\n     */\r\n    gate(c : Cell<boolean>) : Stream<A> {\r\n        return this.snapshot(c, (a : A, pred : boolean) => {\r\n            return pred ? a : null;\r\n        }).filterNotNull();\r\n    }\r\n\r\n\t/**\r\n\t * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\r\n\t * at the time of the event firing, ignoring the stream's value.\r\n\t */\r\n\tsnapshot1<B>(c : Cell<B>) : Stream<B> {\r\n        const out = new StreamWithSend<B>(null);\r\n        out.vertex = new Vertex(\"snapshot1\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(c.sampleNoTrans__());\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(c.getVertex__(), null)\r\n            ]\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cell at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot<B,C>(b : Cell<B>, f_ : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Stream<C>\r\n\t{\r\n        const out = new StreamWithSend<C>(null);\r\n        const ff = Lambda2_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null)\r\n            ].concat(toSources(Lambda2_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot3<B,C,D>(b : Cell<B>, c : Cell<C>, f_ : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : Stream<D>\r\n\t{\r\n        const out = new StreamWithSend<D>(null);\r\n        const ff = Lambda3_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null)\r\n            ].concat(toSources(Lambda3_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D) => E) | Lambda4<A,B,C,D,E>) : Stream<E>\r\n\t{\r\n        const out = new StreamWithSend<E>(null);\r\n        const ff = Lambda4_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null)\r\n            ].concat(toSources(Lambda4_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E) => F) | Lambda5<A,B,C,D,E,F>) : Stream<F>\r\n\t{\r\n        const out = new StreamWithSend<F>(null);\r\n        const ff = Lambda5_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__(), e.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null),\r\n                new Source(e.getVertex__(), null)\r\n            ].concat(toSources(Lambda5_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a stream whose events are the result of the combination using the specified\r\n\t * function of the input stream's event value and the value of the cells at that time.\r\n     * <P>\r\n     * There is an implicit delay: State updates caused by event firings being held with\r\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n     * the following transaction. To put this another way, snapshot()\r\n     * always sees the value of a cell as it was before any state changes from the current\r\n     * transaction.\r\n     */\r\n\tsnapshot6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\r\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) | Lambda6<A,B,C,D,E,F,G>) : Stream<G>\r\n\t{\r\n        const out = new StreamWithSend<G>(null);\r\n        const ff = Lambda6_toFunction(f_);\r\n        out.vertex = new Vertex(\"snapshot\", 0, [\r\n                new Source(\r\n                    this.vertex,\r\n                    () => {\r\n                        return this.listen_(out.vertex, (a : A) => {\r\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\r\n                                            d.sampleNoTrans__(), e.sampleNoTrans__(),\r\n                                            f.sampleNoTrans__()));\r\n                        }, false);\r\n                    }\r\n                ),\r\n                new Source(b.getVertex__(), null),\r\n                new Source(c.getVertex__(), null),\r\n                new Source(d.getVertex__(), null),\r\n                new Source(e.getVertex__(), null),\r\n                new Source(f.getVertex__(), null)\r\n            ].concat(toSources(Lambda6_deps(f_)))\r\n        );\r\n        return out;\r\n\t}\r\n\r\n\t/**\r\n\t * Create a {@link Cell} with the specified initial value, that is updated\r\n     * by this stream's event values.\r\n     * <p>\r\n     * There is an implicit delay: State updates caused by event firings don't become\r\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\r\n     * until the following transaction. To put this another way,\r\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\r\n     * any state changes from the current transaction.\r\n     */\r\n    hold(initValue : A) : Cell<A> {\r\n        return new Cell<A>(initValue, this);\r\n\t}\r\n\r\n\t/**\r\n\t * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\r\n\t */\r\n\tholdLazy(initValue : Lazy<A>) : Cell<A> {\r\n\t    return new LazyCell<A>(initValue, this);\r\n\t}\r\n\r\n    /**\r\n     * Transform an event with a generalized state loop (a Mealy machine). The function\r\n     * is passed the input and the old state and returns the new state and output value.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    collect<B,S>(initState : S, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\r\n        return this.collectLazy(new Lazy<S>(() => { return initState; }), f);\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    collectLazy<B,S>(initState : Lazy<S>, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\r\n        const ea = this;\r\n        return Transaction.run(() => {\r\n            const es = new StreamLoop<S>(),\r\n                s = es.holdLazy(initState),\r\n                ebs = ea.snapshot(s, f),\r\n                eb = ebs.map((bs : Tuple2<B,S>) => { return bs.a; }),\r\n                es_out = ebs.map((bs : Tuple2<B,S>) => { return bs.b; });\r\n            es.loop(es_out);\r\n            return eb;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Accumulate on input event, outputting the new state each time.\r\n     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n     */\r\n    accum<S>(initState : S, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\r\n        return this.accumLazy(new Lazy<S>(() => { return initState; }), f);\r\n    }\r\n\r\n    /**\r\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\r\n     * {@link Cell#sampleLazy()}.\r\n     */\r\n    accumLazy<S>(initState : Lazy<S>, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\r\n        const ea = this;\r\n        return Transaction.run(() => {\r\n            const es = new StreamLoop<S>(),\r\n                s = es.holdLazy(initState),\r\n                es_out = ea.snapshot(s, f);\r\n            es.loop(es_out);\r\n            return es_out.holdLazy(initState);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return a stream that outputs only one value: the next event of the\r\n     * input stream, starting from the transaction in which once() was invoked.\r\n     */\r\n    once() : Stream<A> {\r\n    /*\r\n        return Transaction.run(() => {\r\n            const ev = this,\r\n                out = new StreamWithSend<A>();\r\n            let la : () => void = null;\r\n            la = ev.listen_(out.vertex, (a : A) => {\r\n                if (la !== null) {\r\n                    out.send_(a);\r\n                    la();\r\n                    la = null;\r\n                }\r\n            }, false);\r\n            return out;\r\n        });\r\n        */\r\n        // We can't use the implementation above, beacuse deregistering\r\n        // listeners triggers the exception\r\n        // \"send() was invoked before listeners were registered\"\r\n        // We can revisit this another time. For now we will use the less\r\n        // efficient implementation below.\r\n        const me = this;\r\n        return Transaction.run(() => me.gate(me.mapTo(false).hold(true)));\r\n    }\r\n\r\n    listen(h : (a : A) => void) : () => void {\r\n        return Transaction.run<() => void>(() => {\r\n            return this.listen_(Vertex.NULL, h, false);\r\n        });\r\n    }\r\n\r\n    listen_(target : Vertex,\r\n            h : (a : A) => void,\r\n            suppressEarlierFirings : boolean) : () => void {\r\n        if (this.vertex.register(target))\r\n            Transaction.currentTransaction.requestRegen();\r\n        const listener = new Listener<A>(h, target);\r\n        this.listeners.push(listener);\r\n        if (!suppressEarlierFirings && this.firings.length != 0) {\r\n            const firings = this.firings.slice();\r\n            Transaction.currentTransaction.prioritized(target, () => {\r\n                // Anything sent already in this transaction must be sent now so that\r\n                // there's no order dependency between send and listen.\r\n                for (let i = 0; i < firings.length; i++)\r\n                    h(firings[i]);\r\n            });\r\n        }\r\n        return () => {\r\n            let removed = false;\r\n            for (let i = 0; i < this.listeners.length; i++) {\r\n                if (this.listeners[i] == listener) {\r\n                    this.listeners.splice(i, 1);\r\n                    removed = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (removed)\r\n                this.vertex.deregister(target);\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Fantasy-land Algebraic Data Type Compatability.\r\n     * Stream satisfies the Functor and Monoid Categories (and hence Semigroup)\r\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\r\n     */\r\n\r\n    //map :: Functor f => f a ~> (a -> b) -> f b\r\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Stream<B> {\r\n      return this.map(f);\r\n    }\r\n\r\n    //concat :: Semigroup a => a ~> a -> a\r\n    'fantasy-land/concat'(a:Stream<A>) : Stream<A> {\r\n      return this.merge(a, (left:any, right) => {\r\n        return (Z.Semigroup.test(left)) ? Z.concat(left, right) : left;\r\n      });\r\n    }\r\n\r\n    //empty :: Monoid m => () -> m\r\n    'fantasy-land/empty'() : Stream<A> {\r\n      return new Stream<A>();\r\n    }\r\n}\r\n\r\nexport class StreamWithSend<A> extends Stream<A> {\r\n    constructor(vertex? : Vertex) {\r\n        super(vertex);\r\n    }\r\n\r\n    setVertex__(vertex : Vertex) {  // TO DO figure out how to hide this\r\n        this.vertex = vertex;\r\n    }\r\n\r\n    send_(a : A) : void {\r\n        // We throw this error if we send into FRP logic that has been constructed\r\n        // but nothing is listening to it yet. We need to do it this way because\r\n        // it's the only way to manage memory in a language with no finalizers.\r\n        if (this.vertex.refCount() == 0)\r\n            throw new Error(\"send() was invoked before listeners were registered\");\r\n\t\tif (this.firings.length == 0)\r\n\t\t\tTransaction.currentTransaction.last(() => {\r\n\t\t\t    this.firings = [];\r\n            });\r\n\t\tthis.firings.push(a);\r\n\t\tconst listeners = this.listeners.slice();\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const h = listeners[i].h;\r\n            Transaction.currentTransaction.prioritized(listeners[i].target, () => {\r\n                Transaction.currentTransaction.inCallback++;\r\n                try {\r\n                    h(a);\r\n                    Transaction.currentTransaction.inCallback--;\r\n                }\r\n                catch (err) {\r\n                    Transaction.currentTransaction.inCallback--;\r\n                    throw err;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\r\n */\r\nexport class StreamLoop<A> extends StreamWithSend<A> {\r\n    assigned__ : boolean = false;  // to do: Figure out how to hide this\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n        this.vertex.name = \"StreamLoop\";\r\n    \tif (Transaction.currentTransaction === null)\r\n    \t    throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\r\n    }\r\n\r\n    /**\r\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    loop(sa_out : Stream<A>) : void {\r\n        if (this.assigned__)\r\n            throw new Error(\"StreamLoop looped more than once\");\r\n        this.assigned__ = true;\r\n        this.vertex.addSource(\r\n            new Source(\r\n                sa_out.getVertex__(),\r\n                () => {\r\n                    return sa_out.listen_(this.vertex, (a : A) => {\r\n                        this.send_(a);\r\n                    }, false);\r\n                }\r\n            )\r\n        );\r\n    }\r\n}\r\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\r\nimport { StreamWithSend } from \"./Stream\";\r\nimport { CoalesceHandler } from \"./CoalesceHandler\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\n/**\r\n * A stream that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\r\n * should downcast to {@link Stream}.\r\n */\r\nexport class StreamSink<A> extends StreamWithSend<A> {\r\n    constructor(f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\r\n        super();\r\n        if (!f)\r\n            f = <(l : A, r : A) => A>((l : A, r : A) => {\r\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\r\n            });\r\n        this.coalescer = new CoalesceHandler<A>(f, this);\r\n    }\r\n\r\n    private coalescer : CoalesceHandler<A>;\r\n\r\n    send(a : A) : void {\r\n        Transaction.run<void>(\r\n            () => {\r\n                if (Transaction.currentTransaction.inCallback > 0)\r\n                    throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\r\n                this.coalescer.send_(a);\r\n            }\r\n        )\r\n    }\r\n}\r\n","import { Cell } from \"./Cell\";\r\nimport { Lazy } from \"./Lazy\";\r\nimport { LazyCell } from \"./LazyCell\";\r\nimport { Transaction } from \"./Transaction\";\r\nimport { StreamLoop } from \"./Stream\";\r\n\r\n/**\r\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\r\n */\r\nexport class CellLoop<A> extends LazyCell<A> {\r\n    constructor() {\r\n    \tsuper(null, new StreamLoop<A>());\r\n    }\r\n\r\n    /**\r\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\r\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\r\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n     * or {@link Transaction#runVoid(Runnable)}.\r\n     */\r\n    loop(a_out : Cell<A>) : void {\r\n        const me = this;\r\n        Transaction.run(() => {\r\n            (<StreamLoop<A>>me.getStream__()).loop(a_out.getStream__());\r\n            me.lazyInitValue = a_out.sampleLazy();\r\n        });\r\n    }\r\n\r\n    sampleNoTrans__() : A\r\n    {\r\n        if (!(<StreamLoop<A>>this.getStream__()).assigned__)\r\n            throw new Error(\"CellLoop sampled before it was looped\");\r\n        return super.sampleNoTrans__();\r\n    }\r\n}\r\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\r\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\r\nimport { Cell } from \"./Cell\";\r\nimport { StreamSink } from \"./StreamSink\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\n/**\r\n * A cell that allows values to be pushed into it, acting as an interface between the\r\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\r\n * should downcast to {@link Cell}.\r\n */\r\nexport class CellSink<A> extends Cell<A> {\r\n    /**\r\n     * Construct a writable cell with the specified initial value. If multiple values are\r\n     * sent in the same transaction, the specified function is used to combine them.\r\n     *\r\n     * If the function is not supplied, then an exception will be thrown in this case.\r\n     */\r\n    constructor(initValue : A, f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\r\n    \tsuper(initValue, new StreamSink<A>(f));\r\n    }\r\n\r\n    /**\r\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\r\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\r\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\r\n     * You are not meant to use this to define your own primitives.\r\n     * @param a Value to push into the cell.\r\n     */\r\n    send(a : A) : void {\r\n        (<StreamSink<A>>this.getStream__()).send(a);\r\n    }\r\n}\r\n","export class Tuple2<A,B> {\r\n    constructor(a : A, b : B) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    a : A;\r\n    b : B;\r\n}\r\n","import { Vertex, Source } from \"./Vertex\";\r\nimport * as Collections from 'typescript-collections';\r\nimport { Stream, StreamWithSend } from \"./Stream\";\r\nimport { StreamSink } from \"./StreamSink\";\r\nimport { Cell } from \"./Cell\";\r\nimport { CellSink } from \"./CellSink\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\n/**\r\n * An interface for implementations of FRP timer systems.\r\n */\r\nexport abstract class TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    abstract setTimer(t : number, callback : () => void) : () => void;\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    abstract now() : number;\r\n}\r\n\r\nlet nextSeq : number = 0;\r\n\r\nclass Event {\r\n    constructor(t : number, sAlarm : StreamWithSend<number>) {\r\n        this.t = t;\r\n        this.sAlarm = sAlarm;\r\n        this.seq = ++nextSeq;\r\n    }\r\n    t : number;\r\n    sAlarm : StreamWithSend<number>;\r\n    seq : number;  // Used to guarantee uniqueness\r\n}\r\n\r\nexport class TimerSystem {\r\n    constructor(impl : TimerSystemImpl) {\r\n        Transaction.run(() => {\r\n            this.impl = impl;\r\n            this.tMinimum = 0;\r\n            const timeSnk = new CellSink<number>(impl.now());\r\n            this.time = timeSnk;\r\n            // A dummy listener to time to keep it alive even when there are no other listeners.\r\n            this.time.listen((t : number) => { });\r\n            Transaction.onStart(() => {\r\n                // Ensure the time is always increasing from the FRP's point of view.\r\n                const t = this.tMinimum = Math.max(this.tMinimum, impl.now());\r\n                // Pop and execute all events earlier than or equal to t (the current time).\r\n                while (true) {\r\n                    let ev : Event = null;\r\n                    if (!this.eventQueue.isEmpty()) {\r\n                        let mev = this.eventQueue.minimum();\r\n                        if (mev.t <= t) {\r\n                            ev = mev;\r\n                            // TO DO: Detect infinite loops!\r\n                        }\r\n                    }\r\n                    if (ev != null) {\r\n                        timeSnk.send(ev.t);\r\n                        Transaction.run(() => ev.sAlarm.send_(ev.t));\r\n                    }\r\n                    else\r\n                        break;\r\n                }\r\n                timeSnk.send(t);\r\n            });\r\n        });\r\n    }\r\n\r\n    private impl : TimerSystemImpl;\r\n    private tMinimum : number;  // A guard to allow us to guarantee that the time as\r\n                                // seen by the FRP is always increasing.\r\n\r\n    /**\r\n     * A cell giving the current clock time.\r\n     */\r\n    time : Cell<number>;\r\n\r\n    private eventQueue : Collections.BSTree<Event> = new Collections.BSTree<Event>((a, b) => {\r\n        if (a.t < b.t) return -1;\r\n        if (a.t > b.t) return 1;\r\n        if (a.seq < b.seq) return -1;\r\n        if (a.seq > b.seq) return 1;\r\n        return 0;\r\n    });\r\n\r\n    /**\r\n     * A timer that fires at the specified time, which can be null, meaning\r\n     * that the alarm is not set.\r\n     */\r\n    at(tAlarm : Cell<number>) : Stream<number> {\r\n        let current : Event = null,\r\n            cancelCurrent : () => void = null,\r\n            active : boolean = false,\r\n            tAl : number = null,\r\n            sampled : boolean = false;\r\n        const sAlarm = new StreamWithSend<number>(null),\r\n            updateTimer = () => {\r\n                if (cancelCurrent !== null) {\r\n                    cancelCurrent();\r\n                    this.eventQueue.remove(current);\r\n                }\r\n                cancelCurrent = null;\r\n                current = null;\r\n                if (active) {\r\n                    if (!sampled) {\r\n                        sampled = true;\r\n                        tAl = tAlarm.sampleNoTrans__();\r\n                    }\r\n                    if (tAl !== null) {\r\n                        current = new Event(tAl, sAlarm);\r\n                        this.eventQueue.add(current);\r\n                        cancelCurrent = this.impl.setTimer(tAl, () => {\r\n                                    // Correction to ensure the clock time appears to be >= the\r\n                                    // alarm time. It can be a few milliseconds early, and\r\n                                    // this breaks things otherwise, because it doesn't think\r\n                                    // it's time to fire the alarm yet.\r\n                                    this.tMinimum = Math.max(this.tMinimum, tAl);\r\n                                    // Open and close a transaction to trigger queued\r\n                                    // events to run.\r\n                                    Transaction.run(() => {});\r\n                                });\r\n                    }\r\n                }\r\n            };\r\n        sAlarm.setVertex__(new Vertex(\"at\", 0, [\r\n                new Source(\r\n                    tAlarm.getVertex__(),\r\n                    () => {\r\n                        active = true;\r\n                        sampled = false;\r\n                        Transaction.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\r\n                        const kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), (oAlarm : number) => {\r\n                            tAl = oAlarm;\r\n                            sampled = true;\r\n                            updateTimer();\r\n                        }, false);\r\n                        return () => {\r\n                            active = false;\r\n                            updateTimer();\r\n                            kill();\r\n                        };\r\n                    }\r\n                )\r\n            ]\r\n        ));\r\n        return sAlarm;\r\n    }\r\n}\r\n\r\n","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\r\n\r\n/**\r\n * A timer system implementation using seconds as the time unit.\r\n */\r\nexport class SecondsTimerSystem extends TimerSystem {\r\n    constructor() {\r\n        super(new SecondsTimerSystemImpl());\r\n    }\r\n}\r\n\r\nclass SecondsTimerSystemImpl extends TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    setTimer(t : number, callback : () => void) : () => void\r\n    {\r\n        let timeout = setTimeout(callback, Math.max((t - this.now()) * 1000, 0));\r\n        return () => { clearTimeout(timeout); }\r\n    }\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    now() : number\r\n    {\r\n        return Date.now() * 0.001;\r\n    }\r\n}\r\n","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\r\n\r\n/**\r\n * A timer system implementation using milliseconds as the time unit.\r\n */\r\nexport class MillisecondsTimerSystem extends TimerSystem {\r\n    constructor() {\r\n        super(new MillisecondsTimerSystemImpl());\r\n    }\r\n}\r\n\r\nclass MillisecondsTimerSystemImpl extends TimerSystemImpl {\r\n    /**\r\n     * Set a timer that will execute the specified callback at the specified time.\r\n     * @return A function that can be used to cancel the timer.\r\n     */\r\n    setTimer(t : number, callback : () => void) : () => void\r\n    {\r\n        let timeout = setTimeout(callback, Math.max(t - this.now(), 0));\r\n        return () => { clearTimeout(timeout); }\r\n    }\r\n\r\n    /**\r\n     * Return the current clock time.\r\n     */\r\n    now() : number\r\n    {\r\n        return Date.now();\r\n    }\r\n}\r\n","import { Stream, StreamWithSend } from \"./Stream\";\r\nimport { Vertex, Source } from \"./Vertex\";\r\nimport { Transaction } from \"./Transaction\";\r\n\r\nexport class IOAction {\r\n    /*!\r\n     * Convert a function that performs asynchronous I/O taking input A\r\n     * and returning a value of type B into an I/O action of type\r\n     * (sa : Stream<A>) => Stream<B>\r\n     */\r\n    static fromAsync<A,B>(performIO : (a : A, result : (b : B) => void) => void)\r\n            : (sa : Stream<A>) => Stream<B> {\r\n        return (sa : Stream<A>) => {\r\n            const out = new StreamWithSend<B>(null);\r\n            out.setVertex__(new Vertex(\"map\", 0, [\r\n                    new Source(\r\n                        sa.getVertex__(),\r\n                        () => {\r\n                            return sa.listen_(out.getVertex__(), (a : A) => {\r\n                                performIO(a, (b : B) => {\r\n                                    Transaction.run(() => {\r\n                                        out.send_(b);\r\n                                    });\r\n                                });\r\n                            }, false);\r\n                        }\r\n                    )\r\n                ]\r\n            ));\r\n            return out;\r\n        }\r\n    }\r\n}\r\n"],"names":["rank","action","this","seq","Entry","nextSeq","toString","Collections.PriorityQueue","a","b","Collections.Set","Transaction","toRegen","target","e","prioritizedQ","enqueue","entries","add","h","sampleQ","push","lastQ","run","currentTransaction","collectCyclesAtEnd","childIx","postQ","length","existing","neu","clear","es","toArray","i","checkRegen","isEmpty","dequeue","remove","sq","parent_1","close","err","Vertex","collectCycles","r","onStartHooks","f","transWas","runningOnStartHooks","totalRegistrations","Color","origin","register_","Error","Source","registered","deregister_","increment","_this","decrement","roots","nextID","name","sources","black","id","targets","_collectCyclesAtEnd","anyChanged","refCount","register","childrn","ensureBiggerThan","matched","splice","deregister","src","limit","visited","colStr","color","gray","white","purple","str","refCountAdj","chs","children","referrer","incRefCount","decRefCount","release","possibleRoots","buffered","free","collectingCycles","markRoots","scanRoots","collectRoots","newRoots","markGray","scan","collectWhite","scanBlack","deps","lambda1","Lambda1","Lambda1_deps","Lambda1_toFunction","Lambda2_deps","Lambda2","Lambda2_toFunction","Lambda3_deps","Lambda3","Lambda3_toFunction","Lambda4_deps","Lambda4","Lambda4_toFunction","Lambda5_deps","Lambda5","Lambda5_toFunction","Lambda6_deps","Lambda6","Lambda6_toFunction","toSources","ss","dep","getVertex__","out","concat","accumValid","CoalesceHandler","accum","prioritized","send_","Lazy","c","d","Unit","Operational","getStream__","sSpark","StreamWithSend","UNIT","sInitial","snapshot1","updates","orElse","s","split","map","setVertex__","listen_","as","post","cell","initValue","value","setStream","Stream","vertex","Cell","me","valueUpdate","last","lazyInitValue","NULL","sampleNoTrans__","sampleLazyNoTrans__","LazySample","sample","hasValue","holdLazy","sampleLazy","fn0","fn","cf","aa","bb","apply","cc","dd","ee","ff","extractor","cKeepAlive","switchC","liftArray","x","hold","ca","_liftArray","fromInc","toExc","pivot","Math","floor","lift","array1","array2","state","ApplyState","cf_value","ca_value","src1","f_present","a_present","src2","coalesce__","l","cca","za","ba","last_ca","cca_value","kill2","kill1","csa","h2","sa","listen","_super","tslib_1.__extends","LazyCell","get","merge","left","right","coalescer","merge_","snapshot","pred","filterNotNull","f_","initState","collectLazy","ea","StreamLoop","ebs","eb","bs","es_out","loop","accumLazy","gate","mapTo","suppressEarlierFirings","requestRegen","listener","Listener","listeners","firings","firings_1","slice","removed","Z.Semigroup","test","Z.concat","inCallback","sa_out","assigned__","addSource","StreamSink","CellLoop","a_out","CellSink","send","t","sAlarm","impl","Collections.BSTree","tMinimum","timeSnk","now","time","onStart","max","ev","eventQueue","mev","minimum","TimerSystem","tAlarm","current","cancelCurrent","active","tAl","sampled","updateTimer","Event","setTimer","kill","oAlarm","SecondsTimerSystemImpl","callback","timeout","setTimeout","clearTimeout","Date","TimerSystemImpl","MillisecondsTimerSystemImpl","IOAction","performIO"],"mappings":"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"}